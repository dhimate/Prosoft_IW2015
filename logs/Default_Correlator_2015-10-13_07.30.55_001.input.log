VERS 00000001 4
HEAD 00000e97 <?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="/resources/transform.xslt"?><header><componentName>correlator</componentName><version>5.3.0.0.247085</version><build>rel/5.3.0.x@247085</build><buildPlatform>amd64-win</buildPlatform><platform>Windows Server 2008 R2 (Service Pack 1)</platform><cputype>AuthenticAMD family 15 model 8 stepping 0 Six-Core AMD Opteron(tm) Processor 2427</cputype><cpus>4</cpus><javaEnabled>true</javaEnabled><replayLogMode>inputLog</replayLogMode><args><arg>C:\SoftwareAG\Apama 5.3\bin\correlator.exe</arg><arg>--logQueueSizePeriod</arg><arg>0</arg><arg>-l</arg><arg>C:\SoftwareAG\ApamaWork_5.3\license\license.txt</arg><arg>--port</arg><arg>15903</arg><arg>--loglevel</arg><arg>INFO</arg><arg>--name</arg><arg>Apama Studio Correlator for Prosoft_IW2015(Prosoft_IW2015:Default Correlator)</arg><arg>-j</arg><arg>--jmsConfig</arg><arg>C:\SoftwareAG\ApamaWork_5.3\studio_workspace\.metadata\.plugins\org.eclipse.core.resources\.projects\Prosoft_IW2015\com.apama.text\JMS_Correlator-Integrated_Adapter</arg><arg>--inputLog</arg><arg>logs/Default_Correlator_${START_TIME}_${ID}.input.log</arg></args><environment><variable>ALLUSERSPROFILE=C:\ProgramData</variable><variable>APAMA_HOME=C:\SoftwareAG\Apama 5.3</variable><variable>APAMA_WORK=C:\SoftwareAG\ApamaWork_5.3</variable><variable>APPDATA=C:\Users\Administrator\AppData\Roaming</variable><variable>CLIENTNAME=PTGHP450-YD</variable><variable>COMMONPROGRAMFILES=C:\Program Files\Common Files</variable><variable>COMMONPROGRAMFILES(X86)=C:\Program Files (x86)\Common Files</variable><variable>COMMONPROGRAMW6432=C:\Program Files\Common Files</variable><variable>COMPUTERNAME=WMSERVER11</variable><variable>COMSPEC=C:\Windows\system32\cmd.exe</variable><variable>FP_NO_HOST_CHECK=NO</variable><variable>HOMEDRIVE=C:</variable><variable>HOMEPATH=\Users\Administrator</variable><variable>LOCALAPPDATA=C:\Users\Administrator\AppData\Local</variable><variable>LOGONSERVER=\\WMSERVER11</variable><variable>NUMBER_OF_PROCESSORS=4</variable><variable>OS=Windows_NT</variable><variable>PATH=C:\SoftwareAG\Apama 5.3\third_party\jre\bin\server;C:\SoftwareAG\Apama 5.3\third_party\jre\bin;C:\SoftwareAG\Apama 5.3\third_party\jre\lib\amd64\server;C:\SoftwareAG\Apama 5.3\third_party\jre\lib\amd64;C:\SoftwareAG\Apama 5.3\bin;C:\ProgramData\Oracle\Java\javapath;C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\</variable><variable>PATHEXT=.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC</variable><variable>PROCESSOR_ARCHITECTURE=AMD64</variable><variable>PROCESSOR_IDENTIFIER=AMD64 Family 16 Model 8 Stepping 0, AuthenticAMD</variable><variable>PROCESSOR_LEVEL=16</variable><variable>PROCESSOR_REVISION=0800</variable><variable>PROGRAMDATA=C:\ProgramData</variable><variable>PROGRAMFILES=C:\Program Files</variable><variable>PROGRAMFILES(X86)=C:\Program Files (x86)</variable><variable>PROGRAMW6432=C:\Program Files</variable><variable>PROMPT=$P$G</variable><variable>PSMODULEPATH=C:\Windows\system32\WindowsPowerShell\v1.0\Modules\</variable><variable>PUBLIC=C:\Users\Public</variable><variable>SESSIONNAME=RDP-Tcp#0</variable><variable>SYSTEMDRIVE=C:</variable><variable>SYSTEMROOT=C:\Windows</variable><variable>TEMP=C:\Users\ADMINI~1\AppData\Local\Temp\2</variable><variable>TMP=C:\Users\ADMINI~1\AppData\Local\Temp\2</variable><variable>USERDOMAIN=WMSERVER11</variable><variable>USERNAME=Administrator</variable><variable>USERPROFILE=C:\Users\Administrator</variable><variable>WINDIR=C:\Windows</variable><variable>WINDOWS_TRACING_FLAGS=3</variable><variable>WINDOWS_TRACING_LOGFILE=C:\BVTBin\Tests\installpackage\csilogfile.log</variable></environment><version>5.3.0.0.247085</version></header>
RAND 0000000a 1630443728
CONN 00000027 6205108723613202185:3955614762 from R01
CONN 00000036 6205108723613202185:3482309487 from internal:R:control
CONN 00000027 6205108723613202185:1865318693 from S01
CONN 0000003c 6795184426424404343:7002719621944117623 from 127.0.0.1:59298
CONN 0000003c 6795184426424404343:7002720270484310391 from 127.0.0.1:59295
CONN 0000003c 6795184426424404343:7002720798765353335 from 127.0.0.1:59296
TIME 0000000e 1444739459.6,1
MONF 00004657 package com.apama.dataview;

/*
 * $Copyright(c) 2007, 2008 Progress Software Corporation (PSC). All rights reserved.$
 * $Copyright (c) 2013-2014 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its Subsidiaries and or/its Affiliates and/or their licensors.$
 * Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG
 */


/* Apama DataViewService API.
 *
 * This service enables MonitorScript or JMon applications to expose a simple 
 * read-only "DataView" interface. DataViews may be viewed using Apama Dashboard 
 * Studio in a similar way to Scenarios.
 *
 * Several implementations of this interface will exist. 
 * Each implementation is in a separate file - inject the one you wish to use.
 *   e.g. DataViewService_Impl_Dict.mon
 *
 * Route vs. Emit
 * The standard implementations of the DataViewService will always ROUTE 
 * any com.apama.dataview.* events, with the expectation that applications
 * using the service are co-located in the same correlator as the service.
 * If your architecture requires the client application to be in a separate 
 * correlator to the DataView service, then two "emitter" monitors are 
 * available.
 * DataViewService_ServiceEmitter.mon  would be injected into the same 
 * correlator as the DataView service after injecting the DataViewService 
 * interface but before injecting the implementation.
 * DataViewService_ApplicationEmitter.mon  would be injected into the same 
 * correlator as the client application after injecting the DataViewService 
 * interface but before injecting the client application.
 * 
 *
 * Notes:
 * 
 * 1) Every event has an initial field called msgId. Clients may choose to put 
 *    some identifier in this field when sending messages to the service. Any 
 *    event routed by the service in response will contain the same identifier.
 *
 * 2) Most events contain a field called "dvName". This string 
 *    uniquely identifies a DataView inside the correlator. 
 *
 * 3) Every event has a final field called extraParams that is a string:string
 *    dictionary. Some implementations may choose to use this field. It provides
 *    a way of future-proofing the interface to a certain extent.
 *
 * $Revision: 221069 $
 */





/* ==========================================================================
 * ==========================================================================
 * Events to send to the DataViewService to manage the DataView schemas
 * ==========================================================================
 * ========================================================================== */


/** Define a new DataView type.
 *
 * Expect either a DataViewDefinition or a DataViewException in response.
 *
 * See also: DataViewDefinition() DataViewException(), DataViewAddItem()
 *
 * Direction: From the customer Monitor to the DataViewService.
 */
event DataViewAddDefinition {
	/** Optional application-defined message identifier used to correlate 
		requests and responses. */
	string msgId;
	/** The name that uniquely identifies this DataView (e.g. DataView_XXX) */
	string dvName;
	/** The display name of the DataView (e.g. "XXX manager") */
	string dvDisplayName;
	/** Optional field containing a description of this DataView 
		(e.g. "This DataView exposes XXX objects"). */
	string dvDescription;
	/** Specifies the names of each field exposed by the DataView. */
	sequence<string> fieldNames;
	/** Specifies the types corresponding to each field in the fieldNames sequence. 
		Supported types are: string, float, integer, boolean. */
	sequence<string> fieldTypes;
	/** Optional set of field names whose values in an Item are to be combined 
		to make a unique key that can be used instead of the dvItemId field of 
		DataViewDeleteItem, DataViewUpdateItem, and DataViewUpdateDelta events.
 	*/
	sequence<string> keyFields;
	/** Optional dictionary of parameters for future extensibility; 
		DataView implementation-specific parameters may also be stored here. */
	dictionary<string, string> extraParams;
}


/* Remove an existing DataView type.
 *
 * Direction: From the customer Monitor to the DataViewService.
 *
 * Response: DataViewUnloaded()
 */
event DataViewDeleteDefinition {
	string msgId;                            // [OPTIONAL] A messageId that applications may choose to use to identify "responses".
	string dvName;                           // The DataView Name (e.g. conventionally DataView_XXX)
	dictionary<string, string> extraParams;  // [OPTIONAL] Some implementations may choose to make use of this field.
}


/* Request helper dictionary to facilitate sequence position lookup
 *    by field name.
 *
 * See also: DataViewFieldLookup()
 *
 * Direction: From the customer Monitor to the DataViewService.
 *
 * Response: DataViewFieldLookup()
 */
event DataViewGetFieldLookup {
	string msgId;                            // [OPTIONAL] A messageId that applications may choose to use to identify "responses".
	string dvName;                           // The DataView Name (e.g. conventionally DataView_XXX)
	dictionary<string, string> extraParams;  // [OPTIONAL] Some implementations may choose to make use of this field.
}



/* ==========================================================================
 * ==========================================================================
 * Events to send to the DataViewService to manage individual DataView Items
 * ==========================================================================
 * ========================================================================== */


/* Request that a new Item is added to a specific DataView.
*
* See also: DataViewItem()
*
* Direction: From the customer Monitor to the DataViewService.
*/
event DataViewAddItem {
	string msgId;                            // [OPTIONAL] A messageId that applications may choose to use to identify "responses".
	string dvName;                           // the unique name of the DataView
	string owner;                            // the owner (user) of the Item.
	float timeStamp;                         // the timestamp of the initial update (seconds since epoch). If the value given is -1.0 then the service will populate it using correlator currentTime.
	sequence<string> fieldValues;            // complete sequence of field values in string form
	dictionary<string, string> extraParams;  // [OPTIONAL] Some implementations may choose to make use of this field.
}


/* Request that a new Item is added to a specific DataView if it does not already exist, 
* or is updated when it does exist. This will ONLY work when keyFields are used.
* Attempts to change the owner of an existing item will be rejected with a DataViewItemException.
*
* See also: DataViewItem()
*
* Direction: From the customer Monitor to the DataViewService.
*/
event DataViewAddOrUpdateItem {
	string msgId;                            // [OPTIONAL] A messageId that applications may choose to use to identify "responses".
	string dvName;                           // the unique name of the DataView
	string owner;                            // the owner (user) of the Item - ONLY used for new items.
	float timeStamp;                         // the timestamp of the initial update (seconds since epoch). If the value given is -1.0 then the service will populate it using correlator currentTime.
	sequence<string> fieldValues;            // complete sequence of field values in string form
	dictionary<string, string> extraParams;  // [OPTIONAL] Some implementations may choose to make use of this field.
}


/* Contains updated DataView Item fields.
 * Use this to update the fields.
 *
 * Direction: From the customer Monitor to the DataViewService.
 *
 */
event DataViewUpdateItem { 
	string msgId;                            // [OPTIONAL] A messageId that applications may choose to use to identify "responses".
	string dvName;                           // the unique name of the DataView
	integer dvItemId;                        // the ID of the Item within the DataView (may be -1 if using keyFields instead)
	float timeStamp;                         // the timestamp of the update (seconds since epoch). If the value given is -1.0 then the service will populate it using correlator currentTime.
	sequence<string> fieldValues;            // sequence of field values in string form
	dictionary<string, string> extraParams;  // [OPTIONAL] Some implementations may choose to make use of this field.
}


/* Contains updated DataView Item fields.
 * Use this to update the fields.
 *
 * Direction: From the customer Monitor to the DataViewService.
 *
 */
event DataViewUpdateItemDelta { 
	string msgId;                            // [OPTIONAL] A messageId that applications may choose to use to identify "responses".
	string dvName;                           // the unique name of the DataView
	integer dvItemId;                        // the ID of the Item within the DataView (may be -1 if using keyFields instead)
	float timeStamp;                         // the timestamp of the update (seconds since epoch). If the value given is -1.0 then the service will populate it using correlator currentTime.
	dictionary<integer,string> fieldValues;  // values to be updated. Dictionary Key is index into fields sequence, Value is new field value in sequence. 
	                                         // If not using dvItemId, then the dictionary MUST contain the key values (even though they have not changed)
	dictionary<string, string> extraParams;  // [OPTIONAL] Some implementations may choose to make use of this field.
}


/* Request that a specific Item within a specific DataView is deleted.
 *
 * See also: DataViewItemDeleted()
 *
 * Direction: From the customer Monitor to the DataViewService.
 */
event DataViewDeleteItem {
	string msgId;                            // [OPTIONAL] A messageId that applications may choose to use to identify "responses".
	string dvName;                           // the unique name of the DataView
	integer dvItemId;                        // the ID of the Item within the DataView (may be -1 if using keyFields instead)
	sequence<string> keyFields;              // [OPTIONAL] sequence of ONLY key field values (if not using the dvItemId)
	dictionary<string, string> extraParams;  // [OPTIONAL] Some implementations may choose to make use of this field.
}


/* Request that all Items within a specific DataView are deleted.
 *
 * See also: DataViewAllItemsDeleted()
 *
 * Direction: From the customer Monitor to the DataViewService.
 */
event DataViewDeleteAllItems {
	string msgId;                            // [OPTIONAL] A messageId that applications may choose to use to identify "responses".
	string dvName;                           // the unique name of the DataView
	dictionary<string, string> extraParams;  // [OPTIONAL] Some implementations may choose to make use of this field.
}


/* ==========================================================================
 * ==========================================================================
 * Events to that are callbacks from DatavViewService
 * ==========================================================================
 * ========================================================================== */


/** Confirmation that a specific DataView definition has been added.
 *
 * For information on the meaning of each field, see DataViewAddDefinition()
 *
 * Direction: From the DataViewService to the customer Monitor.
 */
event DataViewDefinition {
	string msgId;
	string dvName;
	string dvDisplayName;
	string dvDescription;
	sequence<string> fieldNames;
	sequence<string> fieldTypes;
	sequence<string> keyFields;
	dictionary<string, string> extraParams;
}


/* Indicates that a specific DataView definition is being unloaded.
 *
 * Direction: From the DataViewService to the customer Monitor.
 */
event DataViewDefinitionDeleted { 
	string msgId;                            // [OPTIONAL] A messageId that applications may choose to use to identify "responses".
	string dvName;                           // the unique name of the DataView
	dictionary<string, string> extraParams;  // [OPTIONAL] Some implementations may choose to make use of this field.
}


/* Notifies all interested clients that a new Item has been added to a specific 
 * DataView. 
 * The event provides the unique itemID, owner (user), and initial values for 
 * all fields.
 *
 * See also: DataViewAddItem()
 *
 * Direction: From the DataViewService to the customer Monitor.
 *
 */
event DataViewItem { 
	string msgId;                            // [OPTIONAL] A messageId that applications may choose to use to identify "responses".
	string dvName;                           // the unique name of the DataView
	integer dvItemId;                        // the ID of the Item within the DataView
	string owner;                            // the owner (user) of the Item.
	sequence<string> fieldValues;            // sequence of field values in string form
	dictionary<string, string> extraParams;  // [OPTIONAL] Some implementations may choose to make use of this field.
}


/* Notifies all interested clients that a specific Item within a specific 
 * DataView has been deleted.
 *
 * See also: DataViewDeleteItem()
 *
 * Direction: From the DataViewService to the customer Monitor.
 *
 */
event DataViewItemDeleted {
	string msgId;                            // [OPTIONAL] A messageId that applications may choose to use to identify "responses".
	string dvName;                           // the unique name of the DataView
	integer dvItemId;                        // the ID of the Item within the DataView
	sequence<string> keyFields;              // sequence of ONLY key field values (for those not using the dvItemId)
	dictionary<string, string> extraParams;  // [OPTIONAL] Some implementations may choose to make use of this field.
}


/* Notifies all interested clients that all Items within a specific 
 * DataView have been deleted.
 *
 * See also: DataViewDeleteAllItems()
 *
 * Direction: From the DataViewService to the customer Monitor.
 *
 */
event DataViewAllItemsDeleted {
	string msgId;                            // [OPTIONAL] A messageId that applications may choose to use to identify "responses".
	string dvName;                           // the unique name of the DataView
	dictionary<string, string> extraParams;  // [OPTIONAL] Some implementations may choose to make use of this field.
}


/* The helper dictionary to facilitate sequence position lookup
 *    by field name.
 *
 * See also: DataViewGetFieldLookup()
 *
 * Direction: From the DataViewService to the customer Monitor.
 */
event DataViewFieldLookup {
	string msgId;                            // [OPTIONAL] A messageId that applications may choose to use to identify "responses".
	string dvName;                           // The DataView Name (e.g. conventionally DataView_XXX)
	dictionary <string, integer> fields;     // A map of fieldName:fieldIndex
	dictionary<string, string> extraParams;  // [OPTIONAL] Some implementations may choose to make use of this field.
}


/* Indicates that an exception occurred within the DataViewService, and indicates 
* the name of the specific DataView.
*
* Direction: From the DataViewService to the customer Monitor.
*/
event DataViewException {
	string msgId;                            // [OPTIONAL] A messageId that applications may choose to use to identify "responses".
	string dvName;                           // the unique name of the DataView
	wildcard string message;                 // The message in the exception. This is designed to be human readable, and may change between implementations/versions, hence the wildcard.
	dictionary<string, string> extraParams;  // [OPTIONAL] Some implementations may choose to make use of this field.
}

/* Indicates that an exception occurred within the DataViewService, and indicates 
* the name of the specific DataView, and the Id of the specific Item.
*
* Direction: From the DataViewService to the customer Monitor.
*/
event DataViewItemException {
	string msgId;                            // [OPTIONAL] A messageId that applications may choose to use to identify "responses".
	string dvName;                           // the unique name of the DataView
	integer dvItemId;                        // the ID of the Item within the DataView
	wildcard string message;                 // The message in the exception. This is designed to be human readable, and may change between implementations/versions, hence the wildcard.
	dictionary<string, string> extraParams;  // [OPTIONAL] Some implementations may choose to make use of this field.
}


/* Indicates that the DataView service is being unloaded.
 *
 * Direction: From the DataViewService to the customer Monitor.
 */
event DataViewServiceUnloaded { 
	dictionary<string, string> extraParams;  // [OPTIONAL] Some implementations may choose to make use of this field.
}


monitor DataViewService_Interface {
	// MetaData relating to the interface
	dictionary<string,string> interfaceMetaData := {
		"interface.package"     :"com.apama.dataview",
		"interface.name"        :"DataViewService_Interface",
		"interface.fileName"    :"DataViewService_Interface.mon",
		"interface.vendor"      :"Apama",
		"interface.version"     :"5.3.0.0.247085",
		"interface.fullVersion" :"rel/5.3.0.x@247085",
		"interface.language"    :"MonitorScript"
	};

	action onload {
		log "DataViewService interface loaded. MetaData: "+interfaceMetaData.toString() at INFO;
	}
}

 0000003e C:\SoftwareAG\Apama 5.3\monitors\DataViewService_Interface.mon
TIME 0000000e 1444739459.7,1
MONF 00012519 package com.apama.scenario;

/**
 * This file contains the shared event definitions that are generic across 
 * all Scenarios.  
 *
 * WARNING: 
 *    The event definitions contained in this file form an internal protocol 
 *    and may change between software releases.
 *
 * Notes:
 * 1) The Event definitions contained in this file MUST be considered
 *    as an internal implementation of the communications protocol
 *    between the Apama client API and an Apama server.  As such
 *    these event definitions MUST NOT be considered "stable" and are 
 *    subject to change in any future software release.
 *
 *    The ONLY supported public APIs to the Scenario Service are the 
 *    Java client API (in the com.apama.services.scenario package) and the 
 *    .NET client API (in the Apama.Services.Scenario namespace).  
 *    Customers should not attempt to interface at the event or 
 *    EPL layer. Some events have been changed over time (as 
 *    noted here).
 *
 * 2) Most events now contain an initial field called "scenarioId". This string 
 *    uniquely identifies a scenario inside the correlator, and is used as 
 *    the package name, in several events, and for making up a part of the 
 *    data and control channel names.
 *
 * 3) Events that are intended to be used in a request-response pattern contain
 *    a "messageId" field.  The value of this field must be copied from the 
 *    request event into the response event. The mechanism allows clients to 
 *    match up request-response pairs.
 *
 *
 * $Copyright(c) 2005-2011 Progress Software Corporation (PSC). All rights reserved.$
 * $Copyright (c) 2013-2014 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its Subsidiaries and or/its Affiliates and/or their licensors.$
 * Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG
 *
 * $Revision: 242755 $
 */

/**
 * Request that a new instance of a specific scenario is created.
 *
 * See also: Created(), Acknowledge()
 *
 * Direction: From the client to the correlator.
 *
 * Response: Acknowledge()
 */
event Create {
	string scenarioId;                   // the unique name of the scenario
	integer messageId;                   // the unique message ID (for request-response matching)
	string owner;                        // the owner (user) of the instance.
	sequence<string> inputFieldValues;   // sequence of INPUT field values in string form
}

/**
 * Notifies all interested clients that a new instance of a specific 
 * scenario has been created. 
 * The event provides the owner (user), initial state, and initial values for 
 * all input fields and all output fields.
 *
 * See also: Create()
 *
 * Direction: From the correlator to the client.
 *
 * Channel: <scenarioId>.Data and <scenarioId>.Data.Raw
 */
event Created { 
	string scenarioId;                   // the unique name of the scenario
	integer messageId;                   // the unique message ID (for request-response matching)
	integer scenarioInstanceId;          // the ID of the scenario instance
	string owner;                        // the owner (user) of the instance.
	string state;                        // the initial state of the instance.
	sequence<string> inputFieldValues;   // sequence of INPUT field values in string form
	sequence<string> outputFieldValues;  // sequence of OUTPUT field values in string form
}


/**
 * Notifies the interested clients of child scenarios created from
 * a parent scenario.
 *
 * Direction: Internal in the correlator
 *
 * Channel: <none>
 */
event ParentChildRelationship {
	string parentScenarioId;
	integer parentScenarioInstanceId;
	string childScenarioId;
	integer childScenarioInstanceId;
}


/**
 * Request that a specific instance of a specific scenario is edited (the input 
 * field values are changed).
 *
 * See also: Edited(), Acknowledge()
 *
 * Direction: From the client to the correlator.
 *
 * Response: Acknowledge()
 */
event Edit { 
	string scenarioId;                   // the unique name of the scenario
	integer messageId;                   // the unique message ID (for request-response matching)
	integer scenarioInstanceId;          // the ID of the scenario instance
	sequence<string> inputFieldValues;   // sequence of INPUT field values in string form
}


/**
 * Notifies all interested clients that a specific instance of a specific 
 * scenario has been edited (the input field values have changed).
 *
 * See also: Edit()
 *
 * Direction: From the correlator to the client.
 *
 * Channel: <scenarioId>.Data and <scenarioId>.Data.Raw
 */
event Edited { 
	string scenarioId;                   // the unique name of the scenario
	integer messageId;                   // the unique message ID (for request-response matching)
	integer scenarioInstanceId;          // the ID of the scenario instance
	sequence<string> inputFieldValues;   // sequence of INPUT field values in string form
	sequence<string> outputFieldValues;  // sequence of OUTPUT field values in string form
}


/**
 * Request that a specific instance of a specific scenario is deleted.
 *
 * See also: Deleted(), Acknowledge()
 *
 * Direction: From the client to the correlator.
 *
 * Response: Acknowledge()
 */
event Delete {
	string scenarioId;                   // the unique name of the scenario
	integer messageId;                   // the unique message ID (for request-response matching)
	integer scenarioInstanceId;          // the ID of the scenario instance
}


/**
 * Notifies all interested clients that a specific instance of a specific 
 * scenario has been deleted.
 *
 * See also: Delete()
 *
 * Direction: From the correlator to the client.
 *
 * Channel: <scenarioId>.Data and <scenarioId>.Data.Raw
 */
event Deleted {
	string scenarioId;                   // the unique name of the scenario
	integer messageId;                   // the unique message ID (for request-response matching)
	integer scenarioInstanceId;          // the ID of the scenario instance
}


/**
 * Indicates that a specific instance of a specific scenario has died.
 * This is sent as a result of a scenario instance use of MonitorScript ondie.
 * This occurs for any of deleting a running scenario, a scenario failing, or 
 * entering the end state.
 *
 * Direction: From the correlator to the client.
 *
 * Channel: <scenarioId>.Data and <scenarioId>.Data.Raw
 */
event InstanceDied {
	string scenarioId;                   // the unique name of the scenario
	integer scenarioInstanceId;          // the ID of the scenario instance
}


/**
 * Contains updated scenario instance output fields.
 * Note that this is the ONLY event type that is sendted on the 
 * "<scenarioId>.Data" channel.
 *
 * Direction: From the correlator to the client.
 *
 * Channel: <scenarioId>.Data and <scenarioId>.Data.Raw
 */
event Update { 
	string scenarioId;                   // the unique name of the scenario
	integer scenarioInstanceId;          // the ID of the scenario instance
	float timeStamp;                     // the time of the update (seconds since epoch)
	sequence<string> outputFieldValues;  // sequence of OUTPUT field values in string form
}


/**
 * A general Acknowledgement event that is the "response" to various "request"
 * events such as Create, Edit, Delete.
 *
 * Direction: From the correlator to the client.
 *
 * Channel: <scenarioId>.Control
 */
event Acknowledge { 
	string scenarioId;                   // the unique name of the scenario
	integer messageId;                   // the unique message ID (for request-response matching)
	integer scenarioInstanceId;          // the id of the scenario instance
	boolean success;                     // boolean indication of success
	sequence<string> outputFieldValues;  // sequence of the OUTPUT field values in string form, 
	                                     //   or an empty sequence if success = false
}


/**
 * Indicates that a specific instance of a specific scenario has changed 
 * state, where valid states include "ENDED", "FAILED", "RUNNING".
 *
 * Direction: From the correlator to the client.
 *
 * Channel: <scenarioId>.Data and <scenarioId>.Data.Raw
 */
event StateChange { 
	string scenarioId;                   // the unique name of the scenario.
	integer scenarioInstanceId;          // the ID of the scenario instance.
	string state;                        // the new state.
}


/**
 * Request that each scenario loaded in the correlator send its meta
 * information out on the supplied channel. When all scenarios have
 * sent out this information, a final RequestScenariosDone event will
 * be sent on the same channel.
 *
 * As soon as this event is received, a RequestScenariosAck will be
 * sent on the same channel so client can stop resending the RequestScenarios
 * event.
 *
 * See also: Scenario, RequestScenariosDone, RequestScenariosAck
 *
 * Direction: From the client to the correlator.
 *
 * Response: Scenario() from each loaded scenario.
 */
event RequestScenarios { 
	// renamed for clarity - was Request
	string channel;                      // Name of the private response channel.
}


/**
 * This is a simple marker event that is sent by the correlator to indicate 
 * that it has finished sending all of the Scenario events in response
 * to a RequestScenarios event.
 * 
 * See also: RequestScenarios, Scenario.
 *
 * Direction: From the correlator to the client.
 *
 * Channel: The private channel that was specified in the RequestScenarios event.
 */
event RequestScenariosDone {}

/* This is a simple ack event that is sent by the correlator to indicate the
 * RequestScenarios event is received and the request is being processed
 *
 * See also: RequestScenarios
 *
 * Direction: From the correlator to the client.
 *
 * Channel: The private channel that was specified in the RequestScenarios event.
 */
event RequestScenariosAck {}

/**
 * Request that each instance of the specified scenario send an Instance event 
 * out on the supplied channel. When all instances for the scenario have been 
 * sent out, a final RequestInstancesDone event will be sent on the same channel.
 *
 * See also: Instance, RequestInstancesDone
 *
 * Direction: From the client to the correlator.
 *
 * Response: Instance() from each scenario instance.
 */
event RequestInstancesOnChannel { 
	string scenarioId;                   // Identifier of the scenario for which to return instances. 
	integer messageId;                   // the unique message ID (for request-response matching)
	string channel;                      // Name of the private response channel.
}

/**
 * Request that each instance for the specified user of the specified scenario
 * send an Instance event out on the supplied channel. When all instances for
 * the scenario have been sent out, a final RequestInstancesDone event will be 
 * sent on the same channel.
 *
 * See also: Instance, RequestInstancesDone
 *
 * Direction: From the client to the correlator.
 *
 * Response: Instance() from each scenario instance.
 */
event RequestInstancesOnChannelByUser { 
	string scenarioId;                   // Identifier of the scenario for which to return instances. 
	integer messageId;                   // the unique message ID (for request-response matching)
	string channel;                      // Name of the private response channel.
	string owner;                        // the username to filter by
}


/**
 * This is a simple marker event that is sent by the correlator to indicate 
 * that it has finished sending all of the Instance events in response
 * to a RequestInstancesInternal event.
 * 
 * See also: RequestInstancesInternal, Scenario.
 *
 * Direction: From the correlator to the client.
 *
 * Channel: A unique private channel as specified by the client in a 
 *          RequestScenariosOnChannel event.
 *
 *          Note that previously it would have been on <scenarioId>.Data and 
 *          <scenarioId>.Data.Raw, but that behaviour is now deprecated.
 */
event RequestInstancesDone {
	string scenarioId;                   // Identifier of the scenario for instances were returned. 	
	integer messageId;                   // the unique message ID (for request-response matching)
}


/**
 * Describes the meta-information about a scenario that is loaded in the 
 * correlator.
 * 
 * See also: RequestScenarios, RequestScenariosDone, ScenarioUnloaded
 * 
 * Direction: From correlator to client.
 *
 * Channel:   1) com.apama.scenario to broadcast when loaded.
 *            2) A unique private channel as specified by the client in a 
 *               RequestScenarios event.
 *
 * This event has gained the executionMode field in Apama 4.2
 */
event Scenario {
	string scenarioId;                   // unique identifier for Scenario, e.g. Scenario_statistical$002darbitrage
	string displayName;                  // user-specified name for Scenario, e.g. statistical-arbitrage
	string description;                  // description of the Scenario
	sequence<string> inputNames;         // input parameter names
	sequence<string> inputTypes;         // input parameter types
	sequence<string> inputConstraints;   // input parameter contraints
	sequence<string> inputDefaults;      // input parameter default values
	sequence<string> outputNames;        // output parameter names
	sequence<string> outputTypes;        // output parameter types
	integer executionMode;               // 0 = serial, 1 = parallel, 2 = parallel child. New as of 4.2
	dictionary<string, string> extraParams; // Additional parameters
}



/**
 * Indicates that a specific Scenario definition is being unloaded.
 *
 * Direction: From the correlator to the client.
 *
 * Channel: <scenarioId>.Control
 */
event ScenarioUnloaded { 
	string scenarioId;                   // the unique name of the scenario
}

/**
 * Provides a dump of the current state of a scenario instance.
 * The event definition is identical to the Created event, and includes the 
 * owner (user), initial state, and current values for all input fields and 
 * all output fields.
 *
 * Instance events are sent in response to RequestInstancesOnChannel event 
 * and the deprecated RequestInstancesInternal event; 
 *
 * See also: RequestInstancesOnChannel, RequestInstancesDone, RequestInstancesInternal
 *
 * Direction: From the correlator to the client.
 *
 * Channel: A unique private channel as specified by the client in a 
 *          RequestScenariosOnChannel event.
 *
 *          Note that previously it would have been on <scenarioId>.Data and 
 *          <scenarioId>.Data.Raw, but that behaviour is now deprecated.
 */
event Instance {
	string scenarioId;                   // the unique name of the scenario. 
	integer messageId;                   // the unique message ID (for request-response matching)
	integer scenarioInstanceId;          // the ID of the scenario instance. 
	string owner;                        // the owner (user) of the instance.
	string state;                        // the initial state of the instance.
	sequence<string> inputFieldValues;   // sequence of INPUT field values in string form. 
	sequence<string> outputFieldValues;  // sequence of OUTPUT field values in string form. 
}


/**
 * Indicates this shared MonitorScript has been loaded.
 *
 * Direction: From the correlator to the client.
 *
 * Channel: com.apama.scenario to broadcast when loaded.
 */
event ScenarioServiceLoaded { 
}

/**
 * Indicates this shared MonitorScript is being unloaded.
 *
 * Direction: From the correlator to the client.
 *
 * Channel: com.apama.scenario to broadcast when unloaded.
 */
event ScenarioServiceUnloaded { 
}


/**
 * Set the period over which updates will be queued and coalesced before being
 * sent out on the data channel. Defaults to zero, which means they won't be
 * queued. If it is negative then we won't send any updates on the data channel.
 * This event is deprecated and the ConfigureUpdates event should be used 
 * instead (see below)
 */
event SetThrottlingPeriod {
	float period;   // The period in seconds. Default zero.
}


/**
 * Configures how updates are sent from scenarios.
 * Each scenario is controlled by two configurations - a global default,
 * and an optional per scenario configuration.  The per scenario
 * configuration takes precedence over the global default.
 * The configuration is made up of a number of entries in 
 * the configuration dictionary. The ConfigureUpdate event 
 * is merged into any previous configuration.
 *
 * Global configuration can be modified by specifying an empty string 
 * for scenarioId, and empty values remove values.
 */
event ConfigureUpdates {
	/** Specifies the scenario the configuratio will apply to, or use 
		empty string "" to specify a global default. 
	*/
	string scenarioId;
	/** 
	 * A set of the configurations modified by this event
	 * the key and meaning is one of:
	 * sendThrottled - boolean - whether to send Updates to the 
	 *                           Throttled (.Data) channel (default=true)
	 * throttlePeriod - float - period with which to send Updates. 
	 *                          0.0 means updates are not throttled - 
	 *                          every update is sent on the Throttled 
	 *                          channel. (default=0.0)
	 * sendRaw - boolean - whether to send Updates on the Raw channel 
	 *                     (.Raw) (default=true)
 	 * sendThrottledUser - boolean - whether to send Updates to the 
	 *                     throttled filtered (.Data:username) channel
	 *                     (default=false)
 	 * sendRawUser - boolean - whether to send Updates to the Raw 
	 *                     channel (.Raw:username) (default=false)
	 * routeUpdate - boolean - whether to route Update (and Edited, Deleted) events.
	 * An empty value removes that entry from the configuration
	 */
	dictionary<string,string> configuration;
}

/**
 * Immediately flushes to receivers any scenario Update events that were 
 * waiting for the next throttling period before being sent. 
 * 
 */
event SendQueuedUpdatesNow {
	
}

/* ==========================================================================
 * The following describes INTERNAL event definitions that should not be sent 
 * into the correlator, nor relied upon.
 * ==========================================================================
 */

/**
 * Request that each instance of the specified scenario send an Instance event 
 * out on the scenario Data or Raw channel. When all instances for the scenario
 * have been sent out, a final RequestInstancesDone event will be sent on the 
 * same channel.
 *
 * See also: Instance, RequestInstancesDone, RequestInstancesOnChannel, RequestInstancesOnChannelByUser
 *
 * Direction: From the ScenarioService to the scenario
 *
 * Response: Instance() from each scenario instance, RequestInstancesDone when finished.
 */
event RequestInstancesInternal { 
	string scenarioId;                   // Identifier of the scenario for which to return instances. 
	integer messageId;                   // the unique message ID (for request-response matching)
	string channel;                      // Name of the private response channel.
	boolean internal;                    // if true, events should be routed/ send-to'd the main context
	string owner;                        // owner filter (optional)
	boolean ownerFilter;                 // whether to filter by owner
}

/**
 * A scenario has finished running, but is still discoverable.
 * (i.e. entered end state or failed - but not deleted).
 * Note that this event contains the state as of the last
 * Update/ Edited event - i.e. if an action modified an output variable 
 * and then caused the scenario to fail, the prior modification
 * would not be reflected in this event.
 *
 * This event contains sufficient information for discovery of the
 * scenario instance later
 * 
 * Direction: from scenarios to the ScenarioService sub-monitor (spawned per scenario)
 */
event ScenarioFinished {
	string scenarioId;                   // Identifier of the scenario which has failed. 
	integer scenarioInstanceId;          // the ID of the scenario instance. 
	string owner;                        // the owner (user) of the instance.
	string state;                        // the initial state of the instance.
	sequence<string> inputFieldValues;   // sequence of INPUT field values in string form. 
	sequence<string> outputFieldValues;  // sequence of OUTPUT field values in string form. 
}
/**
 * Only used internally to tell all the scenarios to start routing their
 * meta data (Scenario). It is followed by a sweeper FinishedScenarioRecovery
 * event which indicates that all the scenarios have reported in.
 */
event StartScenarioRecovery {}

/**
 * Sweeper event to indicate that scenario recovery is done. Only used internally.
 */
event FinishedScenarioRecovery {}

/**
 * Trigger discovery of a parallel scenario. Sent from a sub-monitor of
 * ScenarioService to RequestInstancesHandler to create a new sub-monitor.
 */
event RequestInstancesParallel {
	RequestInstancesInternal request;          // the original request event
	dictionary<integer, context> instances;    // all scenario instances and their running context
	integer highestInstanceId;                 // the highest scenarioInstanceId listed in instances (or more accurately, the highest when discovery started)
}

/**
 * Discovery protocol of a parallel scenario. Sent from a scenario instance
 * to RequestInstancesHandler.
 */
event RequestInstancesParallelDone {
	string scenarioId;                   // the unique name of the scenario
	integer messageId;                   // the unique message ID (for request-response matching)
	integer scenarioInstanceId;          // the ID of the scenario instance
}

/**
 * Notification of a new scenario instance
 */
event ParallelStarting {
	string scenarioId;                   // the unique name of the scenario
	integer scenarioInstanceId;          // the ID of the scenario instance
	string owner;                        // the owner of the scenario instance
	context runningCtx;                  // the context the scenario is running in
}

/**
 * Get the current configuration for a given scenario and the default configuration
 */
event GetConfiguration {
	string scenarioId;                   // the unique name of the scenario
}

/**
 * The current configuration for a given scenario and the default configuration
 * @see ConfigureUpdates
 */
event Configuration {
	string scenarioId;                        // the unique name of the scenario
	dictionary<string, string> defaults;      // the global defaults
	dictionary<string, string> configuration; // the scenario configuration (takes precedence)
}


/**
 * An operation has completed. Sent from parallel scenarios to the main context.
 */
event OperationCompleted {
	string scenarioId;
	integer scenarioInstanceId;
	integer messageId;
}

/**
 * Notification that a scenario has loaded a ConfigureUpdates event
 */
event ScenarioProcessedUpdates {
	string scenarioId;
}

/**
 * Request all configuration
 */
event GetAllConfiguration {
	integer requestId;
}

/** 
 * Response all configuration
 */
event AllConfiguration {
	integer requestId;
	dictionary<string, string> defaultConfig;
	dictionary<string, dictionary<string, string> > configurations;
}


/**
 * Library of utiltiy actions
 */
event ScenarioServiceLibrary {

	/**
	 * Get the control channel for a scenario Id. This channel
	 * is always enabled (uses an event set scenario ID)
	 */
	action getControlChannel(string scenarioId) returns string
	{
		return scenarioId+".Control";
	}
	/**
	 * Get the data channel for a scenario ID. This channel 
	 * is enabled by the sendThrottled configuration key and 
	 * the throttlePeriod key (Update events may be throttled)
	 */
	action getDataChannel(string scenarioId) returns string
	{
		return scenarioId+".Data";
	}
	/**
	 * Get the raw channel for a scenario ID. This channel
	 * is enabled by the sendRaw configuration key.
	 */
	action getRawChannel(string scenarioId) returns string
	{
		return scenarioId+".Data.Raw";
	}
	/**
	 * Get the data channel for a scenario Id. This channel 
	 * is enabled by the sendThrottledUser configuration key and 
	 * the throttlePeriod key (Update events may be throttled)
	 */
	action getDataUserChannel(string channel, string owner) returns string
	{
		return channel+":"+owner;
	}
	/**
	 * Get the raw channel for a scenario Id. This channel
	 * is enabled by the sendRawUser configuration key.
	 */
	action getRawUserChannel(string channel, string owner) returns string
	{
		return channel+":"+owner;
	}
	
	/**
	 * Merge configuration. Any entries in updates overwrite entries in configuration.
	 * An empty string value removes the value.
	 * @see ConfigureUpdates
	 */
	action mergeConfiguration(dictionary<string, string> updates, dictionary<string, string> configuration) {
		string k;
		for k in updates.keys() {
			configuration[k]:=updates[k];
			if updates[k]="" then {
				configuration.remove(k);
			}
		}
	}
	
	// implementation note: the defaults for sendThrottled, sendRaw, throttlePeriod, etc are in the following actions:
	/**
	 * Get the sendThrottled value from the given configuration
	 * @see ConfigureUpdates
	 */
	action getSendThrottled(dictionary<string,string> defaults, dictionary<string,string> config) returns boolean {
		string c:=getConfig(defaults, config, "sendThrottled", "true");
		return c = "true";
	}

	/**
	 * Get the sendThrottledUser value from the given configuration
	 * @see ConfigureUpdates
	 */
	action getSendThrottledUser(dictionary<string,string> defaults, dictionary<string,string> config) returns boolean {
		string c:=getConfig(defaults, config, "sendThrottledUser", "false");
		return c = "true";
	}
	
	/**
	 * Get the sendRaw value from the given configuration
	 * @see ConfigureUpdates
	 */
	action getSendRaw(dictionary<string,string> defaults, dictionary<string,string> config) returns boolean {
		string c:=getConfig(defaults, config, "sendRaw", "true");
		return c = "true";
	}
	
	/**
	 * Get the sendRawUser value from the given configuration
	 * @see ConfigureUpdates
	 */
	action getSendRawUser(dictionary<string,string> defaults, dictionary<string,string> config) returns boolean {
		string c:=getConfig(defaults, config, "sendRawUser", "false");
		return c = "true";
	}
	
	/**
	 * Get the throttlePeriod value from the given configuration
	 * @see ConfigureUpdates
	 */
	action getThrottlePeriod(dictionary<string,string> defaults, dictionary<string,string> config) returns float {
		string c:=getConfig(defaults, config, "throttlePeriod", "0.0");
		return float.parse(c);
	}
	
	/**
	 * Get the routeUpdate value from the given configuration
	 * @see ConfigureUpdates
	 */
	action getRouteUpdate(dictionary<string,string> defaults, dictionary<string,string> config) returns boolean {
		string c:=getConfig(defaults, config, "routeUpdate", "false");
		return c = "true";
	}
	

	/**
	 * Get the specified key from the configuration dictionaries, reverting to the default 
	 * if none specified.
	 */
	action getConfig(dictionary<string,string> defaults,
	                 dictionary<string,string> config, 
	                 string key, string _default) returns string {
		if config.hasKey(key) then {
			return config[key];
		}
		if defaults.hasKey(key) then {
			return defaults[key];
		}
		return _default;
	}

	action configurationManager(dictionary<string, string> defaultConfig, dictionary<string, dictionary<string, string> > configurations) {
		// the recognised ConfigureUpdates configuration keys, as above:
		dictionary<string,boolean> KNOWN_CONFIG_KEYS := {"sendThrottled":true, "throttlePeriod":false,
		 "sendRaw":true, "sendThrottledUser":true, "sendRawUser":true, "routeUpdate":true};

		dictionary <string,string> EMPTY_DICT:=new dictionary<string,string>;
		ConfigureUpdates cu;
		on all ConfigureUpdates():cu {
			string key;
			for key in cu.configuration.keys() {
				if not KNOWN_CONFIG_KEYS.hasKey(key) then {
					log "Unrecognized configuration property "+key+" in event "+cu.toString() at WARN;
				}
			}
			if cu.scenarioId = "" then {
				mergeConfiguration(cu.configuration, defaultConfig);
				log "Received "+cu.toString()+" : defaults applicable to all scenarios" at INFO;
			} else {
				if not configurations.hasKey(cu.scenarioId) then {
					configurations.add(cu.scenarioId, new dictionary<string,string>);
				}
				mergeConfiguration(cu.configuration, configurations[cu.scenarioId]);
				on ScenarioProcessedUpdates(cu.scenarioId) -> completed ConfigureUpdates(scenarioId=cu.scenarioId) {
					log "Received "+cu.toString()+" : applied to scenario" at INFO;
				}
				on completed ConfigureUpdates(scenarioId=cu.scenarioId) and not ScenarioProcessedUpdates(cu.scenarioId) {
					log "Received "+cu.toString()+" : for scenario that is not yet defined" at INFO;
				}
			}
		}

		GetConfiguration getConfig;
		on all GetConfiguration():getConfig {
			dictionary<string,string> config:=EMPTY_DICT;
			if configurations.hasKey(getConfig.scenarioId) then {
				config:=configurations[getConfig.scenarioId];
			}
			route Configuration(getConfig.scenarioId, defaultConfig, config);
		}	
		GetAllConfiguration gac;
		on all GetAllConfiguration():gac {
			route AllConfiguration(gac.requestId, defaultConfig, configurations);
		}
	}
		
}

event CallbackHelper {
	sequence<action<> > callbacks;
	action callback {
		action<> c;
		for c in callbacks {
			c();
		}
	}
}



/**
 * Base event for tracking configuration for a given scenario
 */
event ScenarioServiceUpdaterBase {
	// these are internal and should not be set by users
	string scenarioId;
	dictionary<string,string> defaultConfig;
	dictionary<string,string> config;
	ScenarioServiceLibrary lib;
	boolean sendThrottled;
	boolean sendRaw;
	boolean sendAny;
	boolean emitAny;
	boolean sendThrottledUser;
	boolean sendRawUser;
	boolean routeUpdate;
	float throttlePeriod;
	float throttleStart;
	sequence<listener> listeners;
	string controlChannel;
	string rawChannel;
	string dataChannel;

	/**
	 * Called by monitor at onload time
	 * Will maintain configuration for this scenario
	 * @param sId the scenarioId
	 */
	action init(string sId, action<> cb_onUpdate) {
		scenarioId:=sId;
		controlChannel := lib.getControlChannel(scenarioId);
		rawChannel := lib.getRawChannel(scenarioId);
		dataChannel := lib.getDataChannel(scenarioId);
		route GetConfiguration(scenarioId);
		Configuration c;
		listener l:=on Configuration(scenarioId=scenarioId):c {
			config := c.configuration;
			defaultConfig := c.defaults;
			configurationUpdated();
			cb_onUpdate();
		}
		listeners.append(l);
	}

	/**
	 * Listen for further configuration changes.
	 * @param cb_onUpdate callback upon configuration having been updated
	 */	
	action listenToConfigureUpdates(action<> cb_onUpdate) {
		ConfigureUpdates cu;
		listener l:=on all ConfigureUpdates(scenarioId=""):cu or all ConfigureUpdates(scenarioId=scenarioId):cu {
			if(cu.scenarioId != "") then {
				route ScenarioProcessedUpdates(cu.scenarioId);
			}
			onConfigureUpdates(cu);
			cb_onUpdate();
		}
		listeners.append(l);
	}

	/**
	 * Called when new ConfigureUpdates event available
	 * @param sId the scenarioId
	 */
	action onConfigureUpdates(ConfigureUpdates cu) {
		if cu.scenarioId = "" then {
			lib.mergeConfiguration(cu.configuration, defaultConfig);
		} else {
			lib.mergeConfiguration(cu.configuration, config);
		}
		configurationUpdated();
	}
	
	/**
	 * Called when the configuration should be re-parsed.
	 * @param sId the scenarioId
	 */
	action configurationUpdated() {
		sendThrottled:=lib.getSendThrottled(defaultConfig, config);
		sendThrottledUser:=lib.getSendThrottledUser(defaultConfig, config);
		if sendThrottled or sendThrottledUser then {
			throttlePeriod:=lib.getThrottlePeriod(defaultConfig, config);
			if(throttlePeriod < 0.0) then {
				sendThrottled:=false;
				sendThrottledUser:=false;
			}
			throttleStart:=currentTime;
		}
		sendRaw:=lib.getSendRaw(defaultConfig, config);
		sendRawUser:=lib.getSendRawUser(defaultConfig, config);
		routeUpdate:=lib.getRouteUpdate(defaultConfig, config);
		sendAny:= sendRaw or sendThrottled or routeUpdate or sendRawUser or sendThrottledUser;
		emitAny:= sendRaw or sendThrottled or sendRawUser or sendThrottledUser;
	}

	/** 
	 * Get whether this scenario should send on the throttled (Data) channel
	 */
	action isSendThrottled() returns boolean {
		return sendThrottled or sendThrottledUser;
	}

	/** 
	 * Get whether this scenario should send on the raw channel
	 */
	action isSendRaw() returns boolean {
		return sendRaw or sendRawUser;
	}

	action doEmit(string emitted, string owner) {
		if sendRaw then {
			emit emitted to rawChannel;
		}
		if sendThrottled then {
			emit emitted to dataChannel;
		}
		if sendRawUser then {
			emit emitted to lib.getRawUserChannel(rawChannel, owner);
		}
		if sendThrottledUser then {
			emit emitted to lib.getDataUserChannel(dataChannel, owner);
		}
	}

	/**
 	 * Kill any listeners this object has started
	 */
	action destroy() {
		listener l;
		for l in listeners {
			l.quit();
		}
	}
}


/**
 * Utility event for tracking configuration for a given scenario.
 * This event is suitable for use by monitors which spawn per instance
 * (e.g. Scenarios)
 * 
 * This event also uses a callback to get the updates (supplied in
 * instanceInit). If the scenario is configured to only send throttled 
 * updates, the callback is only called when the throttling period 
 * determines an update should be sent - thus, the scenario does not
 * need to generate the output sequence<string> except when needed,
 * which can improve performance in such a configuration.
 * 
 * actions starting with an underscore should be considered private 
 * and not called by users of this event.
 */
event ScenarioServiceUpdaterSingleInstance {
	// these are internal and should not be set by users
	string scenarioId;
	integer scenarioInstanceId;
	ScenarioServiceLibrary lib;
	listener throttlingListener;
	ScenarioServiceUpdaterBase base;
	boolean havePending;
	float latestUpdate;
	action<> returns sequence<string> getUpdate;
	Update update;
	boolean needUpdate;
	context mainContext;
	string owner;
	string controlChannel;
	string rawChannel;
	string dataChannel;

	/**
	 * Called by monitor at onload time
	 * Will maintain configuration for this scenario
	 */
	action init(string sId) {
		init_cb(sId, _noopAction);
	}
	
	/**
	 * Called by monitor at onload time
	 * Will maintain configuration for this scenario.
	 * cb_init is called when initialisation is complete
	 */
	action init_cb(string sId, action<> cb_init) {
		base.init(sId, cb_init);
		scenarioId:=sId;
		controlChannel := lib.getControlChannel(scenarioId);
		rawChannel := lib.getRawChannel(scenarioId);
		dataChannel := lib.getDataChannel(scenarioId);
		base.listenToConfigureUpdates(_noopAction);
		mainContext:=context.current();
	}

	action _noopAction() {
	}
	

	/**
	 * Called by monitor after spawn
	 * Will maintain configuration for this scenario, and update listeners appropriately.
	 * @param getUpdateCallback a callback to get the latest outputFieldValues - may be called at any time, must 
         *        always return a consistent set of outputs
	 */
	action instanceInit(integer id, action<> returns sequence<string> getUpdateCallback, string _owner) {
		scenarioInstanceId:=id;
		owner:=_owner;
		getUpdate:=getUpdateCallback;
		update.scenarioId:=scenarioId;
		update.scenarioInstanceId:=scenarioInstanceId;
		base.listenToConfigureUpdates(_configurationUpdated);
		_configurationUpdated();
		listener l:=on all SendQueuedUpdatesNow() {
			_sendThrottledUpdate();
		}
		base.listeners.append(l);
	}

	/** 
	 * Get whether this scenario should route updates
	 */
	action isRouteUpdate() returns boolean {
		return base.routeUpdate;
	}

	/**
 	 * Kill any listeners this object has started
	 */
	action destroy() {
		base.destroy();
		throttlingListener.quit();
	}
	  
	/**
	 * called in instances (not factories) when configuration has changed
	 */
	action _configurationUpdated {
		if base.isSendThrottled() then {
			throttlingListener.quit();
			flushPending();
			if(base.throttlePeriod >= 0.0) then {
				if havePending then {
					_setupThrottleListener();
				}
			}
		}
	}

	/**
	 * set up a throttled listener according to throttlePeriod control
	 */
	action _setupThrottleListener {
		if base.throttlePeriod > 0.0 then {
			float offset:=currentTime-base.throttleStart;
			float t:=((offset/base.throttlePeriod).floor()+1).toFloat();
			throttlingListener:=on wait((t*base.throttlePeriod)-offset) {
				_sendThrottledUpdate();
			}
		} else {
			_sendThrottledUpdate();
		}
	}

	/**
	 * actually send an update on the throttled channel
	 */
	action _sendThrottledUpdate {
		if not havePending then {
			return;
		}
		if needUpdate then {
			update.outputFieldValues:=getUpdate();
			update.timeStamp:=latestUpdate;
			needUpdate:=false;
		}
		if base.sendThrottled then {
			send update to dataChannel;
		}
		if base.sendThrottledUser then {
			send update to lib.getDataUserChannel(dataChannel, owner);
		}
		havePending:=false;
	}

	/**
	 * flush any pending update on the throttled channel.
	 */
	action flushPending() {
		if havePending then {
			_sendThrottledUpdate();
			throttlingListener.quit();
		}
	}	

	/**
 	 * Called when a new update is available.
	 */
	action newUpdateAvailable() {
		needUpdate:=true;
		latestUpdate:=currentTime;
 		if base.sendRaw or base.routeUpdate then {
			if needUpdate then {
				update.outputFieldValues:=getUpdate();
				update.timeStamp:=currentTime;
				needUpdate:=false;
			}
			if base.sendRaw then {
				send update to rawChannel;
			}
			if base.sendRawUser then {
				send update to lib.getRawUserChannel(rawChannel, owner);
			}
			if base.routeUpdate then {
				route update;
			}
		}
		if base.isSendThrottled() and not havePending then {
			havePending:=true;
			_setupThrottleListener();
		}
	}
	
	/**
 	 * Called to send a new Acknowledgement event.
	 */
	action emitAcknowledgement(integer messageId) {
		Acknowledge ack:=Acknowledge(scenarioId, messageId, scenarioInstanceId, true, getUpdate());
		if base.routeUpdate then {
			route ack;
		}
		if base.emitAny then {
			send ack to controlChannel;
		}
	}
				
	/**
 	 * Called to send a new Nak event.
	 */
	action emitNack(integer messageId) {
		Acknowledge nack:=Acknowledge(scenarioId, messageId, scenarioInstanceId, false, new sequence<string>);
		if base.routeUpdate then {
			route nack;
		}
		if base.emitAny then {
			send nack to controlChannel;
		}
	}
	
	/**
 	 * Called to send a new Created event.
	 */
	action emitCreated(integer messageId, string owner, string state, sequence<string> inputVariables, sequence<string> outputVariables) {
		if base.sendAny then {
			Created created:=Created(scenarioId, messageId, scenarioInstanceId, owner, state, inputVariables, outputVariables);
			route created;
			if base.emitAny then {
				base.doEmit(created.toString(), owner);
			}
		}
	}
	
	/**
 	 * Called to send a new Edited event.
	 */
	action emitEdited(integer messageId, sequence<string> inputVariables) {
		flushPending();
		if base.sendAny then {
			Edited edited:=Edited(scenarioId, messageId, scenarioInstanceId, inputVariables, getUpdate());
			if base.routeUpdate then {
				route edited;
			}
			if base.emitAny then {
				base.doEmit(edited.toString(), owner);
			}
		}
		emitOpCompleted(messageId);
	}

	/**
 	 * Called to say an operation has completed; implied by emitEdited. Must be called before emitInstanceDied.
	 */
	action emitOpCompleted(integer messageId) {
		if(context.current().getId()!=mainContext.getId()) then {
			send OperationCompleted(scenarioId, scenarioInstanceId, messageId) to mainContext;
		}
	}

	/**
 	 * Called to send a new Deleted event.
	 */
	action emitDeleted(integer messageId) {
		flushPending();
		if base.sendAny then {
			Deleted deleted:=Deleted(scenarioId, messageId, scenarioInstanceId);
			if base.routeUpdate then {
				route deleted;
			}
			if base.emitAny then {
				base.doEmit(deleted.toString(), owner);
			}
		}
		throttlingListener.quit();
		notifyInstanceDied();
	}

	/**
 	 * Called to send an instance Died event (either of failed, ended)
	 */
	action emitInstanceDied() {
		flushPending();
		if base.sendAny then {
			InstanceDied iDied:=InstanceDied(scenarioId, scenarioInstanceId);
			if base.emitAny then {
				base.doEmit(iDied.toString(), owner);
			}
			if mainContext.getId()=context.current().getId() then {
				route iDied;
			}
		}
		throttlingListener.quit();
	}

	/**
 	 * Called to notify the scenario service monitor that we have gone away - must be called 
 	 * after emitting any events regarding this instance going away. Implied by emitDeleted.
	 */
	action notifyInstanceDied() {
		if mainContext.getId()!=context.current().getId() then {
			InstanceDied iDied:=InstanceDied(scenarioId, scenarioInstanceId);
			
			// give a chance for anyone monitoring this from its own context 
			// to handle the InstanceDied before the main context
			if base.routeUpdate then {
				route InstanceDied(scenarioId, scenarioInstanceId);
			}

			send iDied to mainContext;
		}
	}
	
	/**
 	 * Called to send a new StateChange event.
	 */
	action emitStateChange(string state) {
		flushPending();
		StateChange stchange:=StateChange(scenarioId, scenarioInstanceId, state);
		if mainContext.getId()!=context.current().getId() then {
			send stchange to mainContext;
		} else {
			route stchange;
		}
		if base.emitAny then {
			base.doEmit(stchange.toString(), owner);
		}
	}

	/**
 	 * Called to send an instance in response to a RequestInstancesInternal event
	 */
	action emitInstance(RequestInstancesInternal request, string owner, string state, sequence<string> input, sequence<string> output) {
		Instance instance:=Instance(scenarioId, request.messageId, scenarioInstanceId, owner, state, input, output);
		if request.internal then {
			if mainContext.getId() != context.current().getId() then {
				send instance to mainContext;
			} else {
				route instance;
			}
		} else {
			if(base.emitAny) then {
				send instance to request.channel;
			}
		}
		if mainContext.getId() != context.current().getId() then {
			send RequestInstancesParallelDone(scenarioId, request.messageId, scenarioInstanceId) to mainContext;
		}
	}

	/**
 	 * Called when the instance has failed.  input and output are the input
 	 * and output variables as at the last Update/ Edited point.
	 */
	action finished(string state, string owner, sequence<string> input, sequence<string> output) {
		ScenarioFinished scenFinished:=ScenarioFinished(scenarioId, scenarioInstanceId, owner, state, input, output);
		if mainContext.getId() != context.current().getId() then {
			send scenFinished to mainContext;
		} else {
			route scenFinished;
		}
	}
	
}


/**
 * Utilitiy event for tracking configuration for a given scenario.
 * This event is suitable for use by monitors which spawn per scenario,
 * but not per instance. (e.g. ScenarioService, DataViewService)
 * 
 * actions starting with an underscore should be considered private 
 * and not called by users of this event.
 * 
 * Note that this updater only honours sendThrottledUser changes at the next throttling period
 * (it does not record the owner if sendThrottledUser is not true)
 */
event ScenarioServiceUpdaterMultipleInstances {
	// these are internal and should not be set by users
	string scenarioId;
	ScenarioServiceLibrary lib;
	listener throttlingListener;
	ScenarioServiceUpdaterBase base;
	boolean currentlySendingThrottledUser;
	dictionary<integer, Update> updates;
	dictionary<integer, string> owners;
	context mainContext;
	string controlChannel;
	string rawChannel;
	string dataChannel;

	/**
	 * Called by monitor for each scenario
	 * Will maintain configuration for this scenario Id
	 */
	action init(string sId, context mainCtx) {
		_init(sId, mainCtx, _configurationUpdated);
	}
	
	/**
	 * Called by monitor for each scenario
	 * Will maintain configuration for this scenario Id
	 */
	action init_cb(string sId, context mainCtx, action<> cb_initComplete) {
		CallbackHelper callbackHelper:=new CallbackHelper;
		callbackHelper.callbacks.append(cb_initComplete);
		callbackHelper.callbacks.append(_configurationUpdated);
		_init(sId, mainCtx, callbackHelper.callback);
	}

	/**
	 * Implementation of init and init_cb
	 */
	action _init(string sId, context mainCtx, action<> cb_initComplete) {
		base.init(sId, cb_initComplete);
		mainContext:=mainCtx;
		scenarioId:=sId;
		controlChannel := lib.getControlChannel(scenarioId);
		rawChannel := lib.getRawChannel(scenarioId);
		dataChannel := lib.getDataChannel(scenarioId);
		listener l:=on all SendQueuedUpdatesNow() {
			_sendThrottledUpdates();
		}
		base.listeners.append(l);
		base.listenToConfigureUpdates(_configurationUpdated);
	}
	
	/** 
	 * Get whether this scenario should route updates
	 */
	action isRouteUpdate() returns boolean {
		return base.routeUpdate;
	}

	/**
 	 * Kill any listeners this object has started
	 */
	action destroy() {
		base.destroy();
		throttlingListener.quit();
	}
	  

	/**
	 * called in instances (not factories) when configuration has changed
	 */
	action _configurationUpdated {
		if base.isSendThrottled() then {
			throttlingListener.quit();
			flushPending();
			if(base.throttlePeriod >= 0.0) then {
				_setupThrottleListener();
			}
		}
	}

	/**
	 * set up a throttled listener according to throttlePeriod control
	 */
	action _setupThrottleListener {
		if base.throttlePeriod > 0.0 then {
			throttlingListener:=on all wait(base.throttlePeriod) {
				_sendThrottledUpdates();
			}
		} else {
			_sendThrottledUpdates();
		}
	}

	/**
	 * actually send an update on the throttled channel
	 */
	action _sendThrottledUpdates {
		integer instance;
		if base.sendThrottled then {
			for instance in updates.keys() {
				send updates[instance] to dataChannel;
			}
		}
		if currentlySendingThrottledUser then {
			for instance in updates.keys() {
				send updates[instance] to lib.getDataUserChannel(dataChannel, owners[instance]);
			}
		}
		owners.clear();
		updates.clear();
		currentlySendingThrottledUser := base.sendThrottledUser;
	}

	/**
	 * flush any pending update on the throttled channel.
	 */
	action flushPending() {
		_sendThrottledUpdates();
	}	

	/**
 	 * Flush pending throttled data for one instance
	 */
	action flushPendingInstance(integer scenarioInstanceId) {
		if updates.hasKey(scenarioInstanceId) then {
			if base.sendThrottled then {
				send updates[scenarioInstanceId] to dataChannel;
			}
			if currentlySendingThrottledUser then {
				send updates[scenarioInstanceId] to lib.getDataUserChannel(dataChannel, owners[scenarioInstanceId]);
			}
			updates.remove(scenarioInstanceId);
			if owners.hasKey(scenarioInstanceId) then {
				owners.remove(scenarioInstanceId);
			}
		}
	}	

	/**
 	 * Called when a new update is available. (This variant allows setting of the time parameter)
	 */
	action emitUpdate_time(integer scenarioInstanceId, float time, sequence<string> output, string owner) {
		if base.sendAny then {
			Update update:=Update(scenarioId, scenarioInstanceId, time, output);
			if base.sendRaw then {
				send update to rawChannel;
			}
			if base.sendRawUser then {
				send update to lib.getRawUserChannel(rawChannel, owner);
			}
			if base.routeUpdate then {
				route update;
			}
			if base.isSendThrottled() then {
				if base.throttlePeriod > 0.0 then {
					updates.add(scenarioInstanceId, update);
					if currentlySendingThrottledUser then {
						owners.add(scenarioInstanceId, owner);
					}
				} else {
					send update to dataChannel;
				}
			}
		}
	}
	
	/**
 	 * Called when a new update is available.
	 */
	action emitUpdate(integer scenarioInstanceId, sequence<string> output, string owner) {
		emitUpdate_time(scenarioInstanceId, currentTime, output, owner);
	}

	/**
 	 * Called to send a new Acknowledgement event.
	 */
	action emitAcknowledgement(integer messageId, integer scenarioInstanceId, sequence<string> output) {
		Acknowledge ack:=Acknowledge(scenarioId, messageId, scenarioInstanceId, true, output);
		if base.routeUpdate then {
			route ack;
		}
		if base.emitAny then {
			send ack to controlChannel;
		}
	}
				
	/**
 	 * Called to send a new Nak event.
	 */
	action emitNack(integer messageId, integer scenarioInstanceId) {
		Acknowledge nack:=Acknowledge(scenarioId, messageId, scenarioInstanceId, false, new sequence<string>);
		if base.routeUpdate then {
			route nack;
		}
		if base.emitAny then {
			send nack to controlChannel;
		}
	}
	
	/**
 	 * Called to send a new Created event.
	 */
	action emitCreated(integer messageId, integer scenarioInstanceId, string owner, string state, sequence<string> inputVariables, sequence<string> outputVariables) {
		if base.sendAny then {
			Created created:=Created(scenarioId, messageId, scenarioInstanceId, owner, state, inputVariables, outputVariables);
			route created;
			if base.emitAny then {
				string sCreated:=created.toString();
				base.doEmit(sCreated, owner);
			}
		}
	}

	/**
 	 * Called to send any received events (except for instance) for this scenario.
	 */
	action emitReceivedEvents() {
		dictionary<integer, string> instanceOwners:=new dictionary<integer, string>;
		{
			Update update;
			listener l:=on all Update(scenarioId = scenarioId):update {
				if base.sendRaw then {
					send update to rawChannel;
				}
				if base.sendRawUser and instanceOwners.hasKey(update.scenarioInstanceId) then {	
					send update to lib.getRawUserChannel(rawChannel, instanceOwners[update.scenarioInstanceId]);
				}
				if base.isSendThrottled() then {
					if base.throttlePeriod > 0.0 then {
						updates.add(update.scenarioInstanceId, update);
						string owner:="*";
						if instanceOwners.hasKey(update.scenarioInstanceId) then {
							owner:=instanceOwners[update.scenarioInstanceId];
						}
						if currentlySendingThrottledUser then {
							owners.add(update.scenarioInstanceId, owner);
						}
					} else {
						send update to dataChannel;
					}
				}
			}
			base.listeners.append(l);
		}
		{
			Created created;
			listener l:=on all Created(scenarioId = scenarioId):created {
				if(created.owner != "*") then {
					instanceOwners.add(created.scenarioInstanceId, created.owner);
				}
				base.doEmit(created.toString(), created.owner);				
			}
			base.listeners.append(l);
		}
		{
			Deleted deleted;
			listener l:=on all Deleted(scenarioId = scenarioId):deleted {
				flushPendingInstance(deleted.scenarioInstanceId);
				string owner:="*";
				if instanceOwners.hasKey(deleted.scenarioInstanceId) then {
					owner:=instanceOwners[deleted.scenarioInstanceId];
					instanceOwners.remove(deleted.scenarioInstanceId);
				}
				base.doEmit(deleted.toString(), owner);		
			}
			base.listeners.append(l);
		}
		{
			Edited edited;
			listener l:=on all Edited(scenarioId = scenarioId):edited {
				flushPendingInstance(edited.scenarioInstanceId);
				string owner:="*";
				if instanceOwners.hasKey(edited.scenarioInstanceId) then {
					owner:=instanceOwners[edited.scenarioInstanceId];
				}
				base.doEmit(edited.toString(), owner);		
			}
			base.listeners.append(l);
		}
		{
			InstanceDied instanceDied;
			listener l:=on all InstanceDied(scenarioId = scenarioId):instanceDied {
				flushPendingInstance(instanceDied.scenarioInstanceId);
				string owner:="*";
				if instanceOwners.hasKey(instanceDied.scenarioInstanceId) then {
					owner:=instanceOwners[instanceDied.scenarioInstanceId];
				}
				base.doEmit(instanceDied.toString(), owner);		
			}
			base.listeners.append(l);
		}
	}
	
	/**
 	 * Called to send a new Edited event.
	 */
	action emitEdited(integer messageId, integer scenarioInstanceId, sequence<string> inputVariables, sequence<string> outputVariables, string owner) {
		flushPendingInstance(scenarioInstanceId);
		if base.sendAny then {
			Edited edited:=Edited(scenarioId, messageId, scenarioInstanceId, inputVariables, outputVariables);
			if base.routeUpdate then {
				route edited;
			}
			if base.emitAny then {
				base.doEmit(edited.toString(), owner);
			}
		}
		emitOpCompleted(messageId, scenarioInstanceId);
	}

	/**
 	 * Called to say an operation has completed; implied by emitEdited. Must be called before emitInstanceDied.
	 */
	action emitOpCompleted(integer messageId, integer scenarioInstanceId) {
		if(context.current().getId()!=mainContext.getId()) then {
			send OperationCompleted(scenarioId, scenarioInstanceId, messageId) to mainContext;
		}
	}

	/**
 	 * Called to send a new Deleted event.
	 */
	action emitDeleted(integer messageId, integer scenarioInstanceId, string owner) {
		flushPendingInstance(scenarioInstanceId);
		if base.sendAny then {
			Deleted deleted:=Deleted(scenarioId, messageId, scenarioInstanceId);
			if base.routeUpdate then {
				route deleted;
			}
			if base.emitAny then {
				base.doEmit(deleted.toString(), owner);
			}
		}
		notifyInstanceDied(scenarioInstanceId);
	}

	/**
 	 * Called to notify the scenario service monitor that we have gone away - must be called 
 	 * after emitting any events regarding this instance going away. Implied by emitDeleted.
	 */
	action notifyInstanceDied(integer scenarioInstanceId) {
		if mainContext.getId()!=context.current().getId() then {
			InstanceDied iDied:=InstanceDied(scenarioId, scenarioInstanceId);
			send iDied to mainContext;
		}
	}
	

	
	/**
 	 * Called to send an instance Died event (either of failed, ended)
	 */
	action emitInstanceDied(integer scenarioInstanceId, string owner) {
		flushPendingInstance(scenarioInstanceId);
		if base.sendAny then {
			InstanceDied iDied:=InstanceDied(scenarioId, scenarioInstanceId);
			if base.emitAny then {
				base.doEmit(iDied.toString(), owner);
			}
			if mainContext.getId()=context.current().getId() then {
				route iDied;
			}
		}
	}
	
	/**
 	 * Called to send a new StateChange event.
	 */
	action emitStateChange(string state, integer scenarioInstanceId, string owner) {
		flushPendingInstance(scenarioInstanceId);
		StateChange stchange:=StateChange(scenarioId, scenarioInstanceId, state);
		if mainContext.getId()!=context.current().getId() then {
			send stchange to mainContext;
		} else {
			route stchange;
		}
		if base.emitAny then {
			base.doEmit(stchange.toString(), owner);
		}
	}

	/**
 	 * Called to send an instance in response to a RequestInstancesInternal event
	 */
	action emitInstance(RequestInstancesInternal request, integer scenarioInstanceId, string owner, string state, sequence<string> input, sequence<string> output) {
		Instance instance:=Instance(scenarioId, request.messageId, scenarioInstanceId, owner, state, input, output);
		if request.internal then {
			if mainContext.getId() != context.current().getId() then {
				send instance to mainContext;
			} else {
				route instance;
			}
		} else {
			if(base.emitAny) then {
				send instance to request.channel;
			}
		}
		if mainContext.getId() != context.current().getId() then {
				send RequestInstancesParallelDone(scenarioId, request.messageId, scenarioInstanceId) to mainContext;
		}
	}
	/**
 	 * Called to send an instance that has already been seen in the current context
	 */
	action emitReceivedInstance(RequestInstancesInternal request, Instance instance) {
		if request.internal then {
			if mainContext.getId() != context.current().getId() then {
				send instance to mainContext;
			}
		} else {
			if(base.emitAny) then {
				send instance to request.channel;
			}
		}
	}
	
}


/*
 * Monitor that performs the following tasks:
 *   - routing/emitting ScenarioServiceLoaded when the service is loaded
 *   - routing/emitting ScenarioServiceUnloaded when the service is unloaded
 *   - routing/emitting a nack if a Create request is ignored
 *   - maintains latest configuration
 *   - tracks state of ended/ failed scenarios
 *   - forwards Edit, delete events to scenarios in other contexts
 *
 */
monitor ScenarioService {

	event PendingOperation {
		integer messageId;
		integer type; // 0 = delete, 1 = edit
	}

	listener throttledSenderListener;
	ScenarioServiceLibrary lib;
	RequestScenarios requestScenarios;
	boolean requestingScenarios;
	
	// MetaData relating to the interface
	dictionary<string,string> interfaceMetaData := {
		"interface.package"     :"com.apama.scenario",
		"interface.name"        :"ScenarioService",
		"interface.fileName"    :"ScenarioService.mon",
		"interface.vendor"      :"Apama",
		"interface.version"     :"5.3.0.0.247085",
		"interface.fullVersion" :"rel/5.3.0.x@247085",
		"interface.language"    :"MonitorScript"
	};
	
	// Channel names	
	string scenarioServiceChannel := "com.apama.scenario";
	integer highestInstanceId;


	// the first mThread handles scenario discovery and maps some events to internal events
	action onload {
		// print version
		log "ScenarioService interface loaded. MetaData: "+interfaceMetaData.toString() at INFO;
		
		// generate the ScenarioServiceLoaded event
		route ScenarioServiceLoaded();
		send ScenarioServiceLoaded() to scenarioServiceChannel;

		dictionary <string,string> defaultConfig:=new dictionary<string,string>;
		dictionary <string, dictionary<string,string> > configurations:=new dictionary<string, dictionary<string,string> >;
		lib.configurationManager(defaultConfig, configurations);
		RequestInstancesOnChannel requestInstancesOnChannel;
		on all RequestInstancesOnChannel():requestInstancesOnChannel {
			route RequestInstancesInternal(requestInstancesOnChannel.scenarioId, requestInstancesOnChannel.messageId, requestInstancesOnChannel.channel, false, "", false);
			on RequestInstancesDone(scenarioId=requestInstancesOnChannel.scenarioId, messageId=requestInstancesOnChannel.messageId) {
				send RequestInstancesDone(requestInstancesOnChannel.scenarioId, requestInstancesOnChannel.messageId) to requestInstancesOnChannel.channel;
			}
		}

		RequestInstancesOnChannelByUser requestInstancesOnChannelByUser;
		on all RequestInstancesOnChannelByUser():requestInstancesOnChannelByUser {
			route RequestInstancesInternal(requestInstancesOnChannelByUser.scenarioId, requestInstancesOnChannelByUser.messageId, requestInstancesOnChannelByUser.channel, false, requestInstancesOnChannelByUser.owner, true);
			on RequestInstancesDone(scenarioId=requestInstancesOnChannelByUser.scenarioId, messageId=requestInstancesOnChannelByUser.messageId) {
				send RequestInstancesDone(requestInstancesOnChannelByUser.scenarioId, requestInstancesOnChannelByUser.messageId) to requestInstancesOnChannelByUser.channel;
			}
		}
		Scenario scenario;
		on all Scenario():scenario {
			if requestingScenarios then {
				send scenario to requestScenarios.channel;
			} else {
				spawn trackScenario(scenario);
			}
		}
		
		ScenarioUnloaded scenarioUnloaded;
		on all ScenarioUnloaded(): scenarioUnloaded {
			send scenarioUnloaded to scenarioServiceChannel;
		}

		
		on all RequestScenarios():requestScenarios {
			send RequestScenariosAck() to requestScenarios.channel;
			route StartScenarioRecovery();
			route FinishedScenarioRecovery();
			requestingScenarios:=true;
			on FinishedScenarioRecovery() {
				requestingScenarios:=false;
				send RequestScenariosDone() to requestScenarios.channel;
			}
		}

		dictionary <string,string> EMPTY_DICT:=new dictionary<string,string>;
		// Pick up any requests for operations on invalid scenarioIds
		Create create;
		on all unmatched Create(): create {
			dictionary<string,string> config:=EMPTY_DICT;
			if configurations.hasKey(create.scenarioId) then {
				config:=configurations[create.scenarioId];
			}
			Acknowledge nack := new Acknowledge;
			nack.scenarioId := create.scenarioId;
			nack.messageId := create.messageId;
			nack.success := false;
			log create.scenarioId+": Scenario create ignored - unknown scenarioId." at WARN;
			send nack to lib.getControlChannel(create.scenarioId);
			if lib.getRouteUpdate(defaultConfig, config) then {
				route nack;
			}
		}

		// The old SetThrottlingPeriod is mapped to a ConfigureUpdates event
		SetThrottlingPeriod setThrottlingPeriod;		
		on all SetThrottlingPeriod():setThrottlingPeriod {
			dictionary<string, string> configChanges:=new dictionary<string,string>;
			if setThrottlingPeriod.period >= 0.0 then {
				configChanges["sendThrottled"]:="true";
				configChanges["throttlePeriod"]:=setThrottlingPeriod.period.toString();
			} else {
				configChanges["sendThrottled"]:="false";
			}
			ConfigureUpdates cu:=ConfigureUpdates("", configChanges);
			log "Received deprecated event "+setThrottlingPeriod.toString()+", will re-route as "+cu.toString() at WARN;
			route cu;
		}
	}		
				
	
	action onunload {
		// generate the ScenarioServiceUnloaded event
		ScenarioServiceUnloaded unloaded := new ScenarioServiceUnloaded;
		route unloaded;
		send unloaded to scenarioServiceChannel;
	}
	
	/**
	 * spawned per scenario, and handles any finished scenario instances.
	 * For parallel scenarios, it also tracks which instance runs in 
	 * which context and forwards Edit and Delete events.
	 */
	action trackScenario(Scenario scenario) {
		on ScenarioUnloaded(scenarioId=scenario.scenarioId) {
			die;
		}
		ScenarioServiceUpdaterMultipleInstances updater:=new ScenarioServiceUpdaterMultipleInstances;
		updater.init(scenario.scenarioId, context.current());
		ScenarioFinished finished;
		on all ScenarioFinished(scenarioId=scenario.scenarioId):finished {
			// Finished scenarios can be deleted (which terminates all listeners for this instance), 
			// discovered, and edits are Nacked 
			Delete delete;
			on Delete(scenarioId=scenario.scenarioId, scenarioInstanceId = finished.scenarioInstanceId):delete {
				updater.emitAcknowledgement(delete.messageId, finished.scenarioInstanceId, finished.outputFieldValues);
				updater.emitDeleted(delete.messageId, finished.scenarioInstanceId, finished.owner);
			}
			Edit edit;
			on all Edit(scenarioId=scenario.scenarioId, scenarioInstanceId=finished.scenarioInstanceId):edit and not 
			            Delete(scenarioId=scenario.scenarioId, scenarioInstanceId = finished.scenarioInstanceId) {
				updater.emitNack(edit.messageId, finished.scenarioInstanceId);
				log scenario.displayName+"("+finished.scenarioInstanceId.toString()+ "): Scenario edit ignored - Scenario is in "+finished.state+" state." at WARN;
			}
			RequestInstancesInternal requestInstances;
			if finished.owner = "*" then {
				on all RequestInstancesInternal(scenarioId=scenario.scenarioId):requestInstances and not
						Delete(scenarioId=scenario.scenarioId, scenarioInstanceId = finished.scenarioInstanceId) {
					updater.emitInstance(requestInstances, finished.scenarioInstanceId,
						finished.owner, finished.state, finished.inputFieldValues, finished.outputFieldValues);
				}
			} else {
				on all (RequestInstancesInternal(scenarioId=scenario.scenarioId, ownerFilter=false):requestInstances or
					RequestInstancesInternal(scenarioId=scenario.scenarioId, owner=finished.owner, ownerFilter=true):requestInstances) and not
						Delete(scenarioId=scenario.scenarioId, scenarioInstanceId = finished.scenarioInstanceId) {
					updater.emitInstance(requestInstances, finished.scenarioInstanceId,
						finished.owner, finished.state, finished.inputFieldValues, finished.outputFieldValues);
				}
			}
		}
		if scenario.executionMode > 0 then {
			// for parallel scenarios, we keep track of instance to context mapping:
			dictionary<integer, context> runningCtxs := new dictionary<integer, context>;
			// and to owner mapping:
			dictionary<integer, string> ownerCtxs := new dictionary<integer, string>;
			// and by user:
			dictionary<string, dictionary<integer, context> > runningCtxsByOwner := new dictionary<string, dictionary<integer, context> >;
			// maps from instanceId to sequence<messageId>
			dictionary<integer, sequence<PendingOperation> > pendingOperations := new dictionary<integer, sequence<PendingOperation> >;
			ParallelStarting starting;
			on all ParallelStarting(scenarioId = scenario.scenarioId):starting {
				runningCtxs.add(starting.scenarioInstanceId, starting.runningCtx);
				ownerCtxs.add(starting.scenarioInstanceId, starting.owner);
				if not runningCtxsByOwner.hasKey(starting.owner) then {
					runningCtxsByOwner.add(starting.owner, new dictionary<integer, context>);
				}
				runningCtxsByOwner[starting.owner].add(starting.scenarioInstanceId, starting.runningCtx);
				highestInstanceId := starting.scenarioInstanceId;
			}
			
			InstanceDied died;
			on all InstanceDied(scenarioId = scenario.scenarioId):died {
				if runningCtxs.hasKey(died.scenarioInstanceId) then {
					runningCtxs.remove(died.scenarioInstanceId);
				}
				if ownerCtxs.hasKey(died.scenarioInstanceId) then {
					string owner:=ownerCtxs[died.scenarioInstanceId];
					ownerCtxs.remove(died.scenarioInstanceId);
					if runningCtxsByOwner.hasKey(owner) then {
						if runningCtxsByOwner[owner].hasKey(died.scenarioInstanceId) then {
							runningCtxsByOwner[owner].remove(died.scenarioInstanceId);
						}
						if runningCtxsByOwner[owner].size()=0 then {
							runningCtxsByOwner.remove(owner);
						}
					}
				}
				if pendingOperations.hasKey(died.scenarioInstanceId) then {
					PendingOperation pending;
					for pending in pendingOperations[died.scenarioInstanceId] {
						if pending.type = 0 then {
							route Delete(scenario.scenarioId, pending.messageId, died.scenarioInstanceId);
						} else {
							if pending.type = 1 then {
								route Edit(scenario.scenarioId, pending.messageId, died.scenarioInstanceId, new sequence<string>);
							} else {
								log "error: unknown pending operation type "+pending.toString() at ERROR;
							}
						}
					}
					pendingOperations.remove(died.scenarioInstanceId);
				}
			}
			
			// and forward edits, deletes:
			Edit edit;
			on all unmatched Edit(scenarioId = scenario.scenarioId):edit {
				if runningCtxs.hasKey(edit.scenarioInstanceId) then {
					send edit to runningCtxs[edit.scenarioInstanceId];
					addPendingOperation(pendingOperations, edit.scenarioInstanceId, edit.messageId, 1);
					on OperationCompleted(scenarioId = scenario.scenarioId, scenarioInstanceId = edit.scenarioInstanceId, messageId = edit.messageId) and not
					   ScenarioFinished(scenarioId = scenario.scenarioId, scenarioInstanceId = edit.scenarioInstanceId){
						removePendingOperation(pendingOperations, edit.scenarioInstanceId, edit.messageId);
					}
				} else {
					log scenario.displayName+"("+edit.scenarioInstanceId.toString()+"): Scenario edit ignored - unknown scenarioInstanceId." at WARN;
					updater.emitNack(edit.messageId, edit.scenarioInstanceId);
				}
			}
			Delete delete;
			on all unmatched Delete(scenarioId = scenario.scenarioId):delete {
				if runningCtxs.hasKey(delete.scenarioInstanceId) then {
					send delete to runningCtxs[delete.scenarioInstanceId];
					addPendingOperation(pendingOperations, delete.scenarioInstanceId, delete.messageId, 0);
					on OperationCompleted(scenarioId = scenario.scenarioId, scenarioInstanceId = delete.scenarioInstanceId, messageId = delete.messageId) and not
					   ScenarioFinished(scenarioId = scenario.scenarioId, scenarioInstanceId = delete.scenarioInstanceId){
						removePendingOperation(pendingOperations, delete.scenarioInstanceId, delete.messageId);
					}
				} else {
					log scenario.displayName+"("+delete.scenarioInstanceId.toString()+"): Scenario delete ignored - unknown scenarioInstanceId." at WARN;
					updater.emitNack(delete.messageId, delete.scenarioInstanceId);
				}
			}
			
			// and request instances is handled by a separate monitor. Note that 
			// Finished scenarios are not in the dictionary, but are handled by the finished
			// listener above.
			RequestInstancesInternal reqInstances;
			on all RequestInstancesInternal(scenarioId=scenario.scenarioId):reqInstances {
				if reqInstances.ownerFilter then {
					if runningCtxsByOwner.hasKey(reqInstances.owner) then {
						dictionary<integer, context> rCtxs:=runningCtxsByOwner[reqInstances.owner];
						if runningCtxsByOwner.hasKey("*") then {
							rCtxs:=rCtxs.clone();
							integer i;
							dictionary<integer, context> wildcards:=runningCtxsByOwner["*"];
							for i in wildcards.keys() {
								rCtxs.add(i, wildcards[i]);
							}
						}
						route RequestInstancesParallel(reqInstances, rCtxs, highestInstanceId);
					} else {
						if runningCtxsByOwner.hasKey("*") then {
							route RequestInstancesParallel(reqInstances, runningCtxsByOwner["*"], highestInstanceId);
						} else {
							route RequestInstancesParallel(reqInstances, new dictionary<integer,context>, highestInstanceId);
						}
					}
				} else {
					route RequestInstancesParallel(reqInstances, runningCtxs, highestInstanceId);
				}
			}
			ConfigureUpdates cu;
			on all ConfigureUpdates(scenarioId=""):cu or all ConfigureUpdates(scenarioId=scenario.scenarioId):cu {
				integer inst;
				for inst in runningCtxs.keys() {
					send cu to runningCtxs[inst];
				}
			}
			on all SendQueuedUpdatesNow() {
				SendQueuedUpdatesNow snow:=SendQueuedUpdatesNow();
				integer inst;
				for inst in runningCtxs.keys() {
					send snow to runningCtxs[inst];
				}
			}
		}
	}
	
	action addPendingOperation(dictionary<integer,  sequence<PendingOperation> > pendingOperations, integer scenarioInstanceId, integer messageId, integer type) {
		if not pendingOperations.hasKey(scenarioInstanceId) then {
			pendingOperations.add(scenarioInstanceId, new sequence<PendingOperation>);
		}
		pendingOperations[scenarioInstanceId].append(PendingOperation(messageId, type));
	}
	
	action removePendingOperation(dictionary<integer, sequence<PendingOperation> > pendingOperations, integer scenarioInstanceId, integer messageId) {
		if not pendingOperations.hasKey(scenarioInstanceId) then {
			return;
		}
		integer idx:=-1, i:=0;
		while(i < pendingOperations[scenarioInstanceId].size()) {
			if pendingOperations[scenarioInstanceId][i].messageId = messageId then {
				idx:=i;
				break;
			}
			i:=i+1;
		}
		if(idx>=0) then {
			pendingOperations[scenarioInstanceId].remove(idx);
		}
		if pendingOperations[scenarioInstanceId].size() = 0 then {
			pendingOperations.remove(scenarioInstanceId);
		}
	}	
}

/*
 * Monitor that handles request instances for parallel scenarios:
 * - on a RequestInstancesOnChannel for a parallel scenario, the ScenarioService 
 *   routes a RequestInstancesParallel which triggers this monitor to spawn.
 * - this waits for a response (be it to say the request instances has been 
 *   handled or that the scenario has finished) before sending the 
 *   RequestInstancesDone event 
 *
 * Note that this monitor assumes scenarioInstancesIds always increase over time.
 */
monitor RequestInstancesHandler {
	RequestInstancesParallel req;
	action onload {
		on all RequestInstancesParallel():req {
			spawn handleRequest();
		}
	}
	
	/**
	 * Forward the request to every context and await responses. We remove 
	 * instances from the dictionary upon receiving an update for them. 
	 */
	action handleRequest() {
		ScenarioServiceUpdaterMultipleInstances updater:=new ScenarioServiceUpdaterMultipleInstances;
		updater.init(req.request.scenarioId, context.current());
		integer k;
		for k in req.instances.keys() {
			send req.request to req.instances[k];
		}
		// if a scenario dies, it will send events in the order ScenarioFinished, InstanceDied:
		ScenarioFinished finished;
		on all ScenarioFinished(scenarioId=req.request.scenarioId, scenarioInstanceId <= req.highestInstanceId):finished {
			// if a scenario dies after it has sent the Instance, do not send another 
			// (the StateChange/ InstanceDied events are sufficient)
			if(req.instances.hasKey(finished.scenarioInstanceId)) then {
				updater.emitInstance(req.request, finished.scenarioInstanceId,
					finished.owner, finished.state, finished.inputFieldValues, finished.outputFieldValues);
			}
		}
		// A finished scenario should not be counted
		InstanceDied died;
		on all InstanceDied(scenarioId = req.request.scenarioId, scenarioInstanceId <= req.highestInstanceId):died {
			if(req.instances.hasKey(died.scenarioInstanceId)) then {
				req.instances.remove(died.scenarioInstanceId);
				checkFinished();
			}
		}
		RequestInstancesParallelDone pdone;
		on all RequestInstancesParallelDone(scenarioId = req.request.scenarioId, messageId = req.request.messageId):pdone {
			if(req.instances.hasKey(pdone.scenarioInstanceId)) then {
				req.instances.remove(pdone.scenarioInstanceId);
				checkFinished();
			}
		}
		checkFinished();
	}
	
	/**
	 * Check whether we are finished.
	 * We are finished if we have no instances left in our dictionary, in which 
	 * case we route a RequestInstancesDone (handled by the ScenarioService monitor)
	 * and terminate.
	 */
	action checkFinished() {
		if req.instances.size()=0 then {
			route RequestInstancesDone(req.request.scenarioId, req.request.messageId);
			die;
		}
	}
}

 00000034 C:\SoftwareAG\Apama 5.3\monitors\ScenarioService.mon
TIME 0000000e 1444739459.8,1
MONF 0000ed5b package com.apama.dataview;

/*
 * $Copyright(c) 2007-2011 Progress Software Corporation (PSC). All rights reserved.$
 * $Copyright (c) 2013-2014 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its Subsidiaries and or/its Affiliates and/or their licensors.$
 * Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG
 */


/* This is an implementation of the Apama DataViewService API.
 *
 * You must first inject the "interface" - DataViewService_Interface.mon
 * Several implementations of the interface may exist. 
 * You may also need to inject optional "emitter" (see below).
 * Each implementation is in a separate file - inject the one you wish to use.
 *   e.g. this implementation is DataViewService_Impl_Dict.mon
 * 
 *
 * This service enables MonitorScript or JMon applications to expose a simple 
 * read-only "DataView" interface. DataViews may be viewed using Apama Dashboard 
 * Studio in a similar way to Scenarios.
*
 * Route vs. Send
 * The standard implementations of the DataViewService will always ROUTE 
 * any com.apama.dataview.* events, with the expectation that applications
 * using the service are co-located in the same correlator as the service.
 * If your architecture requires the client application to be in a separate 
 * correlator to the DataView service, then two "emitter" monitors are 
 * available.
 * DataViewService_ServiceEmitter.mon  would be injected into the same 
 * correlator as the DataView service after injecting the DataViewService 
 * interface but before injecting the implementation.
 * DataViewService_ApplicationEmitter.mon  would be injected into the same 
 * correlator as the client application after injecting the DataViewService 
 * interface but before injecting the client application.
 *
 * Notes:
 * 
 * 1) Every event has an initial field called msgId. Clients may choose to put 
 *    some identifier in this field when sending messages to the service. Any 
 *    event routed by the service in response will contain the same identifier.
 *
 * 2) Most events contain a field called "dvName". This string 
 *    uniquely identifies a DataView inside the correlator. 
 *
 * 3) Every event has a final field called extraParams that is a string:string
 *    dictionary. Some implementations may choose to use this field. It provides
 *    a way of future-proofing the interface to a certain extent.
 *
 * $Revision: 242755 $
 */

using com.apama.scenario.Create;
using com.apama.scenario.Delete;
using com.apama.scenario.Edit;
using com.apama.scenario.RequestInstancesDone;
using com.apama.scenario.RequestInstancesInternal;
using com.apama.scenario.Scenario;
using com.apama.scenario.ScenarioServiceUpdaterMultipleInstances;
using com.apama.scenario.ScenarioUnloaded;
using com.apama.scenario.StartScenarioRecovery;

// INTERNAL API CODE

monitor DataViewService_Impl_Dict {

	/** Internal event used to store instances/items in a DataView. */
	event _Item {
		wildcard integer scenarioInstanceId;
		wildcard string owner;
		sequence<string> outputFields;
	}
	

	// MetaData relating to this specific implementation
	dictionary<string,string> implementationMetaData := {
		"implementation.package"       :"com.apama.dataview",
		"implementation.name"          :"DataViewService_Impl_Dict",
		"implementation.fileName"      :"DataViewService_Impl_Dict.mon",
		"implementation.vendor"        :"Apama",
		"implementation.version"       :"5.3.0.0.247085",
		"implementation.fullVersion"   :"rel/5.3.0.x@247085",
		"implementation.language"      :"MonitorScript"
	};

	
	// Variables needed in the parent monitor
	dictionary <string, string> dataViewNamesDictionary;  // scenarioId : dvName
	DataViewAddDefinition dvAddDefinition;

	// Variables required in the per-DataView spawned sub-monitor 
	string dvName;  // this is without the PREFIX (which is defined in the onload)
	string scenarioId; // this is with the PREFIX (which is defined in the onload)
	integer NUM_FIELDS;
	sequence<integer> compoundKeyIndexes; // the indexes of the fields which form the compound unique key of a _Item
	sequence<string> compoundKeyNames;    // the names of the fields which form the compound unique key of a _Item
	dictionary <string, integer> compoundKeyInstanceDictionary; // scenarioInstanceCompoundKey : scenarioInstanceId
	dictionary <integer, _Item> instancesDictionary; // scenarioInstanceId : _Item
	integer scenarioInstanceId := 0;
	
	// Defect 9762.  Space, semi-colon and tab in dvName must be escaped 
	dictionary<string, string> escapeCharMap := {" ":"_",		// space
	                                             ";":"$003b",	// semi-colon
	                                             "	":"$0009",	// tab
	                                             "\t":"$0009"	// tab
	                                            };
	dictionary <string, string> escapedDvNamesDictionary; // unescaped dvname : escaped dvname
	dictionary <string, string> escapedScenarioIdDictionary; // unescaped scenarioId : escaped scenarioId

	ScenarioServiceUpdaterMultipleInstances updater;
	
	
	//===================================================================================
	
	/** A default no-arg constructor for an internal _Item. */
	action createDefaultItem() returns _Item {
		return _Item( -1, "", new sequence<string> );
	}

	/** action to take a string and escape all characters appeared in the escapeCharMap dictionary
	 *
	 * @param s - the string to be escaped
	 * 
	 * @return escaped string.  The original string is returned if there is nothing to be escaped
	**/
	action escapeDvName(string s) returns string {
		integer i;
		string retString := s;
		string unEscapeChar;
		for unEscapeChar in escapeCharMap.keys() {
			retString := _escapeIt(retString, unEscapeChar, escapeCharMap[unEscapeChar]);
		}
		
		return retString;
	}
	
	/** internal recursive method to escape the passed in string s.  s will be scanned for the the 
	    unEscapeChar and if found, replaced that with the escapeChar param.  This process will continue
	    until all characters in s is scanned.
	**/
	action _escapeIt( string s, string unEscapeChar, string escapeChar ) returns string {
		
		if (s.find(unEscapeChar) = -1) then {
			return s;
		}
		
		integer index := s.find(unEscapeChar);

		string rest := s.substring(index+1, s.length());
		string retString := s.substring(0, index) + escapeChar + _escapeIt(rest, unEscapeChar, escapeChar);
		
		return retString;
	}
	
	action getEscapedDvName( string rawDvName ) returns string {
		string s;

		// given the raw dvName, return the cached value
		if (escapedDvNamesDictionary.hasKey(rawDvName)) then {
			return escapedDvNamesDictionary[rawDvName];
		}
		
		// not found, just return original string
		return rawDvName;
	}
	
	action getUnescapedDvName( string escapedDvName ) returns string {
		
		string s;
		for s in escapedDvNamesDictionary.keys() {
			if (escapedDvNamesDictionary[s] = escapedDvName) then {
				return s;
			}
		}
		
		// not found, just return original string
		return escapedDvName;
	}
	
	action getEscapedScenarioId( string rawScenarioId ) returns string {
		string s;

		// given the raw scenarioId, return the cached value
		if (escapedScenarioIdDictionary.hasKey(rawScenarioId)) then {
			return escapedScenarioIdDictionary[rawScenarioId];
		}
		
		// not found, just return original string
		return rawScenarioId;
	}
	
	action getUnescapedScenarioId( string escapedScenarioId ) returns string {
		
		string s;
		for s in escapedScenarioIdDictionary.keys() {
			if (escapedScenarioIdDictionary[s] = escapedScenarioId) then {
				return s;
			}
		}
		
		// not found, just return original string
		return escapedScenarioId;
	}
	
	action convertToScenarioId( string in_dvName ) returns string {
		string PREFIX := "DV_";
		string out_scenarioId;
		
		// for now just prepend the prefix, but in future do more checks and escaping of the name
		out_scenarioId:=PREFIX+in_dvName;
		
		return out_scenarioId;
	}
	
	
	action onload {
		log "DataViewService implementation loaded. MetaData: "+implementationMetaData.toString() at INFO;
		
		log "onload() - entered." at DEBUG;

		// Look for the event to define a new DataView
		on all DataViewAddDefinition():dvAddDefinition {
			string escapedDvName := escapeDvName(dvAddDefinition.dvName);
			
			// name must not be ""
			if (dvAddDefinition.dvName.length()=0) then {
				string msg := "Invalid name for new DataView - length must be greater than zero.";
				log "onload().on_all_DataViewAddDefinition() - "+msg at WARN;
				route DataViewException(dvAddDefinition.msgId, escapedDvName, msg, new dictionary<string,string> );
				return;
			}
			
			//name can not start with MEMST (clashes with memorystore plugin)
			string MEMORY_STORE_PREFIX := "MEMST_";
			if (dvAddDefinition.dvName.find(MEMORY_STORE_PREFIX)=0) then {
				string msg := "Invalid name for new DataView - Must not start with " + MEMORY_STORE_PREFIX;
				log "onload().on_all_DataViewAddDefinition() - "+msg at WARN;
				route DataViewException(dvAddDefinition.msgId, dvAddDefinition.dvName, msg, new dictionary<string,string> );
				return;
			}
			
			
			// displayName must not be ""
			if (dvAddDefinition.dvDisplayName.length()=0) then {
				string msg := "Invalid displayName for new DataView - length must be greater than zero.";
				log "onload().on_all_DataViewAddDefinition() - "+msg at WARN;
				route DataViewException(dvAddDefinition.msgId, escapedDvName, msg, new dictionary<string,string> );
				return;
			}
			
			// use the escaped dvName here.  Will save to the escapedDvNamesDictionary
			// when validation is passed

			// both dvName and scenarioId are escaped
			dvName:=escapedDvName;
			scenarioId:=convertToScenarioId(dvName);
			string rawScenarioId:=convertToScenarioId(dvAddDefinition.dvName);
			
			// Validate the params we were given...
			
			// Make sure this is not already present as a DataView or Scenario
			if dataViewNamesDictionary.hasKey(scenarioId) then {
				string msg := "DataView name already exists";
				log "onload().on_all_DataViewAddDefinition() - \""+escapedDvName+"\" - "+msg at WARN;
				route DataViewException(dvAddDefinition.msgId, escapedDvName, msg, new dictionary<string,string>);
				return;
			}
			
				
			// Make sure we were given more than zero field names and types
			if (0=dvAddDefinition.fieldNames.size() or 0=dvAddDefinition.fieldTypes.size()) then {
				string msg := "There must be 1 or more fields. DataViewAddDefinition event supplied "+dvAddDefinition.fieldNames.size().toString() +" names, and "+dvAddDefinition.fieldTypes.size().toString()+" types.";
				log "onload().on_all_DataViewAddDefinition() - \""+escapedDvName+"\" - "+msg at WARN;
				route DataViewException(dvAddDefinition.msgId, escapedDvName, msg, new dictionary<string,string>);
				return;
			}
			
			// Make sure we were not given any duplicate field names or emptystring field names
			dictionary<string,boolean> validNames := new dictionary<string,boolean>;
			string fName;
			for fName in dvAddDefinition.fieldNames {
				// check for name=""
				if (0=fName.length()) then {
					string msg := "One of the supplied field names in a DataViewAddDefinition event is invalid. Field names must have a length greater than zero. The field names supplied were: "+dvAddDefinition.fieldNames.toString();
					log "onload().on_all_DataViewAddDefinition() - \""+escapedDvName+"\" - "+msg at WARN;
					route DataViewException(dvAddDefinition.msgId, escapedDvName, msg, new dictionary<string,string>);
					return;					
				}
				// check for duplicates
				if (validNames.hasKey(fName)) then {
					string msg := "One of the supplied field names in a DataViewAddDefinition event is a duplicate. Duplicate field name: \""+fName+"\". The field names supplied were: "+dvAddDefinition.fieldNames.toString();
					log "onload().on_all_DataViewAddDefinition() - \""+escapedDvName+"\" - "+msg at WARN;
					route DataViewException(dvAddDefinition.msgId, escapedDvName, msg, new dictionary<string,string>);
					return;
				}
				validNames[fName] := true;
			}
			
			// Make sure we were given enough types for the field names
			if (dvAddDefinition.fieldNames.size() != dvAddDefinition.fieldTypes.size()) then {
				string msg := "Each field name must have a corresponding type. DataViewAddDefinition event supplied "+dvAddDefinition.fieldNames.size().toString() +" names, and "+dvAddDefinition.fieldTypes.size().toString()+" types.";
				log "onload().on_all_DataViewAddDefinition() - \""+escapedDvName+"\" - "+msg at WARN;
				route DataViewException(dvAddDefinition.msgId, escapedDvName, msg, new dictionary<string,string>);
				return;
			}
			
			// Make sure the type strings we were given represent valid scenario variable types
			dictionary<string,boolean> validTypes := {"string":true, "float":true, "integer":true, "boolean":true, "enumeration":true};			
			integer i := 0;
			string t;
			for t in dvAddDefinition.fieldTypes {
				if not validTypes.hasKey(t) then {
					string msg := "One of the supplied field types in a DataViewAddDefinition event is invalid. The type supplied at index "+i.toString()+" was: \""+t+"\"";
					log "onload().on_all_DataViewAddDefinition() - \""+escapedDvName+"\" - "+msg at WARN;
					route DataViewException(dvAddDefinition.msgId, escapedDvName, msg, new dictionary<string,string>);
					return;
				}
				i:=i+1;
			}

			compoundKeyIndexes := new sequence<integer>; // ensure it is ALWAYS reset
			compoundKeyNames := new sequence<string>; // ensure it is ALWAYS reset
			// if we've been given some optional key fields, then validate these
			if (dvAddDefinition.keyFields.size() > 0) then {
				string k;
				for k in dvAddDefinition.keyFields {
					integer idx := dvAddDefinition.fieldNames.indexOf(k);
					if (-1 = idx) then {
						string msg := "One of the supplied keyField field names in a DataViewAddDefinition event is invalid. The invalid keyField name supplied was: \""+k+"\". The keyField names supplied were: "+dvAddDefinition.keyFields.toString();
						log "onload().on_all_DataViewAddDefinition() - \""+escapedDvName+"\" - "+msg at WARN;
						route DataViewException(dvAddDefinition.msgId, escapedDvName, msg, new dictionary<string,string>);
						return;						
					}
					if (-1 < compoundKeyIndexes.indexOf(idx)) then {
						string msg := "A duplicate keyField field name was given in a DataViewAddDefinition event. Duplicate keyField name: \""+k+"\". The keyField names supplied were: "+dvAddDefinition.keyFields.toString();
						log "onload().on_all_DataViewAddDefinition() - \""+escapedDvName+"\" - "+msg at WARN;
						route DataViewException(dvAddDefinition.msgId, escapedDvName, msg, new dictionary<string,string>);
						return;												
					}
					compoundKeyIndexes.append(idx); // since it is valid, add the index to the set.
				}
				compoundKeyNames := dvAddDefinition.keyFields;
			}

			// all fields are validated, save the escapedDvName and associate the scenarioId with the escapedName (dvName is escaped already)
			escapedDvNamesDictionary.add(dvAddDefinition.dvName, dvName);
			escapedScenarioIdDictionary.add(rawScenarioId, scenarioId);
			
			dataViewNamesDictionary.add(scenarioId, dvName);
			log "onload().on_all_DataViewAddDefinition() - \""+dvAddDefinition.dvName+"\" - adding new DataView definition with name: \""+dvAddDefinition.dvName+"\", and exposed externally with scenarioId: \""+scenarioId+"\"" at INFO;
			log "onload().on_all_DataViewAddDefinition() - \""+dvAddDefinition.dvName+"\" - spawning initializeScenario()..." at DEBUG;
			spawn initializeScenario;

		}

		// look for requests to unload definitions and tidy up our records.
		// The actual (spawned) DataView *also* looks for this event and kills itself
		DataViewDeleteDefinition dvDeleteDefinition;
		on all DataViewDeleteDefinition():dvDeleteDefinition {
			string rawScenarioId := convertToScenarioId(dvDeleteDefinition.dvName);
			string escapedScenarioId := getEscapedScenarioId(rawScenarioId);
			if dataViewNamesDictionary.hasKey(escapedScenarioId) then {
				log "onload().on_all_DataViewDeleteDefinition() - \""+dvDeleteDefinition.dvName+"\" - removing DataView from dictionary with DataView name: \""+dvDeleteDefinition.dvName+"\", and exposed externally with scenarioId: \""+rawScenarioId+"\"" at INFO;
				dataViewNamesDictionary.remove(escapedScenarioId);
				escapedDvNamesDictionary.remove(dvDeleteDefinition.dvName);  // key is unescapedDvName
				escapedScenarioIdDictionary.remove(rawScenarioId);  // key is unescapedScenarioId
			}
		}

		
		// Look for external (i.e. com.apama.scenario API events) to remove
		// existing scenarios from our list to ensure we're up to date.
		ScenarioUnloaded scenScenarioUnloaded;
		on all ScenarioUnloaded():scenScenarioUnloaded {
			// the following if statement should never now eval to true, as the entry in the dictionary 
			// should always have been previously deleted by the DataViewDeleteDefinition (see above). Done for completeness.
			if dataViewNamesDictionary.hasKey(scenScenarioUnloaded.scenarioId) then {
				string dvName := dataViewNamesDictionary[scenScenarioUnloaded.scenarioId];
				log "onload().on_all_ScenarioUnloaded() - \""+scenScenarioUnloaded.scenarioId+"\" - removing DataView from dictionary with DataView name: \""+dvName+"\", and exposed externally with scenarioId: \""+scenScenarioUnloaded.scenarioId+"\"" at INFO;
				dataViewNamesDictionary.remove(scenScenarioUnloaded.scenarioId);
				escapedDvNamesDictionary.remove(getUnescapedDvName(dvName));  // key is unescapedDvName
				escapedScenarioIdDictionary.remove(getUnescapedScenarioId(scenScenarioUnloaded.scenarioId));  // key is unescapedScenarioId
			}			
		}

		
		// Look for DataViewItem* events for DataView names that do not exist and route exception events
		DataViewAddItem unmatchedAddItem;
		on all unmatched DataViewAddItem():unmatchedAddItem {
			string msg := "Unknown DataView name in a DataViewAddItem event";
			log "unmatched DataViewAddItem() - "+msg at WARN;
			route DataViewException(unmatchedAddItem.msgId, escapeDvName(unmatchedAddItem.dvName), msg, new dictionary<string,string>);
		}
		DataViewAddOrUpdateItem unmatchedAddOrUpdateItem;
		on all unmatched DataViewAddOrUpdateItem():unmatchedAddOrUpdateItem {
			string msg := "Unknown DataView name in a DataViewAddOrUpdateItem event";
			log "unmatched DataViewAddOrUpdateItem() - "+msg at WARN;
			route DataViewException(unmatchedAddOrUpdateItem.msgId, escapeDvName(unmatchedAddOrUpdateItem.dvName), msg, new dictionary<string,string>);
		}
		DataViewUpdateItem unmatchedUpdateItem;
		on all unmatched DataViewUpdateItem():unmatchedUpdateItem {
			string msg := "Unknown DataView name in a DataViewUpdateItem event";
			log "unmatched DataViewUpdateItem() - "+msg at WARN;
			route DataViewItemException(unmatchedUpdateItem.msgId, escapeDvName(unmatchedUpdateItem.dvName), unmatchedUpdateItem.dvItemId, msg, new dictionary<string,string>);
		}
		DataViewUpdateItemDelta unmatchedUpdateItemDelta;
		on all unmatched DataViewUpdateItemDelta():unmatchedUpdateItemDelta {
			string msg := "Unknown DataView name in a DataViewUpdateItemDelta event";
			log "unmatched DataViewUpdateItemDelta() - "+msg at WARN;
			route DataViewItemException(unmatchedUpdateItemDelta.msgId, escapeDvName(unmatchedUpdateItemDelta.dvName), unmatchedUpdateItemDelta.dvItemId, msg, new dictionary<string,string>);
		}
		DataViewDeleteItem unmatchedDeleteItem;
		on all unmatched DataViewDeleteItem():unmatchedDeleteItem {
			string msg := "Unknown DataView name in a DataViewDeleteItem event";
			log "unmatched DataViewDeleteItem() - "+msg at WARN;
			route DataViewItemException(unmatchedDeleteItem.msgId, escapeDvName(unmatchedDeleteItem.dvName), unmatchedDeleteItem.dvItemId, msg, new dictionary<string,string>);
		}
		DataViewDeleteAllItems unmatchedDeleteAllItems;
		on all unmatched DataViewDeleteAllItems():unmatchedDeleteAllItems {
			string msg := "Unknown DataView name in a DataViewDeleteAllItems event";
			log "unmatched DataViewDeleteAllItems() - "+msg at WARN;
			route DataViewException(unmatchedDeleteAllItems.msgId, escapeDvName(unmatchedDeleteAllItems.dvName), msg, new dictionary<string,string>);
		}
		DataViewGetFieldLookup unmatchedLookup;
		on all unmatched DataViewGetFieldLookup():unmatchedLookup {
			string msg := "Unknown DataView name in a DataViewGetFieldLookup event";
			log "unmatched DataViewGetFieldLookup() - "+msg at WARN;
			route DataViewException(unmatchedLookup.msgId, escapeDvName(unmatchedLookup.dvName), msg, new dictionary<string,string>);
		}
		
		log "onload() - complete." at DEBUG;
	}


	//===================================================================================

	
	// This defines the behaviour for each DataView bridge scenario type
	action initializeScenario {
		log "initializeScenario() - \""+dvName+"\" - entered (spawned with this action)." at DEBUG;
		updater.init(scenarioId, context.current());

		string SCENARIO_SERVICE_CHANNEL := "com.apama.scenario";
		Scenario scenario := new Scenario; // store the schema of the DataView

		// Build up the scenario definition event
		scenario.scenarioId := scenarioId;
		scenario.displayName := dvAddDefinition.dvDisplayName;
		scenario.description := dvAddDefinition.dvDescription;
		scenario.inputNames := [];
		scenario.inputTypes := [];
		scenario.inputConstraints := [];
		scenario.inputDefaults := [];
		scenario.outputNames := dvAddDefinition.fieldNames;
		scenario.outputTypes := dvAddDefinition.fieldTypes;
		scenario.executionMode := 0;
		scenario.extraParams := dvAddDefinition.extraParams;
		scenario.extraParams.add("isReadOnly", "true");
		NUM_FIELDS := scenario.outputTypes.size();
	
		// If we have dont have enough constraints then set default constraints for ALL inputs (ignore any we were given)
		// - no - don't need to do that - always ZERO INPUTS
		
		// If we have dont have enough default initial inputs set basic defaults for ALL inputs (ignore any we were given)
		// - no - don't need to do that - always ZERO INPUTS

		
		// Notify any client listeners when scenario loads
		route scenario;
		send scenario to SCENARIO_SERVICE_CHANNEL;
		route DataViewDefinition(dvAddDefinition.msgId, dvName, dvAddDefinition.dvDisplayName, dvAddDefinition.dvDescription, dvAddDefinition.fieldNames, dvAddDefinition.fieldTypes, dvAddDefinition.keyFields, new dictionary<string,string>);

		// Build the helper dictionaries
		initialiseFieldLookup(scenario, dvName);
		
		// Look for the request to delete this bridge type
		DataViewDeleteDefinition delDef;
		on DataViewDeleteDefinition(dvName = getUnescapedDvName(dvName)):delDef {
			//Remove this bridge type
			// the "on unload" listener will generate the response.
			log "initializeScenario().on_DataViewDeleteDefinition() - \""+dvName+"\" - routing DataViewDefinitionDeleted/ScenarioUnloaded events..." at INFO;
			route DataViewDefinitionDeleted(delDef.msgId, dvName, new dictionary<string,string>);
			route ScenarioUnloaded(scenarioId);
			log "initializeScenario().on_DataViewDeleteDefinition() - \""+dvName+"\" - Killing the mthread for this DataView." at INFO;
			die;
		}

		// RequestInstances handling (dumps current state of all instances by sending Instance events)
		RequestInstancesInternal scenRequestInstances;
		on all RequestInstancesInternal(scenarioId = scenarioId): scenRequestInstances {
			log "initializeScenario().on_all_RequestInstances() - \""+scenarioId+"\" - received request for instances. Initiating recovery on for request messageId: "+scenRequestInstances.messageId.toString() at DEBUG;
			
			integer k;
			_Item item;
			for k in instancesDictionary.keys() {
				item := instancesDictionary[k];

				log "dvItemMThread().on_all_RequestInstances() - \""+scenarioId+":"+k.toString()+"\" - routing an Instance event for this DataView Item..." at DEBUG;

				if(scenRequestInstances.ownerFilter = false or 
				   scenRequestInstances.owner = item.owner or 
				   item.owner = "*") then {
					updater.emitInstance(scenRequestInstances, item.scenarioInstanceId, item.owner, "RUNNING", new sequence<string>, item.outputFields);
				}
			}
			route RequestInstancesDone(scenarioId, scenRequestInstances.messageId);
		}
		
		// Look for the scenario recovery event and send out the definition of this Scenario/DataView. (remember we have spawned per Scenario)
		on all StartScenarioRecovery() {
			route scenario;
		}

		
		
		
		// ========= Listeners for Create/Delete/Edit/Update ==================
		
		
		// ####################################################################
		// ####################################################################	
		// CREATE
		// First if an instance is created via the scenario API (e.g. a dashboard)...
		Create scenCreate;
		on all Create(scenarioId = scenarioId): scenCreate {
			log "initializeScenario().on_all_Create() - \""+scenarioId+"\" - Scenario instance create ignored - DataViewService does not handle incoming CREATE events from the ScenarioService." at WARN;
			emitNack(scenCreate.messageId, -1);
			return;
		}
		// ... secondly if it is created from the MonitorScript side of things
		DataViewAddItem dvAddItem;
		on all DataViewAddItem(dvName = getUnescapedDvName(dvName)): dvAddItem {
			log "initializeScenario().on_all_DataViewAddItem() - \""+dvName+"\" - " at DEBUG;
			addDataViewItem(dvAddItem);
		}
		
		
		// #########################################################
		// #########################################################
		// DELETE
		// From Scenario API - Ignore/Nack
		Delete scenDelete;
		on all Delete(scenarioId=scenarioId):scenDelete {
			log "initializeScenario().on_all_Delete() - \""+scenarioId+":"+scenDelete.scenarioInstanceId.toString()+"\" - Scenario instance delete ignored - DataViewService does not handle incoming DELETE events from the ScenarioService." at WARN;
			emitNack(scenDelete.messageId, scenDelete.scenarioInstanceId);
			return;
		}
		// From DataViewService API
		DataViewDeleteItem dvDeleteItem;
		on all DataViewDeleteItem(dvName=getUnescapedDvName(dvName)):dvDeleteItem {
			log "initializeScenario().on_all_DataViewDeleteItem() - \""+dvName+":"+dvDeleteItem.dvItemId.toString()+"\" - " at DEBUG;
			deleteDataViewItem(dvDeleteItem);
		}
		// From DataViewService API
		DataViewDeleteAllItems dvDeleteAllItems;
		on all DataViewDeleteAllItems(dvName=getUnescapedDvName(dvName)):dvDeleteAllItems {
			log "initializeScenario().on_all_DataViewDeleteAllItems() - \""+dvName+"\" - " at DEBUG;
			deleteAllDataViewItems(dvDeleteAllItems);
		}
		
		
		// #########################################################
		// #########################################################
		// EDIT
		// From Scenario API - Ignore/Nack
		Edit scenEdit;
		on all Edit(scenarioId = scenarioId):scenEdit {
			log "initializeScenario().on_all_Edit() - \""+scenarioId+":"+scenEdit.scenarioInstanceId.toString()+"\" - Scenario instance edit ignored - DataViewService does not handle incoming EDIT events from the ScenarioService." at WARN;
			emitNack(scenEdit.messageId, scenEdit.scenarioInstanceId);
			return;
		}		

		
		// #########################################################
		// #########################################################
		// ADD OR UPDATE (full)
		// Forward the AddOrUpdates from the Monitor via this DataViewService to the Scenario API
		DataViewAddOrUpdateItem dvAddOrUpdateItem;
		on all DataViewAddOrUpdateItem(dvName = getUnescapedDvName(dvName)):dvAddOrUpdateItem {
			addOrUpdateDataViewItem(dvAddOrUpdateItem);
		}

		// #########################################################
		// #########################################################
		// UPDATE (full)
		// Forward the Updates from the Monitor via this DataViewService to the Scenario API
		DataViewUpdateItem dvUpdateItem;
		on all DataViewUpdateItem(dvName = getUnescapedDvName(dvName)):dvUpdateItem {
			updateFullDataViewItem(dvUpdateItem);
		}

		// #########################################################
		// #########################################################
		// UPDATE (delta) - an update containing only deltas
		// Forward the Updates from the Monitor via this DataViewService to the Scenario API
		DataViewUpdateItemDelta dvUpdateItemDelta;
		on all DataViewUpdateItemDelta(dvName = getUnescapedDvName(dvName)):dvUpdateItemDelta {
			updateDeltaDataViewItem(dvUpdateItemDelta);
		}
		
		// ####################################################################
		// ####################################################################
		log "initializeScenario() - \""+dvName+"\" - complete." at DEBUG;
	}
	
	
	//===================================================================================

	
	// Management Actions

	/** Build the fieldname-index lookup dictionary, and add a the DataViewGetFieldLookup listener. */
	action initialiseFieldLookup(Scenario theScenario, string dataViewName) {
		log "initialiseFieldLookup() - building the dictionary, and adding a the DataViewGetFieldLookup listener" at DEBUG;
		string s;
		integer count := 0;
		dictionary <string, integer> fieldLookupDictionary := new dictionary<string, integer>; // fieldName : index in sequence
		for s in theScenario.outputNames {
			fieldLookupDictionary.add(s, count);
			count := count + 1;
		}		


		// Look for requests for the helper lookup dictionaries and reply
		DataViewGetFieldLookup lookupReq;
		on all DataViewGetFieldLookup(dvName = getUnescapedDvName(dataViewName)):lookupReq {
			log "initialiseFieldLookup().on_all_DataViewGetFieldLookup() - \""+dataViewName+"\" - routing DataViewFieldLookup event..." at DEBUG;
			route DataViewFieldLookup(lookupReq.msgId, dataViewName, fieldLookupDictionary, new dictionary<string,string>);
		}		
	}
	

	action generateInstanceDied(_Item item) {
		// this should only ever be called once, from deleteDataViewItem() or deleteAllDataViewItems(), so we no longer need a flag to says its been called.
		log "generateInstanceDied() - \""+scenarioId+":"+item.scenarioInstanceId.toString()+"\" - routing Died events." at DEBUG;
		updater.emitInstanceDied(item.scenarioInstanceId, item.owner);
	}
	
	
	//===================================================================================

	
	// Management Actions
	action onunload {
		route DataViewServiceUnloaded( new dictionary<string,string> );
		log "DataViewService implementation unloaded." at INFO;
	}
	
	
	//===================================================================================

	/* Build the compound key from a COMPLETE sequence of values (i.e. not just the keyFields).
	 * The key will ALWAYS be > "".  "" indicates an error.
	 * For a single-field (non-compound) key, whose value is "", just return the prefix.
	*/
	action buildCompoundKeyFromSeq(sequence<string> fieldValues) returns string {
		string key := "#";
		integer keyIndex;
		integer i:=0;
		if not (fieldValues.size() = NUM_FIELDS) then {
			log "buildCompoundKeyfromSeq() - the given sequence of fields is the wrong size. Required: "+NUM_FIELDS.toString()+", Found: "+fieldValues.size().toString() at WARN;
			return "";
		}
		for keyIndex in compoundKeyIndexes {
			if (fieldValues.size() <= keyIndex) then {
				log "buildCompoundKeyfromSeq() - the given sequence of fields does not contain a required keyField: "+compoundKeyNames[i]+", index: "+keyIndex.toString() at WARN;
				return "";
			}
			key := key + fieldValues[keyIndex]; 
			i:=i+1;
			if (compoundKeyIndexes.size() > i) then {
				key := key +":";
			}
		}
		return key;
	}

	/* Build the compound key from a sequence of keyField values ONLY (i.e. just the keyFields).
	 * The key will ALWAYS be > "".  "" indicates an error.
	 * For a single-field (non-compound) key, whose value is "", just return the prefix.
	*/
	action buildCompoundKeyFromKeySeq(sequence<string> keyFieldValues) returns string {
		string key := "#";
		string keyValue;
		integer i:=0;
		if not (keyFieldValues.size() = compoundKeyIndexes.size()) then {
			log "buildCompoundKeyfromKeySeq() - the given sequence of keyFields is the wrong size. Required: "+compoundKeyIndexes.size().toString()+", Found: "+keyFieldValues.size().toString() at WARN;
			return "";
		}
		for keyValue in keyFieldValues {
			key := key + keyValue; 
			i:=i+1;
			if (compoundKeyIndexes.size() > i) then {
				key := key +":";
			}
		}
		return key;
	}

	/* Build the compound key from a dictionary of fieldNAME<->fieldvalue. 
	 * The dictionary does not need to contain a complete set of fields, but must contain at least the keyFields.
	 * The key will ALWAYS be > "".  "" indicates an error.
	 * For a single-field (non-compound) key, whose value is "", just return the prefix.
	*/
	action buildCompoundKeyFromDict(dictionary<string,string> fields) returns string {
		string key := "#"; // all keys will have this prefix
		string keyName;
		integer i:=0;
		for keyName in compoundKeyNames {
			if not (fields.hasKey(keyName)) then {
				log "buildCompoundKeyfromDict() - the given dictionary does not contain a required keyField: "+keyName at WARN;
				return "";
			}
			key := key + fields[keyName];
			i:=i+1;
			if (compoundKeyIndexes.size() > i) then {
				key := key +":";
			}
		}
		return key;
	}

	/* Build the compound key from a dictionary of fieldINDEX<->fieldvalue. 
	 * The dictionary does not need to contain a complete set of fields, but must contain at least the keyFields.
	 * The key will ALWAYS be > "".  "" indicates an error.
	 * For a single-field (non-compound) key, whose value is "", just return the prefix.
	*/
	action buildCompoundKeyFromIndexDict(dictionary<integer,string> fields) returns string {
		string key := "#"; // all keys will have this prefix
		integer keyIndex;
		integer i:=0;
		for keyIndex in compoundKeyIndexes {
			if not (fields.hasKey(keyIndex)) then {
				log "buildCompoundKeyfromIndexDict() - the given dictionary does not contain a required keyField: "+compoundKeyNames[i]+", index: "+keyIndex.toString() at WARN;
				return "";
			}
			key := key + fields[keyIndex];
			i:=i+1;
			if (compoundKeyIndexes.size() > i) then {
				key := key +":";
			}
		}
		return key;
	}
	
	
	/** Add a new DataViewItem to the current (spawned) DataView.
	 * This action is called as a result of matching a DataViewAddItem.
	 * 
	 * @exception Routes a DataViewException event if the new Item cannot be added.
	 */
	action addDataViewItem(DataViewAddItem dvAddItem) {
		log "addDataViewItem() - \""+dvName+"\" - entered." at DEBUG;
		
		if (dvAddItem.fieldValues.size() != NUM_FIELDS) then {
			string msg := "DataView addItem ignored - " + NUM_FIELDS.toString() + " output field(s) required but " + dvAddItem.fieldValues.size().toString() + " provided.";
			
			// dvName is escaped already
			log "addDataViewItem() - \""+dvName+"\" - " + msg at WARN;
			route DataViewException(dvAddItem.msgId, dvName, msg, new dictionary<string,string>);
			return;
		}

		_Item newItem := createDefaultItem();
		newItem.owner := dvAddItem.owner;
		newItem.outputFields := dvAddItem.fieldValues;
		
		// are we using the automatic compound key feature? If so we must generate the key and store it in a dictionary
		if (compoundKeyIndexes.size()>0) then {
			// build the key
			string compoundKey := buildCompoundKeyFromSeq(newItem.outputFields);
			
			// dvName is escaped already
			log "addDataViewItem() - \""+dvName+"\" - compoundKey is: "+compoundKey at DEBUG;
			
			// do we already have an item with that key?
			if (compoundKeyInstanceDictionary.hasKey(compoundKey)) then {
				// reject the new item - duplicate key
				string msg := "DataView addItem ignored - the DataView uses the keyFields feature and the new item clashes with an existing item.  The supplied values were: "+dvAddItem.fieldValues.toString();
				log "addDataViewItem() - \""+dvName+"\" - " + msg at WARN;
				route DataViewException(dvAddItem.msgId, dvName, msg, new dictionary<string,string>);
				return;
			}
			
			// add the new key to the dictionary to map it to the scenarioInstanceId(=dvItemId)
			compoundKeyInstanceDictionary.add(compoundKey, scenarioInstanceId);
		}
		
		//copy then increment the main instanceId counter
		newItem.scenarioInstanceId := scenarioInstanceId;
		scenarioInstanceId := scenarioInstanceId + 1;

		// store the newly created Item
		log "addDataViewItem() - \""+dvName+":"+newItem.scenarioInstanceId.toString()+"\" - storing Item..." at INFO;
		instancesDictionary.add(newItem.scenarioInstanceId, newItem);
	
		// Send Created/Added events to both the Scenario and DataViewService APIs
		// This ensures that the Application MonitorScript and the Components such as Dashboards see the new instance
		log "addDataViewItem() - \""+dvName+":"+newItem.scenarioInstanceId.toString()+"\" - routing Created/Added events..." at DEBUG;
		updater.emitCreated(-1, newItem.scenarioInstanceId, newItem.owner, "RUNNING", new sequence<string>, newItem.outputFields);
		
		log "addDataViewItem() - \""+dvName+":"+newItem.scenarioInstanceId.toString()+"\" - routing initial Update event for this Item..." at DEBUG;
		float timeStamp := dvAddItem.timeStamp;
		if (-1.0=timeStamp) then {
			timeStamp:=currentTime;
		}
		updater.emitUpdate_time(newItem.scenarioInstanceId, timeStamp, newItem.outputFields, newItem.owner);
		
		route DataViewItem(dvAddItem.msgId, dvName, newItem.scenarioInstanceId, newItem.owner, newItem.outputFields, new dictionary<string,string>);

		log "addDataViewItem() - \""+dvName+":"+newItem.scenarioInstanceId.toString()+"\" - complete." at DEBUG;
	}
	
	
	/* Add a new DataViewItem to the current (spawned) DataView if it does not already exist, 
	 * or update it when it does exist. This will ONLY work when keyFields are used.
	 * Attempts to change the owner of an existing item will be rejected with a DataViewItemException.
	 *
	 * This action is called as a result of matching a DataViewAddOrUpdateItem.
	 * 
	 * @exception Routes a DataViewException event if the new Item cannot be added.
	 * @exception Routes a DataViewItemException event if the new Item attempts to change the owner of an existing item.
	 */
	action addOrUpdateDataViewItem(DataViewAddOrUpdateItem dvAddOrUpdateItem) {
		log "addOrUpdateDataViewItem() - \""+dvName+"\" - entered." at DEBUG;
		
		if (0=compoundKeyIndexes.size()) then { 
			// this DataView does not use keyFields - error - The DataViewAddOrUpdateItem event is only valid for DataViews which use keyFields
			string msg := "DataViewAddOrUpdateItem event is only valid for DataViews which use keyFields";
			log "addOrUpdateDataViewItem() - \""+dvName+"\" - routing DataViewException event - "+msg at WARN;
			route DataViewException(dvAddOrUpdateItem.msgId, dvName, msg, new dictionary<string,string>);
			return;
		}

		if (dvAddOrUpdateItem.fieldValues.size() != NUM_FIELDS) then {
			string msg := "DataView addOrUpdateItem ignored - " + NUM_FIELDS.toString() + " output field(s) required but " + dvAddOrUpdateItem.fieldValues.size().toString() + " provided.";
			log "addOrUpdateDataViewItem() - \""+dvName+"\" - " + msg at WARN;
			route DataViewException(dvAddOrUpdateItem.msgId, dvName, msg, new dictionary<string,string>);
			return;
		}

		_Item newItem := createDefaultItem();
		newItem.owner := dvAddOrUpdateItem.owner;
		newItem.outputFields := dvAddOrUpdateItem.fieldValues;
		
		// build the key
	
		string compoundKey := buildCompoundKeyFromSeq(newItem.outputFields);
		log "addOrUpdateDataViewItem() - \""+dvName+"\" - compoundKey is: "+compoundKey at DEBUG;
		
		// do we already have an item with that key?
		boolean alreadyExists := compoundKeyInstanceDictionary.hasKey(compoundKey);
		if (alreadyExists) then {
			// Yes we found the key - so we're going to get the existing item and update it (after a couple of checks)
			integer itemId := compoundKeyInstanceDictionary[compoundKey];
			newItem.scenarioInstanceId := itemId; // copy the ID for use when we send out the update
			log "addOrUpdateDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - found dvItemId for keyFields" at DEBUG;
			
			// Get the existing item
			_Item item := instancesDictionary[itemId];
			
			// Check the owner is not changed
			if (item.owner != newItem.owner) then {
				// reject the new item - attempted to change OWNER
				string msg := "DataView addOrUpdateItem ignored - detected attempt to change the owner of an existing item.  Current owner: \""+item.owner+"\", attempted owner: \""+newItem.owner+"\"";
				log "addOrUpdateDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - " + msg at WARN;
				route DataViewItemException(dvAddOrUpdateItem.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;
			}
			
			// Now we can make the change to the actual stored values
			item.outputFields := newItem.outputFields;
		}
		else {
			// No didn't find the key, so it must be new - add the new key to the dictionary to map it to the scenarioInstanceId(=dvItemId)
			compoundKeyInstanceDictionary.add(compoundKey, scenarioInstanceId);
			
			//copy then increment the main instanceId counter
			newItem.scenarioInstanceId := scenarioInstanceId;
			scenarioInstanceId := scenarioInstanceId + 1;

			// store the newly created Item
			log "addOrUpdateDataViewItem() - \""+dvName+":"+newItem.scenarioInstanceId.toString()+"\" - storing Item..." at INFO;
			instancesDictionary.add(newItem.scenarioInstanceId, newItem);
		
			// Send Created/Added events to both the Scenario and DataViewService APIs
			// This ensures that the Application MonitorScript and the Components such as Dashboards see the new instance
			log "addOrUpdateDataViewItem() - \""+dvName+":"+newItem.scenarioInstanceId.toString()+"\" - routing Created/Added events..." at DEBUG;
			updater.emitCreated(-1, newItem.scenarioInstanceId, newItem.owner, "RUNNING", new sequence<string>, newItem.outputFields);
		}

		// In either case (add or update), we now need to route the Update event
		log "addOrUpdateDataViewItem() - \""+dvName+":"+newItem.scenarioInstanceId.toString()+"\" - routing an Update event with the following field values:"+newItem.outputFields.toString() at DEBUG;
		float timeStamp := dvAddOrUpdateItem.timeStamp;
		if (-1.0=timeStamp) then {
			timeStamp:=currentTime;
		}
		updater.emitUpdate_time(newItem.scenarioInstanceId, timeStamp, newItem.outputFields, newItem.owner);
		
		if (not alreadyExists) then {
		
			route DataViewItem(dvAddOrUpdateItem.msgId, dvName, newItem.scenarioInstanceId, newItem.owner, newItem.outputFields, new dictionary<string,string>);
		}

		// All done
		log "addOrUpdateDataViewItem() - \""+dvName+":"+newItem.scenarioInstanceId.toString()+"\" - complete." at DEBUG;
	}


	/** Delete an existing DataViewItem from the current (spawned) DataView.
	 * This action is called as a result of matching a DataViewDeleteItem.
	 * 
	 * @exception Routes a DataViewItemException event if the Item cannot be deleted (not found, etc).
	 */
	action deleteDataViewItem(DataViewDeleteItem dvDeleteItem) {
		integer itemId := dvDeleteItem.dvItemId;
		string compoundKey;
		if (0<=itemId) then { // an itemId was supplied
			if (not instancesDictionary.hasKey(itemId)) then {
				string msg := "Unknown dvItemId: "+itemId.toString();
				log "deleteDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - routing DataViewItemException event - "+msg at WARN;
				route DataViewItemException(dvDeleteItem.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;
			}
		}
		else { // no itemId supplied
			if (0=compoundKeyIndexes.size()) then { 
				// this DataView does not use keyFields - error - must supply a dvItemId
				string msg := "A valid dvItemId must be supplied (this DataView does not use keyFields)";
				log "deleteDataViewItem() - \""+dvName+"\" - routing DataViewItemException event - "+msg at WARN;
				route DataViewItemException(dvDeleteItem.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;				
			}
			if (dvDeleteItem.keyFields.size() != compoundKeyIndexes.size()) then {
				// invalid number of keys supplied
				string msg := "Incorrect number of key fields supplied. Found "+dvDeleteItem.keyFields.size().toString()+", require "+compoundKeyIndexes.size().toString();
				log "deleteDataViewItem() - \""+dvName+"\" - routing DataViewItemException event - "+msg at WARN;
				route DataViewItemException(dvDeleteItem.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;				
			}

			// build the key
			compoundKey := buildCompoundKeyFromKeySeq(dvDeleteItem.keyFields);
			if (0=compoundKey.length()) then {
				// we get an error back from buildCompoundKey - most likely the key fields were not supplied
				string msg := "Invalid set of key fields supplied: "+dvDeleteItem.keyFields.toString();
				log "deleteDataViewItem() - \""+dvName+"\" - routing DataViewItemException event - "+msg at WARN;
				route DataViewItemException(dvDeleteItem.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;								
			}
			
			
			// all valid - get the itemId from the dictionary
			if (not compoundKeyInstanceDictionary.hasKey(compoundKey)) then {
				// we built a valid key, but no dvItem is currently known with that key
				string msg := "No DataViewItem could be found for the keyFields supplied: "+dvDeleteItem.keyFields.toString();
				log "deleteDataViewItem() - \""+dvName+"\" - routing DataViewItemException event - "+msg at WARN;
				route DataViewItemException(dvDeleteItem.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;
			}
			itemId := compoundKeyInstanceDictionary[compoundKey];
			log "deleteDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - found dvItemId for keyFields" at DEBUG;
			
			// remove that compound key
			compoundKeyInstanceDictionary.remove(compoundKey);
		}
		_Item item := instancesDictionary[itemId];

		// Tell everyone about Deletion
		generateInstanceDied(item);
		log "deleteDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - routing Deleted events..." at DEBUG;
		updater.emitDeleted(-1, itemId, item.owner);
		if (dvDeleteItem.keyFields.size() != compoundKeyIndexes.size()) then {
			// deleted using dvItemId, but this DataView is using keyFields, so we need to build the key to pass out in the Deleted event
			integer i := 0;
			while i < compoundKeyIndexes.size() {
				dvDeleteItem.keyFields.append( item.outputFields[compoundKeyIndexes[i]] );
				i := i + 1;
			}
		}
		route DataViewItemDeleted(dvDeleteItem.msgId, dvName, itemId, dvDeleteItem.keyFields, new dictionary<string,string>);
		log "deleteDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - removing Item..." at INFO;
		instancesDictionary.remove(itemId);
		
		//log "deleteDataViewItem() - instancesDictionary content after removal: "+instancesDictionary.toString() at DEBUG;
	}


	
	/** Delete all existing DataViewItems from the current (spawned) DataView.
	 * This action is called as a result of matching a DataViewDeleteAllItems.
	 * 
	 * @exception Routes a DataViewItemException event if the Item cannot be deleted (not found, etc).
	 */
	action deleteAllDataViewItems(DataViewDeleteAllItems dvDeleteAllItems) {
		
		// Iterate all the items an delete each one
		integer itemId;
		_Item item;
		for itemId in instancesDictionary.keys() {
			item := instancesDictionary[itemId];
			// Tell everyone about Deletion
			generateInstanceDied(item);
			log "deleteAllDataViewItems() - \""+dvName+":"+itemId.toString()+"\" - routing Deleted events..." at DEBUG;
			updater.emitDeleted(-1, itemId, item.owner);
		}
		
		// Clear the dictionaries
		log "deleteAllDataViewItems() - \""+dvName+"\" - removing ALL Items..." at INFO;
		compoundKeyInstanceDictionary.clear();
		instancesDictionary.clear();

		route DataViewAllItemsDeleted(dvDeleteAllItems.msgId, dvName, new dictionary<string,string>);
		
		//log "deleteAllDataViewItems() - instancesDictionary content after removal: "+instancesDictionary.toString() at DEBUG;
	}


	/** Update ALL the field values of an existing DataViewItem in the current (spawned) DataView.
	 * This action is called as a result of matching a DataViewUpdateItem.
	 * 
	 * @exception Routes a DataViewItemException event if the Item cannot be updated (not found, keyField clash, etc).
	 */
	action updateFullDataViewItem(DataViewUpdateItem dvupdate) {
		integer itemId := dvupdate.dvItemId;
		
		// first check the number of fields (this is required before some of the other checks)
		if (dvupdate.fieldValues.size()!= NUM_FIELDS) then {
			string msg := "DataView updateItem ignored - " + NUM_FIELDS.toString() + " output field(s) required but " + dvupdate.fieldValues.size().toString() + " provided.";
			log "updateFullDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - " + msg at WARN;
			route DataViewItemException(dvupdate.msgId, dvName, itemId, msg, new dictionary<string,string>);
			return;
		}

		string compoundKey := "";
		if (0>itemId) then { // no itemId supplied
			if (0=compoundKeyIndexes.size()) then { 
				// this DataView does not use keyFields - error - must supply a dvItemId
				string msg := "A valid dvItemId must be supplied (this DataView does not use keyFields)";
				log "updateFullDataViewItem() - \""+dvName+"\" - routing DataViewItemException event - "+msg at WARN;
				route DataViewItemException(dvupdate.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;				
			}
			// build the key
			compoundKey := buildCompoundKeyFromSeq(dvupdate.fieldValues);
			log "updateFullDataViewItem() - \""+dvName+"\" - compoundKey: "+compoundKey at DEBUG;
			if (0=compoundKey.length()) then {
				// we get an error back from buildCompoundKey - most likely the key fields were not supplied?
				string msg := "Unable to construct compound key from field values: "+dvupdate.fieldValues.toString();
				log "updateFullDataViewItem() - \""+dvName+"\" - routing DataViewItemException event - "+msg at WARN;
				route DataViewItemException(dvupdate.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;								
			}
			
			// all valid - get the itemId from the dictionary
			if (not compoundKeyInstanceDictionary.hasKey(compoundKey)) then {
				// we built a valid key, but no dvItem is currently known with that key
				string msg := "No DataViewItem could be found using the keyFields from the field values supplied: "+dvupdate.fieldValues.toString();
				log "updateFullDataViewItem() - \""+dvName+"\" - routing DataViewItemException event - "+msg at WARN;
				route DataViewItemException(dvupdate.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;
			}
			itemId := compoundKeyInstanceDictionary[compoundKey];
			log "updateFullDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - found dvItemId for keyFields" at DEBUG;
		}
		
		// check if we have an Item with the (supplied or calculated) itemId
		if (not instancesDictionary.hasKey(itemId)) then {
			string msg := "Unknown dvItemId: "+itemId.toString();
			log "updateFullDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - routing DataViewItemException event - "+msg at WARN;
			route DataViewItemException(dvupdate.msgId, dvName, itemId, msg, new dictionary<string,string>);
			return;
		}
				
		_Item item := instancesDictionary[itemId];
		
		// IMPORTANT
		// check we have not altered a keyField value if this DataView is configured for their use!!
		if (0<compoundKeyIndexes.size()) then {
			string existingCompoundKey := buildCompoundKeyFromSeq(item.outputFields);
			if (0=compoundKey.length()) then {
				compoundKey := buildCompoundKeyFromSeq(dvupdate.fieldValues);
			}
			if not (compoundKey=existingCompoundKey) then {
				string msg := "DataView updateItem ignored - It is not permitted to change the value of a keyField. The supplied values were: "+dvupdate.fieldValues.toString();
				log "updateFullDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - routing DataViewItemException event - "+msg at WARN;
				route DataViewItemException(dvupdate.msgId, dvName, itemId, msg, new dictionary<string,string>);

				log "updateFullDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - existing compoundKey: \""+existingCompoundKey+"\", new compoundKey: \""+compoundKey+"\"" at DEBUG;
				
				return;				
			}
		}

		// Now we can make the change to the actual stored values
		integer i:=0;
		while(i<NUM_FIELDS) {
			item.outputFields[i] := dvupdate.fieldValues[i].clone();
			i:=i+1;
		}

		log "updateFullDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - routing an Update event with the following field values:"+item.outputFields.toString() at DEBUG;
		float timeStamp := dvupdate.timeStamp;
		if (-1.0=timeStamp) then {
			timeStamp:=currentTime;
		}
		updater.emitUpdate_time(item.scenarioInstanceId, timeStamp, item.outputFields, item.owner);
	}
	
	
	/** Update a SUBSET of the field values of an existing DataViewItem in the current (spawned) DataView.
	 * This action is called as a result of matching a DataViewUpdateItemDelta.
	 * 
	 * @exception Routes a DataViewItemException event if the Item cannot be updated (not found, keyField clash, etc).
	 */
	action updateDeltaDataViewItem(DataViewUpdateItemDelta dvdelta) {

		integer numberOfUpdatedFields := dvdelta.fieldValues.size() - compoundKeyIndexes.size();
		if (numberOfUpdatedFields=0) or (dvdelta.fieldValues.size()=0) then {
			// empty delta
			log "updateDeltaDataViewItem() - \""+dvName+":"+dvdelta.dvItemId.toString()+"\" - empty delta - ignored. Delta field values: "+dvdelta.fieldValues.toString() at DEBUG;
			//route DataViewItemException(dvName, dvdelta.dvItemId, "Empty delta - ignored. Delta field values: "+dvdelta.fieldValues.toString(), new dictionary<string,string>);
			return;
		}
		
		integer itemId := dvdelta.dvItemId;
		string compoundKey := "";
		
		if (0>itemId) then { // no itemId supplied
			if (0=compoundKeyIndexes.size()) then { 
				// this DataView does not use keyFields - error - must supply a dvItemId
				string msg := "A valid dvItemId must be supplied (this DataView does not use keyFields)";
				log "updateDeltaDataViewItem() - \""+dvName+"\" - routing DataViewItemException event - "+msg at WARN;
				route DataViewItemException(dvdelta.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;				
			}
			if (numberOfUpdatedFields<0) then {
				// not enough dictionary items provided - must be at least the number of keyFields+1
				string msg := "Not enough delta field values provided. Must be at least number of keyFields +1 (="+ (compoundKeyIndexes.size()+1).toString() +"). Supplied delta field values: "+dvdelta.fieldValues.toString();
				log "updateDeltaDataViewItem() - \""+dvName+"\" - routing DataViewItemException event - "+msg at WARN;
				route DataViewItemException(dvdelta.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;				
			}
			// build the key
			compoundKey := buildCompoundKeyFromIndexDict(dvdelta.fieldValues);
			log "updateDeltaDataViewItem() - \""+dvName+"\" - compoundKey: "+compoundKey at DEBUG;
			
			if (0=compoundKey.length()) then {
				// we get an error back from buildCompoundKey - most likely the key fields were not supplied?
				string msg := "Unable to construct compound key from delta field values: "+dvdelta.fieldValues.toString();
				log "updateDeltaDataViewItem() - \""+dvName+"\" - routing DataViewItemException event - "+msg at WARN;
				route DataViewItemException(dvdelta.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;								
			}
			
			// all valid - get the itemId from the dictionary
			if (not compoundKeyInstanceDictionary.hasKey(compoundKey)) then {
				// we built a valid key, but no dvItem is currently known with that key
				string msg := "No DataViewItem could be found for the keyFields supplied: "+dvdelta.fieldValues.toString();
				log "updateDeltaDataViewItem() - \""+dvName+"\" - routing DataViewItemException event - "+msg at WARN;
				route DataViewItemException(dvdelta.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;
			}
			itemId := compoundKeyInstanceDictionary[compoundKey];
			log "updateDeltaDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - found dvItemId for keyFields" at DEBUG;
		}

		// check if we have an Item with the (supplied or calculated) itemId
		if (not instancesDictionary.hasKey(itemId)) then {
			string msg := "Unknown dvItemId: "+itemId.toString();
			log "updateDeltaDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - routing DataViewItemException event - "+msg at WARN;
			route DataViewItemException(dvdelta.msgId, dvName, itemId, msg, new dictionary<string,string>);
			return;
		}
		
		//log "updateDeltaDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - content of delta: "+dvdelta.fieldValues.toString() at DEBUG;
		_Item item := instancesDictionary[itemId];
		integer k;
		sequence<string> tmpFields := item.outputFields.clone(); // take a copy of the current values
		for k in dvdelta.fieldValues.keys() {
			if (k<0 or k>=NUM_FIELDS) then {
				string msg := "DataView updateItemDelta ignored - Invalid field index provided ("+k.toString()+") in the delta field values: "+dvdelta.fieldValues.toString();
				log "updateDeltaDataViewItem() - \""+dvName+"\" - " + msg at WARN;					
				route DataViewItemException(dvdelta.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;
			}
			// no need to check for duplicate indexs, as we're getting them out of a dictionary - by definition there can't be duplicate keys!

			tmpFields[k] := dvdelta.fieldValues[k]; // overwrite a specific value with a new value
		}
		
		// IMPORTANT
		// check we have not altered a keyField value if this DataView is configured for their use!!
		if (0<compoundKeyIndexes.size()) then {
			string existingCompoundKey := buildCompoundKeyFromSeq(item.outputFields);
			if (0=compoundKey.length()) then {
				compoundKey := buildCompoundKeyFromSeq(tmpFields);
			}
			if not (compoundKey=existingCompoundKey) then {
				string msg := "DataView updateItemDelta ignored - It is not permitted to change the value of a keyField. The supplied values were: "+dvdelta.fieldValues.toString();
				log "updateDeltaDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - routing DataViewItemException event - "+msg at WARN;
				route DataViewItemException(dvdelta.msgId, dvName, itemId, msg, new dictionary<string,string>);

				log "updateDeltaDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - existing compoundKey: \""+existingCompoundKey+"\", new compoundKey: \""+compoundKey+"\"" at DEBUG;

				return;				
			}
		}

		// Now we can make the change to the actual stored values
		item.outputFields := tmpFields; // replace with the new updated set
		
		log "updateDeltaDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - routing an Update event with the following field values: "+item.outputFields.toString() at DEBUG;
		float timeStamp := dvdelta.timeStamp;
		if (-1.0=timeStamp) then {
			timeStamp:=currentTime;
		}
		updater.emitUpdate_time(item.scenarioInstanceId, timeStamp, item.outputFields, item.owner);
	}

	
	//===================================================================================

	
	
	// The ACKs and NACKs for the Scenario API and the Scenario Bridge API.	
	action emitAcknowledgement(integer messageId, _Item item) {
		updater.emitAcknowledgement(messageId, item.scenarioInstanceId, item.outputFields);
	}

	action emitNack(integer messageId, integer scenarioInstanceId) {
		updater.emitNack(messageId, scenarioInstanceId);
	}

}
 0000003e C:\SoftwareAG\Apama 5.3\monitors\DataViewService_Impl_Dict.mon
TIME 0000000e 1444739459.9,1
MONF 0000c703 /*
 * $Copyright (c) 2012 Progress Software Corporation and/or its subsidiaries and affiliates. All rights reserved.$ 
 * $Copyright (c) 2013-2014 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its Subsidiaries and or/its Affiliates and/or their licensors.$ 
 * Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG 
 *
 * Event definitions for the Correlator-integrated Apama JMS adapter. 
 *
 * $Revision: 241128 $
 *
 */
package com.apama.correlator.jms;


// *****************************************************************************
// 
// Private event definitions - for internal use only. 
//

/** @private*/ event __AddSender
{
	string connectionId;
	string senderId;
	string senderReliability;
	dictionary<string,string> extraAddParams;
}

/** @private*/ event __RemoveSender
{
	string senderId;
}

/** @private*/ event __AddReceiver
{
	string connectionId;
	string receiverId;
	string destination;
	string receiverReliability;
	string durableTopicSubscriptionName;
	string messageSelector;
	boolean noLocal;
	dictionary<string,string> extraAddParams;
}

/** @private*/ event __RemoveReceiver
{
	string receiverId;
}

/** @private*/ event __JMSReceiverFlowControlWindowUpdate
{
	string receiverId;
	integer __processInstanceToken;
	integer __flowControlMarker;
	integer __flowControlWindow;
}

/** @private*/ event __ReceiverAcknowledgeAndResume
{
	string receiverId;
}

/** @private*/ event __JMSSenderFlush
{
	integer requestId;
	string channelName;
}

// *****************************************************************************
// 
// Public event API for dynamically adding/removing JMS senders and receivers
//
// To be notified about the successful addition or removal of senders and 
// receivers, applications should listen for the separate Sender/ReceiverStatus 
// events, looking for the OK or REMOVED status. 
//

/** An enumeration containing constants for the currently supported sender 
	reliability values.
*/
event JMSSenderReliability
{
	/** Best effort non-reliable messaging; events may be lost or duplicated 
		if a component fails. */
	constant string BEST_EFFORT := "BEST_EFFORT";
	/** Reliable messaging without duplicate detection. 
	
		Events may be  duplicated or reordered if a component fails, but will 
		not be lost. */
	constant string AT_LEAST_ONCE := "AT_LEAST_ONCE";
	/** Reliable messaging with duplicate detection identifiers. 
	
		Events may be reordered if a component fails, but will not be lost, 
		and will not be duplicated if the unique message ids are mapped into 
		the message and the receiving JMS client uses an appropriate duplicate 
		detection window. */
	constant string EXACTLY_ONCE := "EXACTLY_ONCE";
}

/** An enumeration containing constants for the message delivery modes for sender.
*/
event JMSMessageDeliveryMode
{
	/** Use PERSISTENT message delivery mode for sending messages to the broker.
	
		Reliable senders always use PERSISTENT message delivery mode.
	*/
	constant string PERSISTENT := "PERSISTENT";
	
	/** Use NON_PERSISTENT message delivery mode for sending messages to the broker.
	
		This is the default for BEST_EFFORT senders.
	*/
	constant string NON_PERSISTENT := "NON_PERSISTENT";
}

/** An event object representing an existing JMS sender. 
 *
 * A JMS sender has an associated channel to which Apama events can be "sent", 
 * which will then be mapped to JMS messages using the requested message 
 * reliability setting and delivered to a destination on the JMS message bus. 
 */
event JMSSender
{
	// Public
	
	/** Returns the unique identifier of this sender. */
	action getSenderId() returns string { return __senderId; }
	
	/** Returns the Correlator channel to use for events that should 
	 * be delivered to JMS using this sender. 
	 *
	 * Note that if this senderId does not exist or has been removed then 
	 * events sent to this channel will be lost without a warning. 
	 */
	action getChannel() returns string { return __channel; }
	
	/** Requests removal of this JMS sender. The removal will be performed 
	 * asynchronously, and completes after all events already sent by this 
	 * context have been passed to JMS, and the associated JMS producer and 
	 * session have been closed. 
	 *
	 * EPL applications may listen for the REMOVED JMSSenderStatus event to 
	 * detect when the removal has completed. 
	 *
	 * If the connection is currently down there could be an unbounded delay 
	 * in completing the removal of the sender. The application should not 
	 * send any more events to the sender channel once this action has been 
	 * called. 
	 *
	 * It is an error to attempt to remove a JMS sender that does not exist, or 
	 * to attempt to remove a static JMS sender. Such errors will result in 
	 * the termination of the current EPL monitor instance. 
	 * 
	 * @see JMSSenderStatus#REMOVED
	 */
	action remove()
	{
		__plugin.processControlEvent(__RemoveSender(__senderId).toString());
	}

	/** Returns the number of events that have been send to this sender's 
	 * channel from the application, but are still queued waiting to be sent to 
	 * JMS.
	 *
	 * This allows an EPL application to throttle or reduce the rate at which 
	 * it sends events based on the size of the backlog building up in the 
	 * Correlator's queues, to ensure that the Correlator does not run out of 
	 * memory due to a temporary peak in throughput rate or loss of the JMS 
	 * connection. 
	 *
	 * Calling this action is a slightly expensive operation, so it is best to 
	 * get the number of outstanding events once, then loop sending a batch of 
	 * events. Therefore do not call getOutstandingEvents inside a loop that is 
	 * continually sending events to JMS. 
	 *
	 * You must not call this method after calling remove().
	 */
	action getOutstandingEvents() returns integer
	{
		return __plugin.getOutstandingMessages(__senderId);
	}
	
	/** Requests a notification event after flushing all messages 
	 * already sent to the sender's channel by the current context. 
	 *
	 * A JMSSenderFlushed event will be sent to this context when all the 
	 * messages already sent to the sender channel have been processed 
	 * and passed to the JMS broker (or dropped, in the case of 
	 * non-recoverable mapping errors). 
	 *
	 * This feature is only applicable to BEST_EFFORT senders, as for 
	 * AT_LEAST_ONCE/EXACTLY_ONCE senders reliability is already taken care of 
	 * by the integration with Correlator state persistence. It is an error 
	 * to call this action from a persistent monitor. 
	 * 
	 * Applications may have multiple flush requests in flight at any one time. 
	 * Performance will be improved by sending multiple messages (e.g. 1000) 
	 * between each flush request.
	 *
	 * @returns The unique request id for flush request, which will be included 
	 * in the resulting JMSSenderFlushed event.
	 *
	 * @see JMSSenderFlushed Notification event sent in response to 
	 */
	action requestFlush() returns integer
	{
		__plugin.checkNonPersistentMonitor("requestFlush");
		integer requestId := integer.getUnique();
		string privateChannel := "com.apama.jms.backchannel." + context.current().getId().toString();
		monitor.subscribe(privateChannel);
		send __JMSSenderFlush(requestId, privateChannel) to self.getChannel();
		return requestId;
	}
	
	// Private
	
	/** @private*/ string __senderId;
	/** @private*/ string __channel;
	/** @private*/ import "JMSPlugin" as __plugin;

}

/** An event object representing the configuration of a new JMS sender, for 
 * dynamically adding JMS senders at runtime. 
 *
 * Call JMSConnection.createSenderConfiguration() to create an instance, and 
 * then use the setter actions to specify each required configuration option. 
 * Each setter method returns this configuration instance to make it possible 
 * to chain calls and specify all required options in a single statement. 
 *
 * @see JMSConnection#createSenderConfiguration() Creates a new 
 *	JMSSenderConfiguration event object. 
 * @see JMSConnection#addSenderWithConfiguration() Uses a JMSSenderConfiguration 
 *	to add a new JMS sender. 
 */
event JMSSenderConfiguration
{
	/** The unique identifier of this sender. */
	action getSenderId() returns string
	{ return __senderId; }

	/** The identifier of the connection this sender belongs to. */
	action getConnectionId() returns string
	{ return __connectionId; }
	
	/** Specifies the reliability mode to use for messages from this sender. 
	 * @param value Must be one of the enumeration constants from the 
	 * JMSSenderReliability event, or "" to indicate that the connection's 
	 * defaultSenderReliability should be used. 
	 * @see JMSSenderReliability
	 */
	action setSenderReliability(string value) returns JMSSenderConfiguration
	{ __senderReliability := value; return self; }
	/** Specifies the reliability mode to use for messages from this sender. */
	action getSenderReliability() returns string
	{ return __senderReliability; }
	
	/** Specifies the message delivery mode to use for messages from this sender.
	 *
	 * This can be used only for non-reliable BEST_EFFORT senders.
	 * It is ignored for reliable senders which always use PERSISTENT message 
	 * delivery mode.
	 *
	 * @param value Must be one of the enumeration constants from the 
	 * JMSMessageDeliveryMode event, or "" to indicate that the default mode will be used
	 * @see JMSMessageDeliveryMode
	 */
	action setMessageDeliveryMode(string value) returns JMSSenderConfiguration
	{ __messageDeliveryMode := value; return self; }
	/** Specifies the message delivery mode to use for messages from this sender. */
	action getMessageDeliveryMode() returns string
	{ return __messageDeliveryMode; }
	
	// Private fields
	
	/** @private*/ string __connectionId;
	/** @private*/ string __senderId;
	/** @private*/ string __senderReliability;
	/** @private*/ string __messageDeliveryMode;
	
	/** Initializes this object with required parameters 
	 * @private*/ 
	action __init(string connectionId, string senderId) 
	{
		self.__connectionId := connectionId;
		self.__senderId := senderId;
	}
	
	/** @private*/ 
	action __getAddSender() returns __AddSender
	{
		return __AddSender(
			getConnectionId(), 
			getSenderId(), 
			getSenderReliability(),
			{"MessageDeliveryMode":getMessageDeliveryMode()}
			);
	}
}

/** A notification event sent to an EPL application in response to a sender 
 * flush request.
 * 
 * The application context will receive this event after all the messages 
 * already sent by the application at the time of the flush request have been 
 * processed and passed to the JMS broker (or dropped, in the case of 
 * non-recoverable mapping errors). 
 *
 * This event will be sent to the context that requested message flushing.
 *
 * @see JMSSender#requestFlush()
 */
event JMSSenderFlushed
{
	/** The unique request id returned by the flush request.*/
	integer requestId;
	/** The identifier of sender. */
	string senderId;
}

/** An enumeration containing constants for the currently supported receiver 
	reliability values.
*/
event JMSReceiverReliability
{
	/** Best effort non-reliable messaging; events may be lost or duplicated 
		if a component fails. */
	constant string BEST_EFFORT := "BEST_EFFORT";
	/** Reliable messaging without duplicate detection; events may be 
		duplicated or reordered if a component fails, but will not be lost. */
	constant string AT_LEAST_ONCE := "AT_LEAST_ONCE";
	/** Reliable messaging with duplicate detection; events may be 
		reordered if a component fails, but will not be lost, and will not be 
		duplicated provided the unique message ids and duplicate detection 
		window are configured correctly. */
	constant string EXACTLY_ONCE := "EXACTLY_ONCE";
	/** Reliable messaging with acknowledgements controlled by the application.
	*/
	constant string APP_CONTROLLED := "APP_CONTROLLED";
}

/** An event object representing an existing JMS receiver. 
 *
 * A receiver listeners for messages on a specific JMS queue or topic, maps 
 * them to Apama events and sends them to the Correlator's public contexts. 
 */
event JMSReceiver
{
	// Public
	
	/** Returns the unique identifier of this receiver. */
	action getReceiverId() returns string { return __receiverId; }
	
	
	/** Requests removal of this JMS receiver. 
	 *
	 * The removal will be performed asynchronously, and completes after all 
	 * events already received from this JMS destination have been enqueued to 
	 * the Correlator, any persisted uniqueMessageIds no longer required for 
	 * duplicate detection have been deleted, any durable topic subscription 
	 * has been removed from the JMS broker, and the associated JMS consumer 
	 * and session have been closed. 
	 *
	 * EPL applications may listen for the REMOVED JMSReceiverStatus event to 
	 * detect when the removal has completed. 
	 *
	 * If the connection is currently down there could be an unbounded delay 
	 * in completing the removal of the receiver. 
	 *
	 * It is an error to attempt to remove a JMS receiver that does not exist, 
	 * or to attempt to remove a static JMS receiver. Such errors will result 
	 * in the termination of the current EPL monitor instance. 
	 * 
	 * @see JMSReceiverStatus#REMOVED
	 */
	action remove()
	{
		__plugin.processControlEvent(__RemoveReceiver(__receiverId).toString());
	}
	
	
	/** Signals that the application is ready for messages received 
	 * since the last appControlledAcknowledgeAndResume() call to be 
	 * acknowledged to JMS, and that message receiving can then resume. 
	 *
	 * This is used only by receivers which are running in APP_CONTROLLED 
	 * reliability mode. APP_CONTROLLED receivers should listen for the 
	 * JMSAppControlledReceivingSuspended event enqueued at the end of each 
	 * batch of incoming messages and respond by calling 
	 * appControlledAcknowledgeAndResume() once the messages or the output 
	 * events/state changes resulting from processing them have been reliably 
	 * stored in another system (e.g. sent and flushed to a downstream JMS 
	 * destination, or committed to a database or distributed MemoryStore). 
	 *
	 * To avoid race conditions, it is important to call this method only from 
	 * the context that is handling both the JMS messages from this receiver 
	 * and the JMSAppControlledReceivingSuspended event. 
	 * 
	 * Never call this method except in response to a 
	 * JMSAppControlledReceivingSuspended event, and do not call it from 
	 * a persistent monitor - both will result in an exception.
	 *
	 * @see JMSAppControlledReceivingSuspended
	 */
	action appControlledAcknowledgeAndResume() {
		__plugin.processControlEvent(__ReceiverAcknowledgeAndResume(__receiverId).toString());
	}
	
	// Private
	
	/** @private*/ string __receiverId;
	/** @private*/ import "JMSPlugin" as __plugin;

}

/** A notification event sent to an EPL application every time an APP_CONTROLLED 
 * receiver suspends, at the end of each message batch. 
 *
 * The application should respond by taking whatever action is required to 
 * ensure that the messages received since the last suspend 
 * or the output events/state changes resulting from processing them 
 * have been reliably stored in another system (e.g. sent and flushed to 
 * a downstream JMS destination, or committed to a database or distributed MemoryStore). 
 *
 * Once these operations have completed the application should call 
 * JMSReceiver.appControlledAcknowledgeAndResume() to signal that the message 
 * batch can be acknowledged to JMS (i.e. no longer needs to be retained for 
 * possible resending in the event of crash) and that receiving can resume. 
 *
 * This event will be sent to the same context(s) that are handling the 
 * messages from this receiver. 
 * The event will be sent at the end of every message 'batch' 
 * (see "maxBatchSize" in the documentation for more details). 
 * @see JMSReceiver#appControlledAcknowledgeAndResume()
 */
event JMSAppControlledReceivingSuspended
{
	/** The unique identifier of the suspended receiver. */
	string receiverId;
}


/** An event object representing the configuration of a new JMS receiver, for 
 * dynamically adding JMS receivers at runtime. 
 *
 * Call JMSConnection.createReceiverConfiguration() to create an instance, and 
 * then use the setter actions to specify each required configuration option. 
 * Each setter method returns this configuration instance to make it possible 
 * to chain calls and specify all required options in a single statement. 
 *
 * @see JMSConnection#createReceiverConfiguration() Creates a new 
 *	JMSReceiverConfiguration event object. 
 * @see JMSConnection#addReceiverWithConfiguration() Uses a 
 *	JMSReceiverConfiguration to add a new JMS receiver. 
 */
event JMSReceiverConfiguration
{
	/** The unique identifier of this receiver. */
	action getReceiverId() returns string
	{ return __receiverId; }

	/** The identifier of the connection this receiver belongs to. */
	action getConnectionId() returns string
	{ return __connectionId; }
	
	/** The queue or topic this receiver will listen to. */
	action getDestination() returns string
	{ return __destination; }
	
	/** Specifies the reliability mode to use for receiving messages. 
	 * @param value Must be one of the enumeration constants from the 
	 *	JMSReceiverReliability event, or "" to indicate that the connection's 
	 *	defaultReceiverReliability should be used. 
	 * @see JMSReceiverReliability
	 */
	action setReceiverReliability(string value) returns JMSReceiverConfiguration
	{ __receiverReliability := value; return self; }
	/** Specifies the reliability mode to use for receiving messages. */
	action getReceiverReliability() returns string
	{ return __receiverReliability; }
	
	/** Specifies the unique identifier for the subscription if a durable topic 
	 * subscription is to be created.
	 * @param value A unique JMS subscription name if a durable topic 
	 *	subscription should be created, or "" if a non-durable topic 
	 *	subscription should be made. Only valid for topics, and only if the 
	 *	reliability is not BEST_EFFORT.
	 */
	action setDurableTopicSubscriptionName(string value) returns JMSReceiverConfiguration
	{ __durableTopicSubscriptionName := value; return self; }
	/** Specifies the unique identifier for the subscription if a durable topic 
	 * subscription is to be created. */
	action getDurableTopicSubscriptionName() returns string
	{ return __durableTopicSubscriptionName; }

	/** Specifies the JMS message selector query string to select a subset of 
	 * queue/topic messages to be processed by this receiver. 
	 * @param value A message selector string, or "" to receive all messages. 
	 * See the JMS documentation for the javax.jms.Message interface for more 
	 * details. 
	 */
	action setMessageSelector(string value) returns JMSReceiverConfiguration
	{ __messageSelector := value; return self; }
	/** Specifies the JMS message selector query string to select a subset of 
	 * queue/topic messages to be processed by this receiver. */
	action getMessageSelector() returns string
	{ return __messageSelector; }

	/** Specifies an application-defined identifier to override how receivers 
	 * are grouped together for duplicate-detection purposes when using 
	 * EXACTLY_ONCE reliability. 
	 * @param value An arbitrary (but preferably short) string defined by the 
	 *	EPL application. All EXACTLY_ONCE receivers with this string will be 
	 *	grouped together to form a single duplicate detection domain. 
	 *
	 *	This is an advanced feature - by default, receivers are grouped into 
	 *	a duplicate detection domain together with other receivers in the 
	 *	same connectionId listening to the same destination, which is the 
	 *	correct setting in the majority of cases. 
	 */
	action setDupDetectionDomainId(string value) returns JMSReceiverConfiguration
	{ __dupDetectionDomainId := value; return self; }
	/** Specifies an application-defined identifier to override how receivers 
	 * are grouped together for duplicate-detection purposes when using 
	 * EXACTLY_ONCE reliability. */
	action getDupDetectionDomainId() returns string
	{ return __dupDetectionDomainId; }

	/** Specifies that messages sent to this destination by our own connection 
	 * should be ignored by the receiver. 
	 * @param value May be set to true or false for topic destinations. If 
	 *	the destination is a queue, the behaviour of noLocal=true is not 
	 *	specified, and will not work with many providers. The default value of 
	 *	false is usually fine. 
	 */
	action setNoLocal(boolean value) returns JMSReceiverConfiguration
	{ __noLocal := value; return self; }
	/** Specifies that messages sent to this destination by our own connection 
	 * should be ignored by the receiver. */
	action getNoLocal() returns boolean
	{ return __noLocal; }
	
	// Private fields
	
	/** @private*/ string __connectionId;
	/** @private*/ string __receiverId;
	/** @private*/ string __destination;
	/** @private*/ string __receiverReliability;
	/** @private*/ string __durableTopicSubscriptionName;
	/** @private*/ string __messageSelector;
	/** @private*/ string __dupDetectionDomainId;
	/** @private*/ boolean __noLocal;
	
	
	/** Initializes this object with required parameters 
	 * @private*/ 
	action __init(string connectionId, string receiverId, string destination) 
	{
		self.__connectionId := connectionId;
		self.__receiverId := receiverId;
		self.__destination := destination;
	}
	/** Initializes this object with required parameters 
	 * @private*/ 
	action __getAddReceiver() returns __AddReceiver
	{
		__AddReceiver result := new __AddReceiver;
		result.connectionId := getConnectionId();
		result.receiverId := getReceiverId();
		result.destination := getDestination();
		result.receiverReliability := getReceiverReliability();
		result.durableTopicSubscriptionName := getDurableTopicSubscriptionName();
		result.messageSelector := getMessageSelector();
		result.noLocal := getNoLocal();
		if getDupDetectionDomainId() != "" then { result.extraAddParams["dupDetectionDomainId"] := getDupDetectionDomainId(); }
		
		return result;
	}
}

/** An event object representing a JMS connection, with actions for 
 * manipulating a connection's existing senders and receivers, and also for 
 * dynamically adding senders and receivers at runtime. 
 *
 * Senders and receivers may be added dynamically either using the 
 * comprehensive JMSConnection.addReceiver/SenderWithConfiguration() actions 
 * which provide access to all configuration parameters, or one of the 
 * other addReceiver/Sender*() actions that simplify creation of 
 * senders/receivers using the more common configuration parameter sets. 
 *
 * @see JMS#getConnection() Use this method to get a JMSConnection
 */
event JMSConnection
{
	// Public
	
	/** The unique identifier of this connection. */
	action getConnectionId() returns string 
	{
		return __connectionId;
	}

	/** Get a JMSReceiver event object representing a receiver that already 
	 * exists, which might have been added dynamically, or defined statically 
	 * in the XML configuration file. 
	 *
	 * It is the caller's responsibility to specify a valid receiverId - the  
	 * specified identifier is not be validated as part of this action call. 
	 * If the identifier does not represent an existing receiver then 
	 * operations on the returned JMSReceiver (such as remove()) will cause an 
	 * error. 
	 */
	action getReceiver(string receiverId) returns JMSReceiver { return JMSReceiver(receiverId); }
	
	/** Get a JMSSender event object representing a sender that already 
	 * exists, which might have been added dynamically, or defined statically 
	 * in the XML configuration file. 
	 *
	 * It is the caller's responsibility to specify a valid senderId - the  
	 * specified identifier is not be validated as part of this action call. 
	 * If the identifier does not represent an existing sender then 
	 * operations on the returned JMSSender (such as remove()) will cause an 
	 * error. 
	 */
	action getSender(string senderId) returns JMSSender { return JMSSender(senderId, "jms:"+senderId); }

	/** Get a JMSSender event object representing the default sender for this 
	 * connection (which exists automatically if no other static senders 
	 * were explicitly configured). 
	 */
	action getDefaultSender() returns JMSSender { return getSender(__connectionId+"-default-sender"); }

	
	/** Requests the addition of a new dynamic JMS sender, with the specified 
	 * reliability setting. 
	 *
	 * EPL applications may listen for the JMSSenderStatus event to be notified 
	 * when the new sender has been added, and when it has reached the 
	 * "OK" state. Events can be sent to the sender's channel as soon as 
	 * this action returns. 
	 *
	 * A unique senderId will be generated automatically. 
	 *
	 * The monitor instance will usually be terminated with an ERROR if invalid 
	 * arguments are provided. 
	 *
	 * @param senderReliability An enumeration value from JMSSenderReliability 
	 * indicating the reliability setting to use for sending events. 
	 * Alternatively, specify an empty string "" to use the connection's 
	 * defaultSenderReliability. 
	 *
	 * @return A JMSSender instance which can be used to get the senderId for 
	 * status monitoring, the channel to send events to, and an action for 
	 * removing the sender when it is no longer required. 
	 * @see JMSSenderReliability
	 */
	action addSender(string senderReliability) returns JMSSender
	{
		return addSenderWithConfiguration(createSenderConfiguration(__makeUniqueId("sender", senderReliability))
			.setSenderReliability(senderReliability));
	}
	
	
	/** Requests the addition of a new dynamic JMS sender, with the specified 
	 * sender configuration. 
	 *
	 * EPL applications may listen for the JMSSenderStatus event to be notified 
	 * when the new sender has been added, and when it has reached the 
	 * "OK" state. Note that no events will actually be sent into the 
	 * Correlator until JMS.onApplicationInitialized() has been called. 
 	 *
	 * The monitor instance will usually be terminated with an ERROR if invalid 
	 * arguments are provided. 
	 *
	 * @param config An event representing the configuration of the new sender, 
	 * constructed using JMSConnection.createSenderConfiguration and the 
	 * setter methods on JMSSenderConfiguration.
	 *
	 * @return A JMSSender instance which can be used to get the senderId for 
	 * status monitoring, the channel to send events to, and an action for 
	 * removing the sender when it is no longer required. 
	 *
	 * @see JMSConnection#createSenderConfiguration()
	 */
	action addSenderWithConfiguration(JMSSenderConfiguration config) returns JMSSender
	{
		__plugin.processControlEvent(config.__getAddSender().toString());
		return getSender(config.getSenderId());
	}
	
	/** Create a JMSSenderConfiguration for this connection that can be 
	 * used to add a new sender with the specified settings. 
	 *
	 * @param senderId An application-defined unique identifier for this 
	 * sender, used to track status and removal. The senderId must not be an 
	 * empty string or contain the colon ":" character - if it does, the 
	 * monitor will terminate with an error when trying to create the sender.
	 *
	 * Applications are encouraged to use <tt>integer.getUnique().toString()</tt> 
	 * or a similar generator of unique numbers for all or part of the senderId. 
	 *
	 * @see JMSConnection#addSenderWithConfiguration()
	 */
	action createSenderConfiguration(string senderId) returns JMSSenderConfiguration
	{
		JMSSenderConfiguration result := new JMSSenderConfiguration;
		result.__init(__connectionId, senderId);
		return result;
	}

	/** Requests the addition of a new dynamic JMS receiver, with the specified 
	 * queue/topic name and reliability setting. 
	 *
	 * EPL applications may listen for the JMSReceiverStatus event to be 
	 * notified when the new receiver has been added, and when it has reached 
	 * the "OK" state. 
	 *
	 * A unique receiverId will be generated automatically. 
	 *
	 * The monitor instance will usually be terminated with an ERROR if invalid 
	 * arguments are provided. 
	 *
	 * @param destination A JMS queue name, JMS topic name, or JNDI name, 
	 *	prefixed by <tt>"queue:"</tt>, <tt>"topic:"</tt> or <tt>"jndi:"</tt>.
	 
	 * @param receiverReliability An enumeration value from 
	 *	JMSReceiverReliability indicating the reliability setting to use. 
	 *	Alternatively, specify an empty string "" to use the connection's 
	 *	defaultReceiverReliability. 
	 *
	 * @return A JMSReceiver instance which can be used to get the receiverId 
	 *	for status monitoring, and an action for removing the receiver when it 
	 *	is no longer required. 
	 * @see JMSReceiverReliability
	 */
	action addReceiver(string destination, string receiverReliability) returns JMSReceiver
	{
		return addReceiverWithConfiguration(
			createReceiverConfiguration(__makeUniqueId("receiver", destination), destination)
			.setReceiverReliability(receiverReliability));
	}

	/** Requests the addition of a new dynamic JMS durable topic subscription. 
	 *
	 * EPL applications may listen for the JMSReceiverStatus event to be 
	 * notified when the new receiver has been added, and when it has reached 
	 * the "OK" state. 
	 *
	 * This durable topic subscription will remain on the JMS broker until this 
	 * dynamic receiver is removed using JMSReceiver.remove(). 
	 *
	 * A unique receiverId will be generated automatically. 
	 *
	 * The monitor instance will usually be terminated with an ERROR if invalid 
	 * arguments are provided. 
	 *
	 * @param destination A JMS topic name, or JNDI name, 
	 *	prefixed by <tt>"topic:"</tt> or <tt>"jndi:"</tt>.
	 *
	 * @param receiverReliability An enumeration value from 
	 *	JMSReceiverReliability indicating the reliability setting to use.
	 
	 *	For a durable topic subscription, this must not be BEST_EFFORT.  
	 *	Specify an empty string "" to use the connection's 
	 *	defaultReceiverReliability. 
	 *
	 * @param durableTopicSubscriptionName The unique identifier used by the 
	 *	JMS broker for for this durable topic subscription. 
	 *
	 *	Must not be "", and must not match any other subscription name with the 
	 *	same connection clientID. 
	 *
	 * @param messageSelector An optional JMS message selector query string to 
	 *	select a subset of topic messages to be processed by this receiver, or 
	 *	"" to receive all messages. 
	 *
	 *	See the JMS documentation for the javax.jms.Message interface for more 
	 *	details. 

	 * @return A JMSReceiver instance which can be used to get the receiverId 
	 *	for status monitoring, and an action for removing the receiver when it 
	 *	is no longer required. 
	 * @see JMSReceiverReliability
	 * @see JMSReceiver#remove()
	 */
	action addReceiverWithDurableTopicSubscription(string destination, string receiverReliability, 
		string durableTopicSubscriptionName, string messageSelector) returns JMSReceiver
	{
		return addReceiverWithConfiguration(
			createReceiverConfiguration(__makeUniqueId("durable-subscriber", durableTopicSubscriptionName), destination)
			.setReceiverReliability(receiverReliability)
			.setMessageSelector(messageSelector)
			.setDurableTopicSubscriptionName(durableTopicSubscriptionName)
			);
	}

	/** Requests the addition of a new dynamic JMS receiver, with the specified 
	 * receiver configuration. 
	 *
	 * EPL applications may listen for the JMSReceiverStatus event to be 
	 * notified when the new receiver has been added, and when it has reached 
	 * the "OK" state. 
	 *
	 * The monitor instance will usually be terminated with an ERROR if invalid 
	 * arguments are provided. 
	 *
	 * @param config An event representing the configuration of the new 
	 * receiver, constructed using JMSConnection.createReceiverConfiguration 
	 * and the setter methods on JMSReceiverConfiguration.
	 *
	 * @return A JMSReceiver instance which can be used to get the receiverId 
	 * for status monitoring, and an action for removing the receiver when it 
	 * is no longer required. 
	 *
	 * @see JMSConnection#createReceiverConfiguration()
	 */
	action addReceiverWithConfiguration(JMSReceiverConfiguration config) returns JMSReceiver
	{
		__plugin.processControlEvent(config.__getAddReceiver().toString());
		return getReceiver(config.getReceiverId());
	}
	
	/** Create a JMSReceiverConfiguration for this connection that can be 
	 * used to add a new receiver with the specified settings. 
	 *
	 * @param receiverId An application-defined unique identifier for this 
	 * receiver, used to track status and removal. The receiverId must not be an 
	 * empty string or contain the colon ":" character - if it does, the 
	 * monitor will terminate with an error when trying to create the receiver.
	 *
	 * Applications are encouraged to use <tt>integer.getUnique().toString()</tt> 
	 * or a similar generator of unique numbers for all or part of the receiverId. 
	 *
	 * @param destination A JMS queue name, JMS topic name, or JNDI name, 
	 * prefixed by <tt>"queue:"</tt>, <tt>"topic:"</tt> or <tt>"jndi:"</tt>.
	 *
	 * @see JMSConnection#addReceiverWithConfiguration()
	 */
	action createReceiverConfiguration(string receiverId, string destination) returns JMSReceiverConfiguration
	{
		JMSReceiverConfiguration result := new JMSReceiverConfiguration;
		result.__init(__connectionId, receiverId, destination);
		return result;
	}
	
	// Private
	
	/** @private*/ string __connectionId;
	/** @private*/ import "JMSPlugin" as __plugin;
	
	/** @private*/ 
	action __makeUniqueId(string requiredSuffix, string optionalSuffix) returns string {
		string result := __connectionId+"-"+requiredSuffix;
		if optionalSuffix != "" then {
			result := result+"-"+optionalSuffix;
		}
		result := result.replaceAll(":","-"); // ensure it's a valid identifier
		return result + "-" + integer.getUnique().toString();
	}
	
}

/** The top-level event object representing the Correlator-integrated JMS 
 * runtime.
 */
event JMS
{
	// Public
	
	/** Should be called by EPL applications after all EPL has been injected 
	 * and initialized, to indicate that the application is ready to receive 
	 * events from the JMS runtime, such as received JMS messages and 
	 * status notification events. 
	 *
	 * Invoking this action more than once will have no effect. 
	 *
	 */
	action onApplicationInitialized() 
	{
		__plugin.onApplicationInitialized();
	}
	
	/** Get a JMSConnection event object representing a connection defined  
	 * in the XML configuration file. 
	 */
	action getConnection(string connectionId) returns JMSConnection
	{
		return JMSConnection(connectionId);
	}
	
	/** Get a JMSReceiver event object representing a receiver that already 
	 * exists, which might have been added dynamically, or defined statically 
	 * in the XML configuration file. 
	 *
	 * It is the caller's responsibility to specify a valid receiverId - the  
	 * specified identifier is not be validated as part of this action call. 
	 * If the identifier does not represent an existing receiver then 
	 * operations on the returned JMSReceiver (such as remove()) will cause an 
	 * error. 
	 */
	action getReceiver(string receiverId) returns JMSReceiver { return (new JMSConnection).getReceiver(receiverId); }
	
	/** Get a JMSSender event object representing a sender that already 
	 * exists, which might have been added dynamically, or defined statically 
	 * in the XML configuration file. 
	 *
	 * It is the caller's responsibility to specify a valid senderId - the  
	 * specified identifier is not be validated as part of this action call. 
	 * If the identifier does not represent an existing sender then 
	 * operations on the returned JMSSender (such as remove()) will cause an 
	 * error. 
	 */
	action getSender(string senderId) returns JMSSender { return (new JMSConnection).getSender(senderId); }
	
	// Private
	
	/** @private*/ import "JMSPlugin" as __plugin;
}


//*****************************************************************************
//
// Status events
//

/** 
 * A notification event sent to an EPL application when a configured JMS 
 * connection encounters an error or changes state. 
 *
 * This event includes string constants for each supported status. 
 *
 * Note that all notification events will be held back until 
 * JMS.onApplicationInitialized() has been called. 
 */
event JMSConnectionStatus
{
	/** The unique identifier of the JMS connection. 
	*/
	string connectionId;

	/** An enumeration value specifying the status of the connection. The 
	 * values in the enumeration are provided as constants in this event. 
	 *
	 * If the status is OK then the connection is up. 
	 */
	string status;
	
	/** A user-readable string specifying the cause of the error. This should 
		always be a non-empty string when the status is "ERROR". */
	string errorMessage;
	
	/** Additional status information items. None are currently supported. */
	dictionary<string,string> extraStatusInfo;
	
	// enumeration constants for status field value:
	
	/** The status value indicating that the Correlator-JMS runtime is fully 
		connected to the JMS broker with a valid JMS Connection object. */
	constant string OK := "OK";
	
	/** The status value indicating that the Correlator-JMS runtime is trying
		to establish an initial connection.  */
	constant string CONNECTING := "CONNECTING";

	/** The status value indicating that the connection is not available due to 
		some non-fatal error condition; the Correlator-JMS runtime will keep 
		retrying in the background. */
	constant string ERROR := "ERROR";
}

/** 
 * A notification event sent to an EPL application when a configured JMS 
 * sender has been created successfully, encounters an error, or is removed. 
 *
 * This event includes string constants for each supported status, and 
 * fields specifying information about the configuration of this sender
 * (as specified when it was created). 
 *
 * Note that all notification events will be held back until 
 * JMS.onApplicationInitialized() has been called. 
 *
 * JMSSenderStatus events are sent for both static senders in the 
 * configuration file (or the implicitly defined default sender), and 
 * dynamic senders created with JMSConnection.addSender.
 */
event JMSSenderStatus
{
	/** The unique identifier of the JMS connection. 
	*/
	string connectionId;

	/** The unique identifier of this sender. 
	*/
	string senderId;

	/** An enumeration value specifying the status of the sender. The values
	 * in the enumeration are provided as constants in this event. 
	 *
	 * If the status is OK then the sender is functioning correctly; if it 
	 * is REMOVED then removal of the sender has completed.  
	 */
	string status;
	
	/** A user-readable string specifying the cause of the error. This is 
	 * guaranteed not empty if status="ERROR" or "FATAL_ERROR". */
	string errorMessage;
	
	/** Additional status information items. None are currently supported. */
	dictionary<string,string> extraStatusInfo;
	
	// enumeration constants for status field value:
	
	/** The status value indicating that the sender is fully connected to the 
		JMS broker with a valid JMS Producer object, and is available to send 
		messages. */
	constant string OK := "OK";
	
	/** The status value indicating that the sender is waiting for the 
		JMS connection or sender session to be established. */
	constant string CONNECTING := "CONNECTING";
	/** The status value indicating that the sender is not available due to 
		some non-fatal error condition; the Correlator-JMS runtime will keep 
		retrying in the background. */
	constant string ERROR := "ERROR";
	
	/** The status value indicating that the sender is not available due to 
		a fatal error condition. 
		
		Senders in this state are no longer useful and should be removed by the 
		EPL application (if dynamic) or the system administrator (if statically 
		defined in the XML config file). Note that the removal of such failed 
		senders does not happen automatically. */
	constant string FATAL_ERROR := "FATAL_ERROR";
	/** The status value indicating that the removal of a dynamic sender has 
		been completed, which will be sent some time after a sender removal 
		request, once all the associated state on the broker and the 
		Correlator's database has been removed. 
		
		In rare cases it's possible that a status event for a sender may be 
		sent after the REMOVED status; any such event should be ignored.  */
	constant string REMOVED := "REMOVED";
	
	// fields specifying the sender's configuration:

	/** Sender quality of service, specifying the reliability mode of the 
		messages from this sender. 
		
		One of the enumeration constants from the JMSSenderReliability event. */
	string senderReliability;

	/** Additional sender configuration parameters specified when it was added. 
	*/
	dictionary<string,string> extraAddParams;

}

/** 
 * A notification event sent to an EPL application when a configured JMS 
 * receiver has been created successfully, encounters an error, or is removed. 
 *
 * This event includes string constants for each supported status, and 
 * fields specifying information about the configuration of this receiver
 * (as specified when it was created). 
 *
 * Note that the ordering of JMSReceiverStatus events relative to received 
 * messages is not defined. Also note that notification events will be held 
 * back until JMS.onApplicationInitialized() has been called. 
 *
 * JMSReceiverStatus events are sent for both static receivers in the 
 * configuration file, and dynamic receivers created with 
 * JMSConnection.addReceiver.
 */
event JMSReceiverStatus
{
	/** The unique identifier of the JMS connection.  */
	string connectionId;
	
	/** The unique identifier of this receiver. */
	string receiverId;

	/** An enumeration value specifying the status of the receiver. The values
	 * in the enumeration are provided as constants in this event. 
	 *
	 * If the status is OK then the receiver is functioning correctly; if it 
	 * is REMOVED then removal of the receiver has completed.  
	 */
	string status;
	
	/** A user-readable string specifying the cause of the error. This is 
	 * guaranteed not empty if status="ERROR" or "FATAL_ERROR". */
	string errorMessage;

	// enumeration constants for status field value:
	
	/** The status value indicating that the receiver is fully connected to the 
		JMS broker with a valid JMS Consumer object, and is available to receive 
		messages. */
	constant string OK := "OK";
	
	/** The status value indicating that the receiver is waiting for the 
		JMS connection or receiver session to be established. */
	constant string CONNECTING := "CONNECTING";
	/** The status value indicating that the receiver is not available due to 
		some non-fatal error condition; the Correlator-JMS runtime will keep 
		retrying in the background. */
	constant string ERROR := "ERROR";

	/** The status value indicating the  receiver could not be found because of 
		a problem accessing the specified destination (i.e. a JMS or JNDI 
		error). */
	constant string DESTINATION_NOT_FOUND := "DESTINATION_NOT_FOUND"; 	

	/** The status value indicating that the receiver is not available due to 
		a fatal error condition. 
		
		Receivers in this state are no longer useful and should be removed by 
		the EPL application (if dynamic) or the system administrator (if 
		statically defined in the XML config file). The removal of such failed 
		receivers does not happen automatically. 
	*/
	constant string FATAL_ERROR := "FATAL_ERROR";

	/** The status value indicating that the removal of a dynamic receiver has 
		been completed, which will be sent some time after a receiver removal 
		request, once all the associated state on the broker and the 
		Correlator's database has been removed. 
		
		In rare cases it's possible that a status event for a receiver may be 
		sent after the REMOVED status; any such event should be ignored.  */
	constant string REMOVED := "REMOVED";
	
	/** Additional status information items. None are currently supported. */
	dictionary<string,string> extraStatusInfo;

	// fields specifying the receiver's configuration:
	
	/** A JMS queue name, JMS topic name, or JNDI name, prefixed by 
		<tt>"queue:"</tt>, <tt>"topic:"</tt> or <tt>"jndi:"</tt>. */
	string destination;
	/** Receiver quality of service, specifying the reliability mode used 
		for receiving messages. 
		
		One of the enumeration constants from the JMSReceiverReliability event*/
	string receiverReliability;
	/** A unique JMS subscription name if a durable topic subscription should 
		be created, or "" if a non-durable topic subscription should be made. */
	string durableTopicSubscriptionName;
	/** JMS message selector string, to specify a subset of messages from the 
		destination to be processed by this receiver. 
	*/
	string messageSelector;
	/** Specifies that messages sent to this destination by our own connection 
		should be ignored by the receiver. */
	boolean noLocal;
	/** Additional receiver configuration parameters. None currently supported. */
	dictionary<string,string> extraAddParams;
}

//*****************************************************************************
//
// Advanced control events
//


/** A control event periodically sent to an EPL application for each receiver 
 * with receiverFlowControl enabled, which the application uses to update 
 * the flow control window.
 *
 * This event is used as a baseline from which the EPL application specifies 
 * the size of the window of new events it is currently ready to receive, 
 * specified relative to the last event received before this marker. 
 *
 * The event is sent:
 * i) when a receiver with receiverFlowControl=true is first added 
 * (once onApplicationInitialized has been called), 
 * ii) during recovery (in a persistent correlator), and 
 * iii) also periodically as JMS messages are received and 
 * enqueued to the correlator (typically these events are sent as often as 
 * the configured maxBatchSize, e.g. at least once every 1000 events). 
 *
 * To correctly implement the receiver flow control protocol, applications must 
 * respond to this event by calling updateFlowControlWindow (see below) 
 * to indicate the maximum number of additional events that the JMS runtime 
 * should take from this receiver, using the point in the event stream at 
 * which this marker was received as the baseline. 
 *
 * Applications that wish to  use flow control to throttle message receiving 
 * based on the number of outstanding asynchronous operations from 
 * already-received messages (to put a finite bound on memory usage) should 
 * also cache the most recent JMSReceiverFlowControlMarker for each 
 * active JMSReceiver so that the flow control window can be updated 
 * (e.g. extended) as pending operations complete, since there is no guarantee 
 * another JMSReceiverFlowControlMarker event will be sent until the window 
 * is extended enough for more events to be received. 
 *
 * Note that the fields of this event (apart from receiverId) are intended as 
 * 'opaque' data for internal use only and should be ignored by customer code.
 *
 * @see JMSReceiverFlowControlMarker#updateFlowControlWindow() Set the flow 
 * control window for this receiver, relative to this marker. 
 */ 
event JMSReceiverFlowControlMarker
{
	/** The unique identifier of this receiver. */
	string receiverId;
	
	/** For internal use only, treat as opaque data. */ 
	integer __processInstanceToken;
	
	/** For internal use only, treat as opaque data. */ 
	integer __flowControlMarker;
	
	/**
	* Sets the current flow control window size for a given receiver, which 
	* indicates the number of extra Apama events that should be taken from JMS 
	* and passed to the application before blocking, relative to the last data 
	* event received before this marker. 
	*
	* @param windowSizeEvents The maximum number of new events that should be 
	* received from this JMS receiver and enqueued to the correlator, relative 
	* to the position in the event flow indicated by this marker. 
	* The window size may be a constant number (e.g. 10,000 events) for 
	* applications that immediately process received events to completion,
	* or it may have a number of 'pending' events subtracted from it to create 
	* a bound on on the number of events that may be received from the JMS 
	* broker but are not yet been fully processed by the application (e.g. if 
	* an asynchronous database operation must complete before the memory, data 
	* structures or event listeners associated with the event may be deleted).
	*
	* It is valid to supply a zero or negative number for this value, in which 
	* case the JMS runtime will attempt to pause receiving, and take no more 
	* messages from the JMS queue/topic until this action is called again 
	* with a positive window (though it is not possible to guarantee that the 
	* flow of events will stop immediately, since some events could already be 
	* queued up). To allow an unbounded number of events to be received, 
	* specify integer.MAX for windowSizeEvents.
	* 
	* It is important that the overall long-term maximum window size 
	* (i.e. the chosen constant upper bound, ignoring any currently pending 
	* operations) is greater than than the receiver's maxBatchSize 
	* (typically 1000). 
	*/
	action updateFlowControlWindow(integer windowSizeEvents)
	{
		// use 'UnlessDisabled' as this should be a no-op when JMS is disabled, to support replay log
		__plugin.processControlEventUnlessDisabled(__JMSReceiverFlowControlWindowUpdate(
			receiverId, __processInstanceToken, __flowControlMarker, windowSizeEvents).toString()
		);
	}
	
	/** @private*/ import "JMSPlugin" as __plugin;
}
 00000038 C:\SoftwareAG\Apama 5.3\monitors\CorrelatorJMSEvents.mon
MONF 00003097 //*****************************************************************************
// Title:       StatusSupport
// Description: Provides event definitions for generic status reporting from  
//              service monitors.
//
// Revision:    $Revision: 235381 $
//
// $Copyright(c) 2006-2007, 2008-2009, 2011-2012 Progress Software Corporation (PSC). All rights reserved.$
// $Copyright (c) 2013-2014 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its Subsidiaries and or/its Affiliates and/or their licensors.$
// Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG
//
//*****************************************************************************

package com.apama.statusreport;

/*
	The events defined in this file act as an API between applications
	or blocks and service monitors.  They provide functionality to 
	Subscribe to status messages.
	
	The aim of this API is to provide an abstraction over any adapter
	specific details - for example, some adapters may require an explicit 
	call to subscribe to such data, some may be sent it anyway.
	
	Any adapter specific information that the application needs to supply
	or be supplied can be passed in the extraParams dictionary - these 
	are free-form (though there are conventions on the keys, see below).
	
	The service monitor also needs to handle any session initiation that
	may be required.
	
	A Status event does not denote a change of state, merely what the current
	state is - in particular, one will be sent out after every 
	SubscribeStatus request.

	All operations and responses are keyed on serviceId (if non-blank), 
	object,	connection and subServiceID. Every event starts with these 4 
	fields.
	
*/


/**
 *	Sent to the SubscribeStatus chanenl to subscribe to status.
 *	
 */
event SubscribeStatus {
	constant string CHANNEL := "SubscribeStatus";
	/**
	 *	service ID to subscribe to - blank will target all services.
	 */
	string serviceID;
	
	/**
	 *	object to request status of - this may include:
	 *	"Connection" - whether connected or not
	 *	"Market" - a market may be "Open", "Closed", or other states
	 */
	string object;
	
	/**
	 *	subService ID to subscribe to.
	 *	Some services may expose several services.  The interpretation of
	 *	this string is adapter-specific.
	 */
	string subServiceID;
	
	/**
	 *	connection to subscribe to.
	 *	Some services may expose several services.  The interpretation of
	 *	this string is adapter-specific.
	 */
	string connection;
}

/**
 *	Sent to the service monitor to unsubscribe from status.
 *	
 */
event UnsubscribeStatus {	 
	constant string CHANNEL := "SubscribeStatus";
	/**
	 *	service ID to subscribe to - blank will target all services
	 */
	string serviceID;
	
	/**
	 *	object to request status of - this may include:
	 *	"Connection" - whether connected or not
	 *	"Market" - a market may be "Open", "Closed", or other states
	 */
	string object;
	
	/**
	 *	subService ID to subscribe to.
	 *	Some services may expose several services.  The interpretation of
	 *	this string is adapter-specific.
	 */
	string subServiceID;
	
	/**
	 *	connection to subscribe to.
	 *	Some services may expose several services.  The interpretation of
	 *	this string is adapter-specific.
	 */
	string connection;
}


/**
 *	Sent from the service monitor to the StatusReport channel to notify the application of status for a 
 *	subscribed item.
 *	
 */
event Status {	
	constant string CHANNEL := "StatusReport";
	/**
	 *	service ID to subscribe to - blank will target all services
	 */
	string serviceID;
	
	/**
	 *	object to request status of - this may include:
	 *	"Connection" - whether connected or not
	 *	"MarketState" - a market may be "Open", "Closed", or other states
	 */
	string object;
	
	/**
	 *	subService ID to subscribe to.
	 *	Some services may expose several services.  The interpretation of
	 *	this string is adapter-specific.
	 */
	string subServiceID;
	
	/**
	 *	connection to subscribe to.
	 *	Some services may expose several services.  The interpretation of
	 *	this string is adapter-specific.
	 */
	string connection;

	/**
	 *	status description.
	 *	A free-form text string giving a description of the status.
	 */
	string description;
	
	/**
	 *	A sequence of summary strings specifying information about the 
	 *	status of the specified object.  This will be a well recognized
	 *	sequence of words - for example, a financial market's
	 *	"MarketState" may be "Open", "Closed", "PreOpen", etc.  A Connection 
	 *	may be "Connected", "Disconnected", "Disconnected LoginFailed", 
	 *	"Disconnected TimedOut", etc. 
	 */
	sequence<string> summaries;

	/**
	 *	available.
	 *	True if the object is "available" - the exact meaning is adapter 
	 * 	specific; for example, connected, open for general orders, etc.
	 */
	 boolean available;
	 
	 /** 
	 *	extra parameters that do not map into any of the above.  Convention
	 *	is that keys are in TitleCase.  e.g. "Username", "CloseTime", etc.
	 */
	wildcard dictionary <string, string> extraParams;
}


event StatusError {
	constant string CHANNEL := "StatusReport";
	/**
	 *	service ID to subscribe to - blank will target all services
	 */
	string serviceID;
	
	/**
	 *	object to request status of - this may include:
	 *	"Connection" - whether connected or not
	 *	"MarketState" - a market may be "Open", "Closed", or other states
	 */
	string object;
	
	/**
	 *	subService ID to subscribe to.
	 *	Some services may expose several services.  The interpretation of
	 *	this string is adapter-specific.
	 */
	string subServiceID;
	
	/**
	 *	connection to subscribe to.
	 *	Some services may expose several services.  The interpretation of
	 *	this string is adapter-specific.
	 */
	string connection;

	/**
	 *	status description.
	 *	A free-form text string giving a description of the status.
	 */
	string description;
	
	/**
	 *	Whether the subscription has been terminated.  Any subscribers will 
	 *	need to send a new SubscribeStatus request after this.
	 */
	boolean failed;
}
	
//*****************************************************************************
// Title:         ParallelStatusSupport
// Description:   ParallelStatusSupport description
// Dependencies:  None
// Author:        arrustem
//
//*****************************************************************************

/*
	Event definitions for block subject event wrappers;
	These are provided for backwards compatibility.  Monitors listening to status should instead subscribe to the "StatusReport" channel.
*/
event SubscribeStatusToContext {
	context instanceContext;
	SubscribeStatus subscribe;
}

event UnsubscribeStatusToContext {
	context instanceContext;
	UnsubscribeStatus unsubscribe;
}

monitor ParallelStatusSupport {
	/*	dictionary < [symbol] , sequence of contexts > eventRouter;
	 - eventRouter will keep track of all contexts that are listening to a particular symbol
	 - The same d.s. will be used for both, Status and StatusError
	   since they are added/removed precisely at the same time. 
	*/
	dictionary < SubscribeStatus , sequence<context> > eventRouter;
	
	/*	dictionary < [event key], dictionary < [contextId], [key ctr] > > statusToContextCtr;
	 - Keeps count of number of listeners for each symbol on each context
	*/
	dictionary < SubscribeStatus, dictionary < integer, integer > > statusToContextCtr;

	/*	dictionary < [symbol], listener > statusListeners;
	 - keeps track of the local listeners for Status
		dictionary < [symbol], listener > errorListeners;
	 - keeps track of the local listeners for StatusError
	*/
	dictionary < SubscribeStatus, listener > statusListeners;
	dictionary < SubscribeStatus, listener > errorListeners;
	
	action onload() {
		monitor.subscribe("StatusReport");
		// set up listeners for the wrapped events coming from subjects
		SubscribeStatusToContext subscribe;
		on all SubscribeStatusToContext():subscribe subscribeEventHandler(subscribe);
		
		UnsubscribeStatusToContext unsubscribe;
		on all UnsubscribeStatusToContext():unsubscribe unsubscribeEventHandler(unsubscribe);
	}
	
	action ondie() {
                // print out an error if statusToContextCtr is not empty
                if (statusToContextCtr.size() != 0) then {
                        log "ParallelStatusSupport is terminating but there may still be contexts subscribed to Status events" at ERROR;
                }
                else {
                        log "ParallelStatusSupport is terminating" at INFO;
                }
	}
	
	action onunload() {
		// not doing anything here since it is assumed that only one instance of this monitor is executing 
	}
	
	action subscribeEventHandler(SubscribeStatusToContext evt) {
		
		SubscribeStatus key := evt.subscribe;
		integer cId := evt.instanceContext.getId();
		
		// manage statusToContextCtr
		if not statusToContextCtr.hasKey(key) then {
			dictionary <integer, integer> entry := {cId:0};
			statusToContextCtr.add(key, entry);
		}
		else {
			if not statusToContextCtr[key].hasKey(cId) then {
				statusToContextCtr[key].add(cId, 0);
				
			}
		}
		statusToContextCtr[key][cId] := statusToContextCtr[key][cId] + 1;
		
		// manage eventRouter
		if not eventRouter.hasKey(key) then {
			sequence < context > entry := [];
			eventRouter.add(key, entry);
			addListener(key);
		}
		// look up context in the symbol
		if (eventRouter[key].indexOf(evt.instanceContext) = -1) then {
			eventRouter[key].append(evt.instanceContext);
		}

		route evt.subscribe;
	}

	action unsubscribeEventHandler(UnsubscribeStatusToContext evt) {
		
		// SubscribeStatus type for the "key" variable is only for the purposes of matching with the dictionary type 
		SubscribeStatus key := SubscribeStatus(evt.unsubscribe.serviceID, evt.unsubscribe.object, 
							   evt.unsubscribe.subServiceID, evt.unsubscribe.connection);
		
		integer cId := evt.instanceContext.getId();
		
		// manage statusToContextCtr
		if ((not statusToContextCtr.hasKey(key)) or 
			(not statusToContextCtr[key].hasKey(cId))) then {
			log "unsubscribeEventHandler: unexpected UnsubscribeStatusToContext received for (key=" + 
				key.toString() + ", contextId=" + cId.toString() + ")" at WARN;
		}
		else {
			statusToContextCtr[key][cId] := statusToContextCtr[key][cId] - 1;
			if (statusToContextCtr[key][cId] = 0) then {
				statusToContextCtr[key].remove(cId);
				integer i := eventRouter[key].indexOf(evt.instanceContext);
				if (i != -1) then {
					eventRouter[key].remove(i);
				}
			}
			if (statusToContextCtr[key].size() = 0) then {
				eventRouter.remove(key);
				removeListener(key);
			}
		}

		route evt.unsubscribe;
	}
	
	action addListener(SubscribeStatus evt) {
		listener dl, el;

		Status d;
		dl := on all Status(serviceID=evt.serviceID, object=evt.object, subServiceID=evt.subServiceID, connection=evt.connection):d {
			send d to eventRouter[evt];
		}
		if statusListeners.hasKey(evt) then {
			log "[action addListener] statusListeners already contains a listener for entry " + evt.toString() at WARN;
		}
		else {
			statusListeners.add(evt, dl);
		}
		
		StatusError e;
		el := on all StatusError(serviceID=evt.serviceID, object=evt.object, subServiceID=evt.subServiceID, connection=evt.connection):e {
			send e to eventRouter[evt];
		}
		if errorListeners.hasKey(evt) then {
			log "[action addListener] errorListeners already contains a listener for entry " + evt.toString() at WARN;
		}
		else {
			errorListeners.add(evt, el);
		}
	}
	
	action removeListener(SubscribeStatus evt) {

		if statusListeners.hasKey(evt) then {
			statusListeners[evt].quit();
			statusListeners.remove(evt);
		}
		else {
			log "[action removeListener] statusListeners does not contain a listener for entry " + evt.toString() at WARN;			
		}
		
		if errorListeners.hasKey(evt) then {
			errorListeners[evt].quit();
			errorListeners.remove(evt);
		}
		else {
			log "[action removeListener] errorListeners does not contain a listener for entry " + evt.toString() at WARN;			
		}
	}
}

 00000032 C:\SoftwareAG\Apama 5.3\monitors\StatusSupport.mon
MONF 0000348d /*
 * Apama Correlator-integrated JMS Status Manager service.
 *
 * Implements the StatusSupport event interface to allow an EPL application to 
 * monitor status information about the status of Correlator-Integrated JMS connections, 
 * senders and receivers.
 * 
 * $Copyright (c) 2012 Progress Software Corporation and/or its subsidiaries and affiliates. All rights reserved.$ 
 * $Copyright (c) 2013 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its Subsidiaries and or/its Affiliates and/or their licensors.$ 
 * Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG 
 *
 */
package com.apama.correlator.jms;

using com.apama.correlator.jms.JMSConnectionStatus;
using com.apama.correlator.jms.JMSSenderStatus;
using com.apama.correlator.jms.JMSReceiverStatus;
using com.apama.statusreport.Status;
using com.apama.statusreport.StatusError;
using com.apama.statusreport.SubscribeStatus;
using com.apama.statusreport.UnsubscribeStatus;


/**
 * Provides a bridge between the JMS-specific status events and the generic 
 * StatusSupport API used by some Apama applications. 
 *
 * @see com.apama.statusreport.SubscribeStatus Generic StatusSupport 
 * status subscription request that an application may send to SubscribeStatus.CHANNEL.
 * @see com.apama.statusreport.Status Generic StatusSupport 
 * status information sent to the Status channel by this monitor for subscribed 
 * objects.
 */
monitor CorrelatorJMSStatusManager 
{
	dictionary<SubscribeStatus, integer> subs;

	dictionary<string, JMSConnectionStatusPublisher> csPubs;
	dictionary<string, JMSSenderStatusPublisher> ssPubs;
	dictionary<string, JMSReceiverStatusPublisher> rsPubs;

	action onload() 
	{
		// Set up listeners for client requests
		listenForSubscribeStatus();
		listenForUnsubscribeStatus();
	
		// Set up listeners for correlator-jms status events
		listenForNewJmsEntities();
	}

	action ondie()
	{
		//Can't distinguish between abnormal termination and shutdown,
		//so just log a message to indicate termination.
		log "CORRELATOR_JMS status manager has terminated." at INFO;
	}

	action listenForSubscribeStatus()
	{
		monitor.subscribe(SubscribeStatus.CHANNEL);
		SubscribeStatus newSub;
		on all SubscribeStatus("CORRELATOR_JMS", *, *, *):newSub
		{
			if isValidSubscription(newSub) then 
			{
				log "Received status subscription: " + newSub.toString() at INFO;

				if subs.hasKey(newSub) then { subs.add(newSub, subs[newSub] + 1); }
				else { subs.add(newSub, 1); }

				boolean atLeastOneAckSent := false;
				
				JMSConnectionStatusPublisher csPub;
				for csPub in csPubs.values()
				{
					atLeastOneAckSent := csPub.ackMatchingNewSub(newSub) or atLeastOneAckSent;
				}

				JMSSenderStatusPublisher ssPub;
				for ssPub in ssPubs.values()
				{
					atLeastOneAckSent := ssPub.ackMatchingNewSub(newSub) or atLeastOneAckSent;
				}

				JMSReceiverStatusPublisher rsPub;
				for rsPub in rsPubs.values()
				{
					atLeastOneAckSent := rsPub.ackMatchingNewSub(newSub) or atLeastOneAckSent;
				}

				if not atLeastOneAckSent then 
				{
					log "No status events received yet from entities matching subscription: " + newSub.toString() at INFO;
					sequence<string> summaries := [ "UNKNOWN" ];
					dictionary<string,string> extraParams := {};	
					Status status := Status("CORRELATOR_JMS", newSub.object, newSub.subServiceID, newSub.connection, "No status events received yet from entities matching subscription", summaries, false, extraParams);
					send status to Status.CHANNEL; 
				}
			}
		}
	}

	action listenForUnsubscribeStatus() 
	{
		UnsubscribeStatus unsub;
		on all UnsubscribeStatus("CORRELATOR_JMS", *, *, *):unsub
		{
			if isValidUnsubscription(unsub) then
			{
				log "Received status unsubscription: " + unsub.toString() at INFO;
				SubscribeStatus key := SubscribeStatus(unsub.serviceID, unsub.object, unsub.subServiceID, unsub.connection);
	
				if subs.hasKey(key) then
				{
					if subs[key] <= 1 then
					{
						subs.remove(key);	
					}
					else { subs[key] := subs[key] - 1; }
				}
				else
				{
					log "No subscription exists that matches unsubscription: " + unsub.toString() at DEBUG;
				}
			}
		}
	}

	action listenForNewJmsEntities()
	{
		JMSConnectionStatus cs;
		on all JMSConnectionStatus():cs
		{
			if not csPubs.hasKey(cs.connectionId) then
			{
				log "Received connection status from new connection: " + cs.toString() at DEBUG;
				JMSConnectionStatusPublisher csPub := new JMSConnectionStatusPublisher;
				csPub.activate(cs, subs);
				csPubs.add(cs.connectionId, csPub);
			}
		}	

		JMSSenderStatus ss;
		on all JMSSenderStatus():ss
		{
			if not ssPubs.hasKey(ss.connectionId + ":" + ss.senderId) then
			{
				log "Received sender status from new sender: " + ss.toString() at DEBUG;
				JMSSenderStatusPublisher ssPub := new JMSSenderStatusPublisher;
				ssPub.activate(ss, subs);
				ssPubs.add(ss.connectionId + ":" + ss.senderId, ssPub);
			}
		}	

		JMSReceiverStatus rs;
		on all JMSReceiverStatus():rs
		{
			if not rsPubs.hasKey(rs.connectionId + ":" + rs.receiverId) then
			{
				log "Received receiver status from new receiver: " + rs.toString() at DEBUG;
				JMSReceiverStatusPublisher rsPub := new JMSReceiverStatusPublisher;
				rsPub.activate(rs, subs);
				rsPubs.add(rs.connectionId + ":" + rs.receiverId, rsPub);
			}
		}	
	}

	action isValidSubscription(SubscribeStatus sub) returns boolean 
	{ 
		return isValidSubOrUnsub(sub.serviceID, sub.object, sub.subServiceID, sub.connection, "SubscribeStatus", sub.toString()); 
	}	

	action isValidUnsubscription(UnsubscribeStatus unsub) returns boolean 
	{ 
		return isValidSubOrUnsub(unsub.serviceID, unsub.object, unsub.subServiceID, unsub.connection, "UnsubscribeStatus", unsub.toString()); 
	}	

	action isValidSubOrUnsub(string serviceID, string object, string subServiceID, string connection, string requestType, string asString) returns boolean
	{
		string errMsg;
		if serviceID = "CORRELATOR_JMS" then
		{
			if object = "" then
			{
				if not subServiceID = "" then
				{
					errMsg := "Invalid CORRELATOR_JMS " + requestType + " (subServiceID must be \"\" when object is \"\"): " + asString;	
					send StatusError(serviceID, object, subServiceID, connection, errMsg, true) to StatusError.CHANNEL;
					return false;
				}
			}
			else if object = "CONNECTION" then
			{
				if connection = "" then
				{
					errMsg := "Invalid CORRELATOR_JMS " + requestType + " (connection may not be \"\" when object is \"CONNECTION\"): " + asString;
					send StatusError(serviceID, object, subServiceID, connection, errMsg, true) to StatusError.CHANNEL;
					return false;
				}

				if not subServiceID = "" then
				{
					errMsg := "Invalid CORRELATOR_JMS " + requestType + " (subServiceID must be \"\" when object is \"CONNECTION\"): " + asString;	
					send StatusError(serviceID, object, subServiceID, connection, errMsg, true) to StatusError.CHANNEL;
					return false;
				}
			}
			else if object = "SENDER" or object = "RECEIVER" then
			{
				if connection = "" then
				{
					errMsg := "Invalid CORRELATOR_JMS " + requestType + " (connection may not be \"\" when object is \"" + object + "\"): " + asString;
					send StatusError(serviceID, object, subServiceID, connection, errMsg, true) to StatusError.CHANNEL;
					return false;
				}

				if subServiceID = "" then
				{
					errMsg := "Invalid CORRELATOR_JMS " + requestType + " (subServiceID may not be \"\" when object is \"" + object + "\"): " + asString;	
					send StatusError(serviceID, object, subServiceID, connection, errMsg, true) to StatusError.CHANNEL;
					return false;
				}
			}
			else
			{ 
				errMsg := "Invalid CORRELATOR_JMS " + requestType + " (valid values for object field are \"CONNECTION\", \"SENDER\", \"RECEIVER\" or \"\"): " + asString;
				send StatusError(serviceID, object, subServiceID, connection, errMsg, true) to StatusError.CHANNEL;
				return false; 
			} 
			
			return true;
		}
		else 
		{ 
			errMsg := "Unexpected request to validate non-CORRELATOR_JMS " + requestType + " (serviceID must be CORRELATOR_JMS): " + asString;
			send StatusError(serviceID, object, subServiceID, connection, errMsg, true) to StatusError.CHANNEL;
			return false; 
		}
	}

	event JMSConnectionStatusPublisher
	{
		JMSConnectionStatus current;	
		dictionary<SubscribeStatus, integer> allSubs;
		
		action activate(JMSConnectionStatus cs, dictionary<SubscribeStatus, integer> subs) 
		{
			current := cs;
			allSubs := subs;

			if existsMatchingSub() then { sendStatus(); }

			JMSConnectionStatus update;
			on all JMSConnectionStatus(current.connectionId, *, *, *):update
			{
				current := update;	
				if existsMatchingSub() then { sendStatus(); }	
			}
		}

		action existsMatchingSub() returns boolean 
		{ 
			SubscribeStatus sub;
			for sub in allSubs.keys()
			{
				if matches(sub) then { return true; }
			}
			return false;
		}

		action matches(SubscribeStatus sub) returns boolean
		{
			return (sub.object = "" and (sub.connection = "" or sub.connection = current.connectionId)) or 
	 			(sub.object = "CONNECTION" and sub.connection = current.connectionId);
		}

		action ackMatchingNewSub(SubscribeStatus newSub) returns boolean 
		{ 
			if matches(newSub) then
			{
				sendStatus();
				return true;
			} 
			return false;
		}

		action sendStatus() 
		{
			boolean available := false;
			if (current.status = JMSConnectionStatus.OK) then { available := true; }

			sequence<string> summaries := [ current.status ];
			dictionary<string,string> extraParams := {};	
			Status status := Status("CORRELATOR_JMS", "CONNECTION", "", current.connectionId, current.errorMessage, summaries, available, extraParams);
			send status to Status.CHANNEL;
		}
	}

	event JMSSenderStatusPublisher
	{
		JMSSenderStatus current;	
		dictionary<SubscribeStatus, integer> allSubs;

		action activate(JMSSenderStatus ss, dictionary<SubscribeStatus, integer> subs) 
		{
			current := ss;
			allSubs := subs;

			if existsMatchingSub() then { sendStatus(); }

			JMSSenderStatus update;
			on all JMSSenderStatus(current.connectionId, current.senderId, *, *, *, *, *):update
			{	
				current := update;	
				if existsMatchingSub() then { sendStatus(); }	
			}
		}

		action existsMatchingSub() returns boolean 
		{ 
			SubscribeStatus sub;
			for sub in allSubs.keys()
			{
				if matches(sub) then { return true; }
			}
			return false;
		}

		action matches(SubscribeStatus sub) returns boolean
		{
			return (sub.object = "" and (sub.connection = "" or sub.connection = current.connectionId)) or 
	 			(sub.object = "SENDER" and sub.connection = current.connectionId and sub.subServiceID = current.senderId);
		}

		action ackMatchingNewSub(SubscribeStatus newSub) returns boolean 
		{
			if matches(newSub) then
			{
				sendStatus();
				return true;
			} 
			return false;
		}

		action sendStatus() 
		{
			boolean available := false;
			if (current.status = JMSSenderStatus.OK) then { available := true; }

			sequence<string> summaries := [ current.status ];
			dictionary<string,string> extraParams := {};	
			Status status := Status("CORRELATOR_JMS", "SENDER", current.senderId, current.connectionId, current.errorMessage, summaries, available, extraParams);
			send status to Status.CHANNEL; 
		}
	}

	event JMSReceiverStatusPublisher
	{
		JMSReceiverStatus current;	
		dictionary<SubscribeStatus, integer> allSubs;

		action activate(JMSReceiverStatus rs, dictionary<SubscribeStatus, integer> subs) 
		{
			current := rs;
			allSubs := subs;

			if existsMatchingSub() then { sendStatus(); }
			
			JMSReceiverStatus update;
			on all JMSReceiverStatus(current.connectionId, current.receiverId, *, *, *, *, *, *, *, *, *):update
			{
				current := update;	
				if existsMatchingSub() then { sendStatus(); }	
			}
		}

		action existsMatchingSub() returns boolean 
		{ 
			SubscribeStatus sub;
			for sub in allSubs.keys()
			{
				if matches(sub) then { return true; }
			}
			return false;
		}

		action matches(SubscribeStatus sub) returns boolean
		{
			return (sub.object = "" and (sub.connection = "" or sub.connection = current.connectionId)) or 
	 			(sub.object = "RECEIVER" and sub.connection = current.connectionId and sub.subServiceID = current.receiverId);
		}

		action ackMatchingNewSub(SubscribeStatus newSub) returns boolean 
		{
			if matches(newSub) then
			{
				sendStatus();
				return true;
			} 
			return false;
		}

		action sendStatus() 
		{
			boolean available := false;
			if (current.status = JMSReceiverStatus.OK) then { available := true; }
			log "Sending receiver status report in response to status event: " + current.toString() at DEBUG;

			sequence<string> summaries := [ current.status ];
			dictionary<string,string> extraParams := {};	
			Status status := Status("CORRELATOR_JMS", "RECEIVER", current.receiverId, current.connectionId, current.errorMessage, summaries, available, extraParams);
			send status to Status.CHANNEL;
		}
	}
}
 0000003f C:\SoftwareAG\Apama 5.3\monitors\CorrelatorJMSStatusManager.mon
TIME 0000000c 1444739460,1
MONF 00000e5e //*****************************************************************************
// Title:         DashboardSupport.mon
// Description:   Monitor defining events to be sent when a client connects
//                or disconnects from a dashboard.  The monitor also provides
//                multi-context support for the connect/disconnect events.
// Dependencies:  None
// $Copyright(c) 2010 Progress Software Corporation (PSC). All rights reserved.$
// $Copyright (c) 2013-2014 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its Subsidiaries and or/its Affiliates and/or their licensors.$
// Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG
//
//*****************************************************************************

package com.apama.dashboard;


event DashboardClientConnected {
	string userName;
	string sessionId;
	dictionary<string,string> extraParams;
}

event DashboardClientDisconnected {
	string userName;
	string sessionId;
	dictionary<string,string> extraParams;
}

// Events to support parallel execution (contexts)

event RegisterContextForDashboardClientConnections {
	context instanceContext;
}

event DeregisterContextForDashboardClientConnections {
	context instanceContext;
}


/**
 * This monitor provides the context forwarders needed to allow
 * the Dashboard connect and disconnect notification events to be sent to
 * the registered contexts.
 * The notifications are always sent to the main context.
 */
monitor DashboardSupport
{
	// Used to persist contexts interested in notifications
	sequence < context > notifyContexts;

	action onload {
		
		log "Loaded Dashboard Client Connect Notification service" at INFO;
		
		// Forwarders to support parallel execution (contexts)
		setupContextForwarders();
		
	}
	
	action setupContextForwarders()
	{

		DashboardClientConnected connect;
		on all DashboardClientConnected(): connect {
			log "Dashboard Client Connected - User:" + connect.userName +
				"  Session:" + connect.sessionId at DEBUG;
			if notifyContexts.size() > 0 then {
				context ctx;
				for ctx in notifyContexts {
					send connect to ctx;
				}
			}
		}

		DashboardClientDisconnected disconnect;
		on all DashboardClientDisconnected(): disconnect {
			log "Dashboard Client Disconnected - User:" + disconnect.userName +
				"  Session:" + disconnect.sessionId at DEBUG;
			if notifyContexts.size() > 0 then {
				context ctx;
				for ctx in notifyContexts {
					send disconnect to ctx;
				}
			}
		}
		
		RegisterContextForDashboardClientConnections regCtx;
		on all RegisterContextForDashboardClientConnections():regCtx registerCtx(regCtx.instanceContext);
	
		DeregisterContextForDashboardClientConnections deregCtx;
		on all DeregisterContextForDashboardClientConnections():deregCtx deregisterCtx(deregCtx.instanceContext);
	}
	
	action registerCtx(context ctx)
	{		
		notifyContexts.append(ctx);
	}

	action deregisterCtx(context ctx)
	{
		if notifyContexts.size() > 0 then {
			integer ctxId := notifyContexts.indexOf(ctx);
			if ctxId >= 0 then {
				notifyContexts.remove(ctxId);
			}
		}
	}

	action ondie() {
		if (notifyContexts.size() != 0) then {
			log "ondie: Dashboard Support service is terminating but there may still be contexts subscribed to dashboard connect events" at ERROR;
		}
		else {
			log "ondie: Dashboard Support service is terminating" at INFO;
		}
	}

	action onunload {
		log "Unloaded Dashboard Support service" at INFO;
	}


}
 00000035 C:\SoftwareAG\Apama 5.3\monitors\DashboardSupport.mon
MONF 00000529 //*****************************************************************************
// Title:       ScenarioDeleterSupport
// Description: Provides event definitions for deleting Scenario instances. 
//
// Revision:    $Id: ScenarioDeleterSupport.mon 228871 2014-06-09 10:43:32Z matj $
//
// $Copyright(c) 2004-2005, 2008-2009 Progress Software Corporation (PSC). All rights reserved.$
// $Copyright (c) 2013-2014 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its Subsidiaries and or/its Affiliates and/or their licensors.$
// Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG
//
//*****************************************************************************

package com.apama.scenarios;

event DeleteAllScenarios {
	constant string CHANNEL := "ScenarioDeleter";
}

event DeleteScenariosByUser {
	string owner;
}

monitor ScenarioDeleterSupport {
	
	action onload() {
		
		DeleteAllScenarios deleteAll;
		on all DeleteAllScenarios():deleteAll {
			send deleteAll to DeleteAllScenarios.CHANNEL;
		}
		
		DeleteScenariosByUser deleteByUser;
		on all DeleteScenariosByUser():deleteByUser {
			send deleteByUser to DeleteAllScenarios.CHANNEL;
		}
	}
	
} 0000004c C:\SoftwareAG\Apama 5.3\monitors\scenario_support\ScenarioDeleterSupport.mon
MONF 000003b9 //*****************************************************************************
// Title:         SensorEvents
// Description:   SensorEvents description
// Dependencies:  None
// Author:        ydhimate
//
//*****************************************************************************

package com.prosoftgroup.klgame;

event AddSensor {
	string	sensorName;
}

event UserObject {
	string	userId;
	string	name;
	string	beaconId;
	string	regionLabel;
	string	timestamp;
	string	eventType;
}

event HelloWorld {
	string message;
}

event IWStatus {
	string iwstatus;
	string destination;
}

event IWRegion {
	string iwregion;
	string destination;
}

event IWCustomer {
	string iwcustomer;
	string destination;
}

event RegionCount {
	string regionLabel;
	integer count;
}

event UserCount {
	string userId;
	string name;
	integer count;
}

event DummyEvent {
	string	userId;
	string	name;

}


 0000005d C:\SoftwareAG\ApamaWork_5.3\studio_workspace\Prosoft_IW2015\eventdefinitions\SensorEvents.mon
MONF 00000849 //*****************************************************************************
//Title:         SensorSimulators
//Description:   SensorSimulators description
//Dependencies:  None
//Author:        ydhimate

//*****************************************************************************

package com.prosoftgroup.klgame; 

//TODO: Monitors and event definitions here

monitor SensorSimulator{

	sequence<string>  users := ["Carolyn Smith","James Walker","Erin Doe",
	                            "Chris Bean","Annie Hall", "Shawn Adams", "Pamela Halpert"];
	sequence<string>  regions := ["Terracotta", "Natural", "GCS", 
	                              "Meet the Experts", "Registration Desk", "General Entrance", 
	                              "Prosoft Booth", "Prosoft Booth", "Prosoft Booth",
	                              "Showcase Entrance", "Prosoft Booth", "Prosoft Booth"];
	string user;
	string userId;
	string  currentHall;
	boolean toggleHall := false;
		
	action onload() {
		DummyEvent dummy;
		on DummyEvent() :dummy {
			log dummy.toString();
			string s;
			for s in users {
				user := s;
				userId := (users.indexOf(user) + 90).toString();
				spawn simulationHandler();
			}
		}
	}


	action simulationHandler() {

		string	beaconId:="Beacon";
		string	regionLabel;
		string	timestamp:="";
		string	eventType:="";
		// Set initial values 
		integer randomWait;
		integer randomHall;
		integer waitTime;
		randomWait := 10;
		waitTime := randomWait.rand()*10;

		if waitTime = 0 then { waitTime := 10; }
		// Randomly fluctuate values for random seconds
		on all wait (waitTime.toFloat()) {
			randomHall := 12;
			regionLabel := regions[randomHall.rand()]; 
			if toggleHall = false then {
				currentHall := regionLabel;
				toggleHall := true;
			}
			else {
				regionLabel := currentHall;
				toggleHall := false;
			}
			
		//	print (toggleHall.toString() + "|" + waitTime.toString() + "|" + userId + "|" + user + "|" + regionLabel);
			
			route UserObject(userId,user,beaconId,regionLabel,timestamp,eventType);
		}

	}
} 00000059 C:\SoftwareAG\ApamaWork_5.3\studio_workspace\Prosoft_IW2015\monitors\SensorSimulators.mon
MONF 000025a7 //*****************************************************************************
// Title:         SensorMonitors
// Description:   SensorMonitors description
// Dependencies:  None
// Author:        ydhimate
//
//*****************************************************************************

package com.prosoftgroup.klgame; 
using com.apama.correlator.jms.JMS;
using com.apama.aggregates.count;

// TODO: Monitors and event definitions here

monitor SensorMonitors {
	
	JMS jms;
	sequence <string> names;
	UserObject userObject;
	UserObject idleObject;
	UserObject staticObject;
	float regionEntryTime := 0.0;
	float timeInRegion := 0.0;
	string currentRegion := "";
	float dealTime := 0.0;
	string status := "In Transit";
	string dealRemark := "Customer moving to another region";
	
	constant float IDLE_TRIGGER := 20.0;
	constant float DEAL_TRIGGER := 45.0;
	constant float DEAL_WAIT := 3600.0;
	constant float REGION_HISTORY := 3600.0;
	constant float STATUS_DELETE := 1800.0;
	
	action onload() {
		 
		on all UserObject() : userObject {
			integer index;
			index := names.indexOf(userObject.userId);
			
			if index = -1 then{

				names.append(userObject.userId);
				spawn sensorHandler (userObject.userId, userObject.name);
				route userObject;
			}
			
		}
		
		stream <UserObject> regionStream := all UserObject();
		
		UserObject region;
		RegionCount rcount;
		from region in regionStream within REGION_HISTORY
		  group by region.regionLabel
		  select RegionCount(region.regionLabel, count()):rcount {
			emit IWRegion(rcount.regionLabel + "|" + rcount.count.toString(), 
			              "topic:IWRegion") to "jms:UniversalMessaging-default-sender"; 
			//print "Count for region " + rcount.regionLabel + " - " + rcount.count.toString(); 
		}
		
//		UserObject user;
//		UserCount ucount;
		
//		from user in regionStream 
//		  partition by user.regionLabel within 3600.0
//		  group by user.userId, user.regionLabel
//		  select UserCount(user.regionLabel, user.userId, count()):ucount {
//			print "Count for user " + ucount.name + " - " + ucount.count.toString(); 
//		}
		
		jms.onApplicationInitialized();
		
		emit HelloWorld("Prosoft IW Demo: Refresh the tables") to "jms:UniversalMessaging-default-sender";
		
		route DummyEvent("Prosoft IW Demo", "Refresh complete" );
	
	
	}
	
	action sensorHandler (string id, string uname) {
		UserObject sensorObject;
		
		integer lastCount;
		integer idleCount;
		integer staticCount;
		boolean sendDeal := false;
		
		
		stream <UserObject> userStream := all UserObject(userId = id);
		
		from userObject in userStream within STATUS_DELETE
		  select count():lastCount {
			
			if lastCount = 0 then {
				
				emit IWStatus(userObject.userId + "|" 
				                + userObject.name + "|"
				                + currentRegion + "|" 
				                + status + "|"
				                + dealRemark + "|"
				                + sendDeal.toString() + "|"
				              + "delete" + "|"
				              + timeInRegion.toString(), "topic:IWStatus") to "jms:UniversalMessaging-default-sender";
		
				
			}
		}
		
		from idleObject in userStream within IDLE_TRIGGER 
		  select count(): idleCount {
			
			//print "IDLE OBJECT :" +idleCount.toString();
			if idleCount = 0 then {
				timeInRegion := currentTime - regionEntryTime;
				
				if timeInRegion >= DEAL_TRIGGER then {
					if dealTime = 0.0 then {
						sendDeal := true;
						dealTime := currentTime;
						
						dealRemark := " Deal sent to " + uname; 
					
					}
					else if (currentTime - dealTime) > DEAL_WAIT then {
						sendDeal := true;
						dealTime := currentTime;
						
						dealRemark := "Deal sent to " + uname;
					}
					else {
						sendDeal := false;
						dealRemark := "Deal already sent. Wait for the next deal for " + uname;
					}
				}
				
				
				//print "IDLE OBJECT :" + timeInRegion.toString();
				if (timeInRegion >= IDLE_TRIGGER and timeInRegion < DEAL_TRIGGER) then {
					status := "Idle";
					dealRemark := "Customer not moving";
				}
				else if (timeInRegion < IDLE_TRIGGER) then {
					status := "In Transit";
					dealRemark := "Customer moving to another region";
				}
				else if (timeInRegion >= DEAL_TRIGGER) then {
					status := "Stationary";
				}
			
				emit IWStatus(id + "|" 
				                + uname + "|"
				                + currentRegion + "|" 
				                + status + "|"
				                + dealRemark + "|"
				                + sendDeal.toString() + "|"
				              + "add" + "|"
				              + timeInRegion.toString(), "topic:IWStatus") to "jms:UniversalMessaging-default-sender";

			}
		}
		
		
		
		from idleObject in userStream within DEAL_TRIGGER 
		  select count(): staticCount {
			
			//print "STATIC OBJECT :" +staticCount.toString(); 
			if staticCount = 0 then {
				timeInRegion := currentTime - regionEntryTime;
				
				if timeInRegion >= DEAL_TRIGGER then {
					if dealTime = 0.0 then {
						sendDeal := true;
						dealTime := currentTime;
						
						dealRemark := " Deal sent to " + uname; 
					
					}
					else if (currentTime - dealTime) > DEAL_WAIT then {
						sendDeal := true;
						dealTime := currentTime;
						
						dealRemark := "Deal sent to " + uname;
					}
					else {
						sendDeal := false;
						dealRemark := "Deal already sent. Wait for the next deal for " + uname;
					}
				}
				
				//print "STATIC OBJECT :" + timeInRegion.toString();
				
				if (timeInRegion >= IDLE_TRIGGER and timeInRegion < DEAL_TRIGGER) then {
					status := "Idle";
					dealRemark := "Customer not moving";
				}
				else if (timeInRegion < IDLE_TRIGGER) then {
					status := "In Transit";
					dealRemark := "Customer moving to another region";
				}
				else if (timeInRegion >= DEAL_TRIGGER) then {
					status := "Stationary";
				}
			
				emit IWStatus(id + "|" 
				                + uname + "|"
				                + currentRegion + "|" 
				                + status + "|"
				                + dealRemark + "|"
				                + sendDeal.toString() + "|"
				              + "add" + "|"
				              + timeInRegion.toString(), "topic:IWStatus") to "jms:UniversalMessaging-default-sender";
			
			}
		}
		
		
		
		on all UserObject(userId=id) : sensorObject {
			
			//log "Received event " + sensorObject.toString();
			
			if currentRegion = "" then {
				currentRegion := sensorObject.regionLabel;
			}
			
			if currentRegion = sensorObject.regionLabel then {
				if regionEntryTime = 0.0 then {
					regionEntryTime := currentTime;
				}
				
				timeInRegion := currentTime - regionEntryTime;
				
				if timeInRegion >= DEAL_TRIGGER then {
					if dealTime = 0.0 then {
						sendDeal := true;
						dealTime := currentTime;
						
						dealRemark := " Deal sent to " + sensorObject.name; 
					
					}
					else if (currentTime - dealTime) > DEAL_WAIT then {
						sendDeal := true;
						dealTime := currentTime;
						
						dealRemark := "Deal sent to " + sensorObject.name;
					}
					else {
						sendDeal := false;
						dealRemark := "Deal already sent. Wait for the next deal for " + sensorObject.name;
					}
				}
				
				
				if (timeInRegion >= IDLE_TRIGGER and timeInRegion < DEAL_TRIGGER) then {
					status := "Idle";
					dealRemark := "Customer not moving";
				}
				else if (timeInRegion < IDLE_TRIGGER) then {
					status := "In Transit";
					dealRemark := "Customer moving to another region";
				}
				else if (timeInRegion >= DEAL_TRIGGER) then {
					status := "Stationary";
				}
			} 
			else {
				currentRegion := sensorObject.regionLabel;
				regionEntryTime := currentTime;
				timeInRegion := currentTime - regionEntryTime;
				status := "In Transit";
				dealRemark := "Customer moving to another region";
				dealTime := 0.0;
			}
			
//			print 	"Region Entry Time " + regionEntryTime.toString() + 
//			" Region Time " + timeInRegion.toString()+
//			" Current Region " + currentRegion + 
//			" Deal time " + dealTime.toString() + 
//			" Status " + status;
//			
			emit IWStatus(sensorObject.userId + "|" 
			                + sensorObject.name + "|"
			                + currentRegion + "|" 
			                + status + "|"
			                + dealRemark + "|"
			                + sendDeal.toString() + "|"
			              + "add" + "|" 
			              + timeInRegion.toString(), "topic:IWStatus") to "jms:UniversalMessaging-default-sender";
			
	
		}
	
		on all wait (13.0) {
			
			timeInRegion := currentTime - regionEntryTime;

			
			if timeInRegion >= DEAL_TRIGGER then {
				if dealTime = 0.0 then {
					sendDeal := true;
					dealTime := currentTime;
					
					dealRemark := " Deal sent to " + uname; 
				
				}
				else if (currentTime - dealTime) > DEAL_WAIT then {
					sendDeal := true;
					dealTime := currentTime;
					
					dealRemark := "Deal sent to " + uname;
				}
				else {
					sendDeal := false;
					dealRemark := "Deal already sent. Wait for the next deal for " + uname;
				}
			}
			
			
			emit IWStatus(id + "|" 
			                + uname + "|"
			                + currentRegion + "|" 
			                + status + "|"
			                + dealRemark + "|"
			                + sendDeal.toString() + "|"
			              + "add" + "|" + timeInRegion.toString(), "topic:IWStatus") to "jms:UniversalMessaging-default-sender";
	
	
		}		
	}
} 00000057 C:\SoftwareAG\ApamaWork_5.3\studio_workspace\Prosoft_IW2015\monitors\SensorMonitors.mon
DISC 0000003c 6795184426424404343:7002720798765353335 from 127.0.0.1:59296
EVNT 00000052 0 "",com.apama.correlator.jms.JMSConnectionStatus("UniversalMessaging","OK","",{})
EVNT 000000bb 0 "",com.apama.correlator.jms.JMSReceiverStatus("UniversalMessaging","UniversalMessaging-receiver-InnovationWorld","CONNECTING","",{},"topic:InnovationWorld","BEST_EFFORT","","",false,{})
EVNT 00000083 0 "",com.apama.correlator.jms.JMSSenderStatus("UniversalMessaging","UniversalMessaging-default-sender","OK","",{},"BEST_EFFORT",{})
EVNT 000000b3 0 "",com.apama.correlator.jms.JMSReceiverStatus("UniversalMessaging","UniversalMessaging-receiver-InnovationWorld","OK","",{},"topic:InnovationWorld","BEST_EFFORT","","",false,{})
TIME 0000000e 1444739461.6,1
EVNT 0000007a 6795184426424404343 "",com.apama.scenario.RequestScenarios("com.apama.scenario.private_6795194240424872337_1444739459631")
CONN 0000003c 7002734572725864823:7002735659352852855 from 127.0.0.1:59311
TIME 0000000e 1444739463.5,1
TIME 0000000e 1444739463.6,1
EVNT 0000007a 7002734572725864823 "",com.apama.scenario.RequestScenarios("com.apama.scenario.private_7002738124664211832_1444739463596")
TIME 0000000c 1444739470,1
TIME 0000000c 1444739480,1
TIME 0000000c 1444739483,1
TIME 0000000c 1444739490,1
TIME 0000000c 1444739496,1
TIME 0000000c 1444739500,1
TIME 0000000c 1444739503,1
TIME 0000000c 1444739509,1
TIME 0000000c 1444739510,1
TIME 0000000c 1444739513,1
TIME 0000000c 1444739515,1
TIME 0000000c 1444739516,1
TIME 0000000c 1444739520,1
TIME 0000000c 1444739522,1
TIME 0000000e 1444739523.6,1
DISC 0000003c 7002734572725864823:7002735659352852855 from 127.0.0.1:59311
TIME 0000000c 1444739525,1
TIME 0000000c 1444739526,1
TIME 0000000c 1444739529,1
TIME 0000000c 1444739530,1
TIME 0000000c 1444739535,1
TIME 0000000c 1444739539,1
TIME 0000000c 1444739540,1
TIME 0000000c 1444739542,1
TIME 0000000c 1444739545,1
TIME 0000000c 1444739548,1
TIME 0000000c 1444739550,1
TIME 0000000c 1444739552,1
TIME 0000000c 1444739553,1
TIME 0000000c 1444739555,1
TIME 0000000c 1444739560,1
TIME 0000000c 1444739561,1
TIME 0000000c 1444739565,1
TIME 0000000c 1444739566,1
TIME 0000000c 1444739568,1
TIME 0000000c 1444739570,1
TIME 0000000c 1444739574,1
TIME 0000000c 1444739575,1
TIME 0000000c 1444739578,1
TIME 0000000c 1444739579,1
TIME 0000000c 1444739580,1
TIME 0000000c 1444739581,1
TIME 0000000c 1444739585,1
TIME 0000000c 1444739587,1
TIME 0000000c 1444739590,1
TIME 0000000c 1444739591,1
TIME 0000000c 1444739592,1
TIME 0000000c 1444739594,1
TIME 0000000c 1444739595,1
TIME 0000000c 1444739600,1
TIME 0000000c 1444739604,1
TIME 0000000c 1444739605,1
TIME 0000000c 1444739607,1
TIME 0000000c 1444739610,1
TIME 0000000c 1444739613,1
TIME 0000000c 1444739615,1
TIME 0000000c 1444739617,1
TIME 0000000c 1444739618,1
TIME 0000000c 1444739620,1
TIME 0000000c 1444739625,1
TIME 0000000c 1444739626,1
TIME 0000000c 1444739630,1
TIME 0000000c 1444739631,1
TIME 0000000c 1444739633,1
TIME 0000000c 1444739635,1
TIME 0000000c 1444739639,1
TIME 0000000c 1444739640,1
TIME 0000000c 1444739643,1
TIME 0000000c 1444739644,1
TIME 0000000c 1444739645,1
TIME 0000000c 1444739646,1
TIME 0000000c 1444739650,1
TIME 0000000c 1444739652,1
TIME 0000000c 1444739655,1
TIME 0000000c 1444739656,1
TIME 0000000c 1444739657,1
TIME 0000000c 1444739659,1
TIME 0000000c 1444739660,1
TIME 0000000c 1444739665,1
TIME 0000000c 1444739669,1
TIME 0000000c 1444739670,1
TIME 0000000c 1444739672,1
TIME 0000000c 1444739675,1
TIME 0000000c 1444739678,1
TIME 0000000c 1444739680,1
TIME 0000000c 1444739682,1
TIME 0000000c 1444739683,1
TIME 0000000c 1444739685,1
TIME 0000000c 1444739690,1
TIME 0000000c 1444739691,1
TIME 0000000c 1444739695,1
TIME 0000000c 1444739696,1
TIME 0000000c 1444739698,1
TIME 0000000c 1444739700,1
TIME 0000000c 1444739704,1
TIME 0000000c 1444739705,1
TIME 0000000c 1444739708,1
TIME 0000000c 1444739709,1
TIME 0000000c 1444739710,1
TIME 0000000c 1444739711,1
TIME 0000000c 1444739715,1
TIME 0000000c 1444739717,1
TIME 0000000c 1444739720,1
TIME 0000000c 1444739721,1
TIME 0000000c 1444739722,1
TIME 0000000c 1444739724,1
TIME 0000000c 1444739725,1
TIME 0000000c 1444739730,1
TIME 0000000c 1444739734,1
TIME 0000000c 1444739735,1
TIME 0000000c 1444739737,1
TIME 0000000c 1444739740,1
TIME 0000000c 1444739743,1
TIME 0000000c 1444739745,1
TIME 0000000c 1444739747,1
TIME 0000000c 1444739748,1
TIME 0000000c 1444739750,1
TIME 0000000c 1444739755,1
TIME 0000000c 1444739756,1
TIME 0000000c 1444739760,1
TIME 0000000c 1444739761,1
TIME 0000000c 1444739763,1
TIME 0000000c 1444739765,1
TIME 0000000c 1444739769,1
TIME 0000000c 1444739770,1
TIME 0000000c 1444739773,1
TIME 0000000c 1444739774,1
TIME 0000000c 1444739775,1
TIME 0000000c 1444739776,1
TIME 0000000c 1444739780,1
TIME 0000000c 1444739782,1
TIME 0000000c 1444739785,1
TIME 0000000c 1444739786,1
TIME 0000000c 1444739787,1
TIME 0000000c 1444739789,1
TIME 0000000c 1444739790,1
TIME 0000000c 1444739795,1
TIME 0000000c 1444739799,1
TIME 0000000c 1444739800,1
TIME 0000000c 1444739802,1
TIME 0000000c 1444739805,1
TIME 0000000c 1444739808,1
TIME 0000000c 1444739810,1
TIME 0000000c 1444739812,1
TIME 0000000c 1444739813,1
TIME 0000000c 1444739815,1
TIME 0000000c 1444739820,1
TIME 0000000c 1444739821,1
TIME 0000000c 1444739825,1
TIME 0000000c 1444739826,1
TIME 0000000c 1444739828,1
TIME 0000000c 1444739830,1
TIME 0000000c 1444739834,1
TIME 0000000c 1444739835,1
TIME 0000000c 1444739838,1
TIME 0000000c 1444739839,1
TIME 0000000c 1444739840,1
TIME 0000000c 1444739841,1
TIME 0000000c 1444739845,1
TIME 0000000c 1444739847,1
TIME 0000000c 1444739850,1
TIME 0000000c 1444739851,1
TIME 0000000c 1444739852,1
TIME 0000000c 1444739854,1
TIME 0000000c 1444739855,1
TIME 0000000c 1444739860,1
TIME 0000000c 1444739864,1
TIME 0000000c 1444739865,1
TIME 0000000c 1444739867,1
TIME 0000000c 1444739870,1
TIME 0000000c 1444739873,1
TIME 0000000c 1444739875,1
TIME 0000000c 1444739877,1
TIME 0000000c 1444739878,1
TIME 0000000c 1444739880,1
TIME 0000000c 1444739885,1
TIME 0000000c 1444739886,1
TIME 0000000c 1444739890,1
TIME 0000000c 1444739891,1
TIME 0000000c 1444739893,1
TIME 0000000c 1444739895,1
TIME 0000000c 1444739899,1
TIME 0000000c 1444739900,1
TIME 0000000c 1444739903,1
TIME 0000000c 1444739904,1
TIME 0000000c 1444739905,1
TIME 0000000c 1444739906,1
TIME 0000000c 1444739910,1
TIME 0000000c 1444739912,1
TIME 0000000c 1444739915,1
TIME 0000000c 1444739916,1
TIME 0000000c 1444739917,1
TIME 0000000c 1444739919,1
TIME 0000000c 1444739920,1
TIME 0000000c 1444739925,1
TIME 0000000c 1444739929,1
TIME 0000000c 1444739930,1
TIME 0000000c 1444739932,1
TIME 0000000c 1444739935,1
TIME 0000000c 1444739938,1
TIME 0000000c 1444739940,1
TIME 0000000c 1444739942,1
TIME 0000000c 1444739943,1
TIME 0000000c 1444739945,1
TIME 0000000c 1444739950,1
TIME 0000000c 1444739951,1
TIME 0000000c 1444739955,1
TIME 0000000c 1444739956,1
TIME 0000000c 1444739958,1
TIME 0000000c 1444739960,1
TIME 0000000c 1444739964,1
TIME 0000000c 1444739965,1
TIME 0000000c 1444739968,1
TIME 0000000c 1444739969,1
TIME 0000000c 1444739970,1
TIME 0000000c 1444739971,1
TIME 0000000c 1444739975,1
TIME 0000000c 1444739977,1
TIME 0000000c 1444739980,1
TIME 0000000c 1444739981,1
TIME 0000000c 1444739982,1
TIME 0000000c 1444739984,1
TIME 0000000c 1444739985,1
TIME 0000000c 1444739990,1
TIME 0000000c 1444739994,1
TIME 0000000c 1444739995,1
TIME 0000000c 1444739997,1
TIME 0000000c 1444740000,1
TIME 0000000c 1444740003,1
TIME 0000000c 1444740005,1
TIME 0000000c 1444740007,1
TIME 0000000c 1444740008,1
TIME 0000000c 1444740010,1
TIME 0000000c 1444740015,1
TIME 0000000c 1444740016,1
TIME 0000000c 1444740020,1
TIME 0000000c 1444740021,1
TIME 0000000c 1444740023,1
TIME 0000000c 1444740025,1
TIME 0000000c 1444740029,1
TIME 0000000c 1444740030,1
TIME 0000000c 1444740033,1
TIME 0000000c 1444740034,1
TIME 0000000c 1444740035,1
TIME 0000000c 1444740036,1
TIME 0000000c 1444740040,1
TIME 0000000c 1444740042,1
TIME 0000000c 1444740045,1
TIME 0000000c 1444740046,1
TIME 0000000c 1444740047,1
TIME 0000000c 1444740049,1
TIME 0000000c 1444740050,1
TIME 0000000c 1444740055,1
TIME 0000000c 1444740059,1
TIME 0000000c 1444740060,1
TIME 0000000c 1444740062,1
TIME 0000000c 1444740065,1
TIME 0000000c 1444740068,1
TIME 0000000c 1444740070,1
TIME 0000000c 1444740072,1
TIME 0000000c 1444740073,1
TIME 0000000c 1444740075,1
TIME 0000000c 1444740080,1
TIME 0000000c 1444740081,1
TIME 0000000c 1444740085,1
TIME 0000000c 1444740086,1
TIME 0000000c 1444740088,1
TIME 0000000c 1444740090,1
TIME 0000000c 1444740094,1
TIME 0000000c 1444740095,1
TIME 0000000c 1444740098,1
TIME 0000000c 1444740099,1
TIME 0000000c 1444740100,1
TIME 0000000c 1444740101,1
TIME 0000000c 1444740105,1
TIME 0000000c 1444740107,1
TIME 0000000c 1444740110,1
TIME 0000000c 1444740111,1
TIME 0000000c 1444740112,1
TIME 0000000c 1444740114,1
TIME 0000000c 1444740115,1
TIME 0000000c 1444740120,1
TIME 0000000c 1444740124,1
TIME 0000000c 1444740125,1
TIME 0000000c 1444740127,1
TIME 0000000c 1444740130,1
TIME 0000000c 1444740133,1
TIME 0000000c 1444740135,1
TIME 0000000c 1444740137,1
TIME 0000000c 1444740138,1
TIME 0000000c 1444740140,1
TIME 0000000c 1444740145,1
TIME 0000000c 1444740146,1
TIME 0000000c 1444740150,1
TIME 0000000e 1444740150.1,1
TIME 0000000c 1444740151,1
TIME 0000000c 1444740153,1
TIME 0000000c 1444740155,1
TIME 0000000c 1444740159,1
TIME 0000000c 1444740160,1
TIME 0000000c 1444740163,1
TIME 0000000e 1444740163.1,1
TIME 0000000c 1444740164,1
TIME 0000000c 1444740165,1
TIME 0000000c 1444740166,1
TIME 0000000c 1444740170,1
TIME 0000000c 1444740172,1
TIME 0000000c 1444740175,1
TIME 0000000c 1444740176,1
TIME 0000000c 1444740177,1
TIME 0000000c 1444740179,1
TIME 0000000c 1444740180,1
TIME 0000000c 1444740185,1
TIME 0000000c 1444740189,1
TIME 0000000c 1444740190,1
TIME 0000000c 1444740192,1
TIME 0000000c 1444740195,1
TIME 0000000c 1444740198,1
TIME 0000000c 1444740200,1
TIME 0000000c 1444740202,1
TIME 0000000c 1444740203,1
TIME 0000000c 1444740205,1
TIME 0000000c 1444740210,1
TIME 0000000c 1444740211,1
TIME 0000000c 1444740215,1
TIME 0000000c 1444740216,1
TIME 0000000c 1444740218,1
TIME 0000000c 1444740220,1
TIME 0000000c 1444740224,1
TIME 0000000c 1444740225,1
TIME 0000000c 1444740228,1
TIME 0000000c 1444740229,1
TIME 0000000c 1444740230,1
TIME 0000000c 1444740231,1
TIME 0000000c 1444740235,1
TIME 0000000c 1444740237,1
TIME 0000000c 1444740240,1
TIME 0000000c 1444740241,1
TIME 0000000c 1444740242,1
TIME 0000000c 1444740244,1
TIME 0000000c 1444740245,1
TIME 0000000c 1444740250,1
TIME 0000000c 1444740254,1
TIME 0000000c 1444740255,1
TIME 0000000c 1444740257,1
TIME 0000000c 1444740260,1
TIME 0000000c 1444740263,1
TIME 0000000c 1444740265,1
TIME 0000000c 1444740267,1
TIME 0000000c 1444740268,1
TIME 0000000c 1444740270,1
TIME 0000000c 1444740275,1
TIME 0000000c 1444740276,1
TIME 0000000c 1444740280,1
TIME 0000000c 1444740281,1
TIME 0000000c 1444740283,1
TIME 0000000c 1444740285,1
TIME 0000000c 1444740289,1
TIME 0000000c 1444740290,1
TIME 0000000c 1444740293,1
TIME 0000000c 1444740294,1
TIME 0000000c 1444740295,1
TIME 0000000c 1444740296,1
TIME 0000000c 1444740300,1
TIME 0000000c 1444740302,1
TIME 0000000c 1444740305,1
TIME 0000000c 1444740306,1
TIME 0000000c 1444740307,1
TIME 0000000c 1444740309,1
TIME 0000000c 1444740310,1
TIME 0000000c 1444740315,1
TIME 0000000c 1444740319,1
TIME 0000000c 1444740320,1
TIME 0000000c 1444740322,1
TIME 0000000c 1444740325,1
TIME 0000000c 1444740328,1
TIME 0000000c 1444740330,1
TIME 0000000c 1444740332,1
TIME 0000000c 1444740333,1
TIME 0000000c 1444740335,1
TIME 0000000c 1444740340,1
TIME 0000000c 1444740341,1
TIME 0000000c 1444740345,1
TIME 0000000c 1444740346,1
TIME 0000000c 1444740348,1
TIME 0000000c 1444740350,1
TIME 0000000c 1444740354,1
TIME 0000000c 1444740355,1
TIME 0000000c 1444740358,1
TIME 0000000c 1444740359,1
TIME 0000000c 1444740360,1
TIME 0000000c 1444740361,1
TIME 0000000c 1444740365,1
TIME 0000000c 1444740367,1
TIME 0000000c 1444740370,1
TIME 0000000c 1444740371,1
TIME 0000000c 1444740372,1
TIME 0000000c 1444740374,1
TIME 0000000c 1444740375,1
TIME 0000000c 1444740380,1
TIME 0000000c 1444740384,1
TIME 0000000c 1444740385,1
TIME 0000000c 1444740387,1
TIME 0000000c 1444740390,1
TIME 0000000c 1444740393,1
TIME 0000000c 1444740395,1
TIME 0000000c 1444740397,1
TIME 0000000c 1444740398,1
TIME 0000000c 1444740400,1
TIME 0000000c 1444740405,1
TIME 0000000c 1444740406,1
TIME 0000000c 1444740410,1
TIME 0000000c 1444740411,1
TIME 0000000c 1444740413,1
TIME 0000000c 1444740415,1
TIME 0000000c 1444740419,1
TIME 0000000c 1444740420,1
TIME 0000000c 1444740423,1
TIME 0000000c 1444740424,1
TIME 0000000c 1444740425,1
TIME 0000000c 1444740426,1
TIME 0000000c 1444740430,1
TIME 0000000c 1444740432,1
TIME 0000000c 1444740435,1
TIME 0000000c 1444740436,1
TIME 0000000c 1444740437,1
TIME 0000000c 1444740439,1
TIME 0000000c 1444740440,1
TIME 0000000c 1444740445,1
TIME 0000000c 1444740449,1
TIME 0000000c 1444740450,1
TIME 0000000c 1444740452,1
TIME 0000000c 1444740455,1
TIME 0000000c 1444740458,1
TIME 0000000c 1444740460,1
TIME 0000000c 1444740462,1
TIME 0000000c 1444740463,1
TIME 0000000e 1444740463.1,1
TIME 0000000c 1444740465,1
TIME 0000000c 1444740470,1
TIME 0000000c 1444740471,1
TIME 0000000c 1444740475,1
TIME 0000000c 1444740476,1
TIME 0000000c 1444740478,1
TIME 0000000c 1444740480,1
TIME 0000000c 1444740484,1
TIME 0000000c 1444740485,1
TIME 0000000c 1444740488,1
TIME 0000000c 1444740489,1
TIME 0000000c 1444740490,1
TIME 0000000c 1444740491,1
TIME 0000000c 1444740495,1
TIME 0000000c 1444740497,1
TIME 0000000c 1444740500,1
TIME 0000000c 1444740501,1
TIME 0000000c 1444740502,1
TIME 0000000c 1444740504,1
TIME 0000000c 1444740505,1
TIME 0000000c 1444740510,1
TIME 0000000c 1444740514,1
TIME 0000000c 1444740515,1
TIME 0000000c 1444740517,1
TIME 0000000c 1444740520,1
TIME 0000000c 1444740523,1
TIME 0000000c 1444740525,1
TIME 0000000c 1444740527,1
TIME 0000000c 1444740528,1
TIME 0000000c 1444740530,1
TIME 0000000c 1444740535,1
TIME 0000000c 1444740536,1
TIME 0000000c 1444740540,1
TIME 0000000c 1444740541,1
TIME 0000000c 1444740543,1
TIME 0000000c 1444740545,1
TIME 0000000c 1444740549,1
TIME 0000000c 1444740550,1
TIME 0000000c 1444740553,1
TIME 0000000c 1444740554,1
TIME 0000000c 1444740555,1
TIME 0000000c 1444740556,1
TIME 0000000c 1444740560,1
TIME 0000000c 1444740562,1
TIME 0000000c 1444740565,1
TIME 0000000c 1444740566,1
TIME 0000000c 1444740567,1
TIME 0000000c 1444740569,1
TIME 0000000c 1444740570,1
TIME 0000000c 1444740575,1
TIME 0000000c 1444740579,1
TIME 0000000c 1444740580,1
TIME 0000000c 1444740582,1
TIME 0000000c 1444740585,1
TIME 0000000c 1444740588,1
TIME 0000000c 1444740590,1
TIME 0000000c 1444740592,1
TIME 0000000c 1444740593,1
TIME 0000000c 1444740595,1
TIME 0000000c 1444740600,1
TIME 0000000c 1444740601,1
TIME 0000000c 1444740605,1
TIME 0000000c 1444740606,1
TIME 0000000c 1444740608,1
TIME 0000000c 1444740610,1
TIME 0000000c 1444740614,1
TIME 0000000c 1444740615,1
TIME 0000000c 1444740618,1
TIME 0000000c 1444740619,1
TIME 0000000c 1444740620,1
TIME 0000000c 1444740621,1
TIME 0000000c 1444740625,1
TIME 0000000c 1444740627,1
TIME 0000000c 1444740630,1
TIME 0000000c 1444740631,1
TIME 0000000c 1444740632,1
TIME 0000000c 1444740634,1
TIME 0000000c 1444740635,1
TIME 0000000c 1444740640,1
TIME 0000000c 1444740644,1
TIME 0000000c 1444740645,1
TIME 0000000c 1444740647,1
TIME 0000000c 1444740650,1
TIME 0000000c 1444740653,1
TIME 0000000c 1444740655,1
TIME 0000000c 1444740657,1
TIME 0000000c 1444740658,1
TIME 0000000c 1444740660,1
TIME 0000000c 1444740665,1
TIME 0000000c 1444740666,1
TIME 0000000c 1444740670,1
TIME 0000000c 1444740671,1
TIME 0000000c 1444740673,1
TIME 0000000c 1444740675,1
TIME 0000000c 1444740679,1
TIME 0000000c 1444740680,1
TIME 0000000c 1444740683,1
TIME 0000000c 1444740684,1
TIME 0000000c 1444740685,1
TIME 0000000c 1444740686,1
TIME 0000000c 1444740690,1
TIME 0000000c 1444740692,1
TIME 0000000c 1444740695,1
TIME 0000000c 1444740696,1
TIME 0000000c 1444740697,1
TIME 0000000c 1444740699,1
TIME 0000000c 1444740700,1
TIME 0000000c 1444740705,1
TIME 0000000c 1444740709,1
TIME 0000000c 1444740710,1
TIME 0000000c 1444740712,1
TIME 0000000c 1444740715,1
TIME 0000000c 1444740718,1
TIME 0000000c 1444740720,1
TIME 0000000c 1444740722,1
TIME 0000000c 1444740723,1
TIME 0000000c 1444740725,1
TIME 0000000c 1444740730,1
TIME 0000000c 1444740731,1
TIME 0000000c 1444740735,1
TIME 0000000c 1444740736,1
TIME 0000000c 1444740738,1
TIME 0000000c 1444740740,1
TIME 0000000c 1444740744,1
TIME 0000000c 1444740745,1
TIME 0000000c 1444740748,1
TIME 0000000c 1444740749,1
TIME 0000000c 1444740750,1
TIME 0000000c 1444740751,1
TIME 0000000c 1444740755,1
TIME 0000000c 1444740757,1
TIME 0000000c 1444740760,1
TIME 0000000c 1444740761,1
TIME 0000000c 1444740762,1
TIME 0000000c 1444740764,1
TIME 0000000c 1444740765,1
TIME 0000000c 1444740770,1
TIME 0000000c 1444740774,1
TIME 0000000c 1444740775,1
TIME 0000000c 1444740777,1
TIME 0000000c 1444740780,1
TIME 0000000c 1444740783,1
TIME 0000000c 1444740785,1
TIME 0000000c 1444740787,1
TIME 0000000c 1444740788,1
TIME 0000000c 1444740790,1
TIME 0000000c 1444740795,1
TIME 0000000c 1444740796,1
TIME 0000000c 1444740800,1
TIME 0000000c 1444740801,1
TIME 0000000c 1444740803,1
TIME 0000000c 1444740805,1
TIME 0000000c 1444740809,1
TIME 0000000c 1444740810,1
TIME 0000000c 1444740813,1
TIME 0000000c 1444740814,1
TIME 0000000c 1444740815,1
TIME 0000000c 1444740816,1
TIME 0000000c 1444740820,1
TIME 0000000c 1444740822,1
TIME 0000000c 1444740825,1
TIME 0000000c 1444740826,1
TIME 0000000c 1444740827,1
TIME 0000000c 1444740829,1
TIME 0000000c 1444740830,1
TIME 0000000c 1444740835,1
TIME 0000000c 1444740839,1
TIME 0000000c 1444740840,1
TIME 0000000c 1444740842,1
TIME 0000000c 1444740845,1
TIME 0000000c 1444740848,1
TIME 0000000c 1444740850,1
TIME 0000000c 1444740852,1
TIME 0000000c 1444740853,1
TIME 0000000c 1444740855,1
TIME 0000000c 1444740860,1
TIME 0000000c 1444740861,1
TIME 0000000c 1444740865,1
TIME 0000000c 1444740866,1
TIME 0000000c 1444740868,1
TIME 0000000c 1444740870,1
TIME 0000000c 1444740874,1
TIME 0000000c 1444740875,1
TIME 0000000c 1444740878,1
TIME 0000000c 1444740879,1
TIME 0000000c 1444740880,1
TIME 0000000c 1444740881,1
TIME 0000000c 1444740885,1
TIME 0000000c 1444740887,1
TIME 0000000c 1444740890,1
TIME 0000000c 1444740891,1
TIME 0000000c 1444740892,1
TIME 0000000c 1444740894,1
TIME 0000000c 1444740895,1
TIME 0000000c 1444740900,1
TIME 0000000c 1444740904,1
TIME 0000000c 1444740905,1
TIME 0000000c 1444740907,1
TIME 0000000c 1444740910,1
TIME 0000000c 1444740913,1
TIME 0000000c 1444740915,1
TIME 0000000c 1444740917,1
TIME 0000000c 1444740918,1
TIME 0000000c 1444740920,1
TIME 0000000c 1444740925,1
TIME 0000000c 1444740926,1
TIME 0000000c 1444740930,1
TIME 0000000c 1444740931,1
TIME 0000000c 1444740933,1
TIME 0000000c 1444740935,1
TIME 0000000c 1444740939,1
TIME 0000000c 1444740940,1
TIME 0000000c 1444740943,1
TIME 0000000c 1444740944,1
TIME 0000000c 1444740945,1
TIME 0000000c 1444740946,1
TIME 0000000c 1444740950,1
TIME 0000000c 1444740952,1
TIME 0000000c 1444740955,1
TIME 0000000c 1444740956,1
TIME 0000000c 1444740957,1
TIME 0000000c 1444740959,1
TIME 0000000c 1444740960,1
TIME 0000000c 1444740965,1
TIME 0000000c 1444740969,1
TIME 0000000c 1444740970,1
TIME 0000000c 1444740972,1
TIME 0000000c 1444740975,1
TIME 0000000c 1444740978,1
TIME 0000000c 1444740980,1
TIME 0000000c 1444740982,1
TIME 0000000c 1444740983,1
TIME 0000000c 1444740985,1
TIME 0000000c 1444740990,1
TIME 0000000c 1444740991,1
TIME 0000000c 1444740995,1
TIME 0000000c 1444740996,1
TIME 0000000c 1444740998,1
TIME 0000000c 1444741000,1
TIME 0000000c 1444741004,1
TIME 0000000c 1444741005,1
TIME 0000000c 1444741008,1
TIME 0000000c 1444741009,1
TIME 0000000c 1444741010,1
TIME 0000000c 1444741011,1
TIME 0000000c 1444741015,1
TIME 0000000c 1444741017,1
TIME 0000000c 1444741020,1
TIME 0000000c 1444741021,1
TIME 0000000c 1444741022,1
TIME 0000000c 1444741024,1
TIME 0000000c 1444741025,1
TIME 0000000c 1444741030,1
TIME 0000000c 1444741034,1
TIME 0000000c 1444741035,1
TIME 0000000c 1444741037,1
TIME 0000000c 1444741040,1
TIME 0000000c 1444741043,1
TIME 0000000c 1444741045,1
TIME 0000000c 1444741047,1
TIME 0000000c 1444741048,1
TIME 0000000c 1444741050,1
TIME 0000000c 1444741055,1
TIME 0000000c 1444741056,1
TIME 0000000c 1444741060,1
TIME 0000000c 1444741061,1
TIME 0000000c 1444741063,1
TIME 0000000c 1444741065,1
TIME 0000000c 1444741069,1
TIME 0000000c 1444741070,1
TIME 0000000c 1444741073,1
TIME 0000000c 1444741074,1
TIME 0000000c 1444741075,1
TIME 0000000c 1444741076,1
TIME 0000000c 1444741080,1
TIME 0000000c 1444741082,1
TIME 0000000c 1444741085,1
TIME 0000000c 1444741086,1
TIME 0000000c 1444741087,1
TIME 0000000c 1444741089,1
TIME 0000000c 1444741090,1
TIME 0000000c 1444741095,1
TIME 0000000c 1444741099,1
TIME 0000000c 1444741100,1
TIME 0000000c 1444741102,1
TIME 0000000c 1444741105,1
TIME 0000000c 1444741108,1
TIME 0000000c 1444741110,1
TIME 0000000c 1444741112,1
TIME 0000000c 1444741113,1
TIME 0000000c 1444741115,1
TIME 0000000c 1444741120,1
TIME 0000000c 1444741121,1
TIME 0000000c 1444741125,1
TIME 0000000c 1444741126,1
TIME 0000000c 1444741128,1
TIME 0000000c 1444741130,1
TIME 0000000c 1444741134,1
TIME 0000000c 1444741135,1
TIME 0000000c 1444741138,1
TIME 0000000c 1444741139,1
TIME 0000000c 1444741140,1
TIME 0000000c 1444741141,1
TIME 0000000c 1444741145,1
TIME 0000000c 1444741147,1
TIME 0000000c 1444741150,1
TIME 0000000c 1444741151,1
TIME 0000000c 1444741152,1
TIME 0000000c 1444741154,1
TIME 0000000c 1444741155,1
TIME 0000000c 1444741160,1
TIME 0000000c 1444741164,1
TIME 0000000c 1444741165,1
TIME 0000000c 1444741167,1
TIME 0000000c 1444741170,1
TIME 0000000c 1444741173,1
TIME 0000000c 1444741175,1
TIME 0000000c 1444741177,1
TIME 0000000c 1444741178,1
TIME 0000000c 1444741180,1
TIME 0000000c 1444741185,1
TIME 0000000c 1444741186,1
TIME 0000000c 1444741190,1
TIME 0000000c 1444741191,1
TIME 0000000e 1444741191.1,1
TIME 0000000e 1444741191.2,1
TIME 0000000c 1444741193,1
TIME 0000000c 1444741195,1
TIME 0000000c 1444741199,1
TIME 0000000c 1444741200,1
TIME 0000000c 1444741203,1
TIME 0000000c 1444741204,1
TIME 0000000c 1444741205,1
TIME 0000000c 1444741206,1
TIME 0000000c 1444741210,1
TIME 0000000c 1444741212,1
TIME 0000000c 1444741215,1
TIME 0000000c 1444741216,1
TIME 0000000c 1444741217,1
TIME 0000000c 1444741219,1
TIME 0000000c 1444741220,1
TIME 0000000c 1444741225,1
TIME 0000000c 1444741229,1
TIME 0000000c 1444741230,1
TIME 0000000c 1444741232,1
TIME 0000000c 1444741235,1
TIME 0000000c 1444741238,1
TIME 0000000c 1444741240,1
TIME 0000000c 1444741242,1
TIME 0000000c 1444741243,1
TIME 0000000c 1444741245,1
TIME 0000000c 1444741250,1
TIME 0000000c 1444741251,1
TIME 0000000c 1444741255,1
TIME 0000000c 1444741256,1
TIME 0000000c 1444741258,1
TIME 0000000c 1444741260,1
TIME 0000000c 1444741264,1
TIME 0000000c 1444741265,1
TIME 0000000c 1444741268,1
TIME 0000000c 1444741269,1
TIME 0000000c 1444741270,1
TIME 0000000c 1444741271,1
TIME 0000000c 1444741275,1
TIME 0000000c 1444741277,1
TIME 0000000c 1444741280,1
TIME 0000000c 1444741281,1
TIME 0000000c 1444741282,1
TIME 0000000c 1444741284,1
TIME 0000000c 1444741285,1
TIME 0000000c 1444741290,1
TIME 0000000c 1444741294,1
TIME 0000000c 1444741295,1
TIME 0000000c 1444741297,1
TIME 0000000c 1444741300,1
TIME 0000000c 1444741303,1
TIME 0000000c 1444741305,1
TIME 0000000c 1444741307,1
TIME 0000000c 1444741308,1
TIME 0000000c 1444741310,1
TIME 0000000c 1444741315,1
TIME 0000000c 1444741316,1
TIME 0000000c 1444741320,1
TIME 0000000c 1444741321,1
TIME 0000000c 1444741323,1
TIME 0000000c 1444741325,1
TIME 0000000c 1444741329,1
TIME 0000000c 1444741330,1
TIME 0000000c 1444741333,1
TIME 0000000c 1444741334,1
TIME 0000000c 1444741335,1
TIME 0000000c 1444741336,1
TIME 0000000c 1444741340,1
TIME 0000000c 1444741342,1
TIME 0000000c 1444741345,1
TIME 0000000c 1444741346,1
TIME 0000000c 1444741347,1
TIME 0000000c 1444741349,1
TIME 0000000c 1444741350,1
TIME 0000000c 1444741355,1
TIME 0000000c 1444741359,1
TIME 0000000c 1444741360,1
TIME 0000000c 1444741362,1
TIME 0000000c 1444741365,1
TIME 0000000c 1444741368,1
TIME 0000000c 1444741370,1
TIME 0000000c 1444741372,1
TIME 0000000c 1444741373,1
TIME 0000000c 1444741375,1
TIME 0000000c 1444741380,1
TIME 0000000c 1444741381,1
TIME 0000000c 1444741385,1
TIME 0000000c 1444741386,1
TIME 0000000c 1444741388,1
TIME 0000000c 1444741390,1
TIME 0000000c 1444741394,1
TIME 0000000c 1444741395,1
TIME 0000000c 1444741398,1
TIME 0000000c 1444741399,1
TIME 0000000c 1444741400,1
TIME 0000000c 1444741401,1
TIME 0000000c 1444741405,1
TIME 0000000c 1444741407,1
TIME 0000000c 1444741410,1
TIME 0000000c 1444741411,1
TIME 0000000c 1444741412,1
TIME 0000000c 1444741414,1
TIME 0000000c 1444741415,1
TIME 0000000c 1444741420,1
TIME 0000000c 1444741424,1
TIME 0000000c 1444741425,1
TIME 0000000c 1444741427,1
TIME 0000000c 1444741430,1
TIME 0000000c 1444741433,1
TIME 0000000c 1444741435,1
TIME 0000000c 1444741437,1
TIME 0000000c 1444741438,1
TIME 0000000c 1444741440,1
TIME 0000000c 1444741445,1
TIME 0000000c 1444741446,1
TIME 0000000c 1444741450,1
TIME 0000000c 1444741451,1
TIME 0000000c 1444741453,1
TIME 0000000c 1444741455,1
TIME 0000000c 1444741459,1
TIME 0000000c 1444741460,1
TIME 0000000c 1444741463,1
TIME 0000000c 1444741464,1
TIME 0000000c 1444741465,1
TIME 0000000c 1444741466,1
TIME 0000000c 1444741470,1
TIME 0000000c 1444741472,1
TIME 0000000c 1444741475,1
TIME 0000000c 1444741476,1
TIME 0000000c 1444741477,1
TIME 0000000c 1444741479,1
TIME 0000000c 1444741480,1
TIME 0000000c 1444741485,1
TIME 0000000c 1444741489,1
TIME 0000000c 1444741490,1
TIME 0000000c 1444741492,1
TIME 0000000c 1444741495,1
TIME 0000000c 1444741498,1
TIME 0000000c 1444741500,1
TIME 0000000c 1444741502,1
TIME 0000000c 1444741503,1
TIME 0000000c 1444741505,1
TIME 0000000c 1444741510,1
TIME 0000000c 1444741511,1
TIME 0000000c 1444741515,1
TIME 0000000c 1444741516,1
TIME 0000000c 1444741518,1
TIME 0000000c 1444741520,1
TIME 0000000c 1444741524,1
TIME 0000000c 1444741525,1
TIME 0000000c 1444741528,1
TIME 0000000c 1444741529,1
TIME 0000000c 1444741530,1
TIME 0000000c 1444741531,1
TIME 0000000c 1444741535,1
TIME 0000000c 1444741537,1
TIME 0000000c 1444741540,1
TIME 0000000c 1444741541,1
TIME 0000000c 1444741542,1
TIME 0000000c 1444741544,1
TIME 0000000c 1444741545,1
TIME 0000000c 1444741550,1
TIME 0000000c 1444741554,1
TIME 0000000c 1444741555,1
TIME 0000000c 1444741557,1
TIME 0000000c 1444741560,1
TIME 0000000c 1444741563,1
TIME 0000000c 1444741565,1
TIME 0000000c 1444741567,1
TIME 0000000c 1444741568,1
TIME 0000000c 1444741570,1
TIME 0000000c 1444741575,1
TIME 0000000c 1444741576,1
TIME 0000000c 1444741580,1
TIME 0000000c 1444741581,1
TIME 0000000c 1444741583,1
TIME 0000000c 1444741585,1
TIME 0000000c 1444741589,1
TIME 0000000c 1444741590,1
TIME 0000000c 1444741593,1
TIME 0000000c 1444741594,1
TIME 0000000c 1444741595,1
TIME 0000000c 1444741596,1
TIME 0000000c 1444741600,1
TIME 0000000c 1444741602,1
TIME 0000000c 1444741605,1
TIME 0000000c 1444741606,1
TIME 0000000c 1444741607,1
TIME 0000000c 1444741609,1
TIME 0000000c 1444741610,1
TIME 0000000c 1444741615,1
TIME 0000000c 1444741619,1
TIME 0000000c 1444741620,1
TIME 0000000c 1444741622,1
TIME 0000000c 1444741625,1
TIME 0000000c 1444741628,1
TIME 0000000c 1444741630,1
TIME 0000000c 1444741632,1
TIME 0000000c 1444741633,1
TIME 0000000c 1444741635,1
TIME 0000000c 1444741640,1
TIME 0000000c 1444741641,1
TIME 0000000c 1444741645,1
TIME 0000000c 1444741646,1
TIME 0000000c 1444741648,1
TIME 0000000c 1444741650,1
TIME 0000000c 1444741654,1
TIME 0000000c 1444741655,1
TIME 0000000c 1444741658,1
TIME 0000000c 1444741659,1
TIME 0000000c 1444741660,1
TIME 0000000c 1444741661,1
TIME 0000000c 1444741665,1
TIME 0000000c 1444741667,1
TIME 0000000c 1444741670,1
TIME 0000000c 1444741671,1
TIME 0000000c 1444741672,1
TIME 0000000c 1444741674,1
TIME 0000000c 1444741675,1
TIME 0000000c 1444741680,1
TIME 0000000c 1444741684,1
TIME 0000000c 1444741685,1
TIME 0000000c 1444741687,1
TIME 0000000c 1444741690,1
TIME 0000000c 1444741693,1
TIME 0000000c 1444741695,1
TIME 0000000c 1444741697,1
TIME 0000000c 1444741698,1
TIME 0000000c 1444741700,1
TIME 0000000c 1444741705,1
TIME 0000000c 1444741706,1
TIME 0000000c 1444741710,1
TIME 0000000c 1444741711,1
TIME 0000000c 1444741713,1
TIME 0000000c 1444741715,1
TIME 0000000c 1444741719,1
TIME 0000000c 1444741720,1
TIME 0000000c 1444741723,1
TIME 0000000c 1444741724,1
TIME 0000000c 1444741725,1
TIME 0000000c 1444741726,1
TIME 0000000c 1444741730,1
TIME 0000000c 1444741732,1
TIME 0000000c 1444741735,1
TIME 0000000c 1444741736,1
TIME 0000000c 1444741737,1
TIME 0000000c 1444741739,1
TIME 0000000c 1444741740,1
TIME 0000000c 1444741745,1
TIME 0000000c 1444741749,1
TIME 0000000c 1444741750,1
TIME 0000000c 1444741752,1
TIME 0000000c 1444741755,1
TIME 0000000c 1444741758,1
TIME 0000000c 1444741760,1
TIME 0000000c 1444741762,1
TIME 0000000c 1444741763,1
TIME 0000000c 1444741765,1
TIME 0000000c 1444741770,1
TIME 0000000c 1444741771,1
TIME 0000000c 1444741775,1
TIME 0000000c 1444741776,1
TIME 0000000c 1444741778,1
TIME 0000000c 1444741780,1
TIME 0000000c 1444741784,1
TIME 0000000c 1444741785,1
TIME 0000000c 1444741788,1
TIME 0000000c 1444741789,1
TIME 0000000c 1444741790,1
TIME 0000000c 1444741791,1
TIME 0000000c 1444741795,1
TIME 0000000c 1444741797,1
TIME 0000000c 1444741800,1
TIME 0000000c 1444741801,1
TIME 0000000c 1444741802,1
TIME 0000000c 1444741804,1
TIME 0000000c 1444741805,1
TIME 0000000c 1444741810,1
TIME 0000000c 1444741814,1
TIME 0000000c 1444741815,1
TIME 0000000c 1444741817,1
TIME 0000000c 1444741820,1
TIME 0000000c 1444741823,1
TIME 0000000c 1444741825,1
TIME 0000000c 1444741827,1
TIME 0000000c 1444741828,1
TIME 0000000c 1444741830,1
TIME 0000000c 1444741835,1
TIME 0000000c 1444741836,1
TIME 0000000c 1444741840,1
TIME 0000000c 1444741841,1
TIME 0000000c 1444741843,1
TIME 0000000c 1444741845,1
TIME 0000000c 1444741849,1
TIME 0000000c 1444741850,1
TIME 0000000c 1444741853,1
TIME 0000000c 1444741854,1
TIME 0000000c 1444741855,1
TIME 0000000c 1444741856,1
TIME 0000000c 1444741860,1
TIME 0000000c 1444741862,1
TIME 0000000c 1444741865,1
TIME 0000000c 1444741866,1
TIME 0000000c 1444741867,1
TIME 0000000c 1444741869,1
TIME 0000000c 1444741870,1
TIME 0000000c 1444741875,1
TIME 0000000c 1444741879,1
TIME 0000000c 1444741880,1
TIME 0000000c 1444741882,1
TIME 0000000c 1444741885,1
TIME 0000000c 1444741888,1
TIME 0000000c 1444741890,1
TIME 0000000c 1444741892,1
TIME 0000000c 1444741893,1
TIME 0000000c 1444741895,1
TIME 0000000c 1444741900,1
TIME 0000000c 1444741901,1
TIME 0000000c 1444741905,1
TIME 0000000c 1444741906,1
TIME 0000000c 1444741908,1
TIME 0000000c 1444741910,1
TIME 0000000c 1444741914,1
TIME 0000000c 1444741915,1
TIME 0000000c 1444741918,1
TIME 0000000c 1444741919,1
TIME 0000000c 1444741920,1
TIME 0000000c 1444741921,1
TIME 0000000c 1444741925,1
TIME 0000000c 1444741927,1
TIME 0000000c 1444741930,1
TIME 0000000c 1444741931,1
TIME 0000000c 1444741932,1
TIME 0000000c 1444741934,1
TIME 0000000c 1444741935,1
TIME 0000000c 1444741940,1
TIME 0000000c 1444741944,1
TIME 0000000c 1444741945,1
TIME 0000000c 1444741947,1
TIME 0000000c 1444741950,1
TIME 0000000c 1444741953,1
TIME 0000000c 1444741955,1
TIME 0000000c 1444741957,1
TIME 0000000c 1444741958,1
TIME 0000000c 1444741960,1
TIME 0000000c 1444741965,1
TIME 0000000c 1444741966,1
TIME 0000000c 1444741970,1
TIME 0000000c 1444741971,1
TIME 0000000c 1444741973,1
TIME 0000000c 1444741975,1
TIME 0000000c 1444741979,1
TIME 0000000c 1444741980,1
TIME 0000000c 1444741983,1
TIME 0000000c 1444741984,1
TIME 0000000c 1444741985,1
TIME 0000000c 1444741986,1
TIME 0000000c 1444741990,1
TIME 0000000c 1444741992,1
TIME 0000000c 1444741995,1
TIME 0000000c 1444741996,1
TIME 0000000c 1444741997,1
TIME 0000000c 1444741999,1
TIME 0000000c 1444742000,1
TIME 0000000c 1444742005,1
TIME 0000000c 1444742009,1
TIME 0000000c 1444742010,1
TIME 0000000c 1444742012,1
TIME 0000000c 1444742015,1
TIME 0000000c 1444742018,1
TIME 0000000c 1444742020,1
TIME 0000000c 1444742022,1
TIME 0000000c 1444742023,1
TIME 0000000c 1444742025,1
TIME 0000000c 1444742030,1
TIME 0000000c 1444742031,1
TIME 0000000c 1444742035,1
TIME 0000000c 1444742036,1
TIME 0000000c 1444742038,1
TIME 0000000c 1444742040,1
TIME 0000000c 1444742044,1
TIME 0000000c 1444742045,1
TIME 0000000c 1444742048,1
TIME 0000000c 1444742049,1
TIME 0000000c 1444742050,1
TIME 0000000c 1444742051,1
TIME 0000000c 1444742055,1
TIME 0000000c 1444742057,1
TIME 0000000c 1444742060,1
TIME 0000000c 1444742061,1
TIME 0000000c 1444742062,1
TIME 0000000c 1444742064,1
TIME 0000000c 1444742065,1
TIME 0000000c 1444742070,1
TIME 0000000c 1444742074,1
TIME 0000000c 1444742075,1
TIME 0000000c 1444742077,1
TIME 0000000c 1444742080,1
TIME 0000000c 1444742083,1
TIME 0000000c 1444742085,1
TIME 0000000c 1444742087,1
TIME 0000000c 1444742088,1
TIME 0000000c 1444742090,1
TIME 0000000c 1444742095,1
TIME 0000000c 1444742096,1
TIME 0000000c 1444742100,1
TIME 0000000c 1444742101,1
TIME 0000000c 1444742103,1
TIME 0000000c 1444742105,1
TIME 0000000c 1444742109,1
TIME 0000000c 1444742110,1
TIME 0000000c 1444742113,1
TIME 0000000c 1444742114,1
TIME 0000000c 1444742115,1
TIME 0000000c 1444742116,1
TIME 0000000c 1444742120,1
TIME 0000000c 1444742122,1
TIME 0000000c 1444742125,1
TIME 0000000c 1444742126,1
TIME 0000000c 1444742127,1
TIME 0000000c 1444742129,1
TIME 0000000c 1444742130,1
TIME 0000000c 1444742135,1
TIME 0000000c 1444742139,1
TIME 0000000c 1444742140,1
TIME 0000000c 1444742142,1
TIME 0000000c 1444742145,1
TIME 0000000c 1444742148,1
TIME 0000000c 1444742150,1
TIME 0000000c 1444742152,1
TIME 0000000c 1444742153,1
TIME 0000000c 1444742155,1
TIME 0000000c 1444742160,1
TIME 0000000c 1444742161,1
TIME 0000000c 1444742165,1
TIME 0000000c 1444742166,1
TIME 0000000c 1444742168,1
TIME 0000000c 1444742170,1
TIME 0000000c 1444742174,1
TIME 0000000c 1444742175,1
TIME 0000000c 1444742178,1
TIME 0000000c 1444742179,1
TIME 0000000c 1444742180,1
TIME 0000000c 1444742181,1
TIME 0000000c 1444742185,1
TIME 0000000c 1444742187,1
TIME 0000000c 1444742190,1
TIME 0000000c 1444742191,1
TIME 0000000c 1444742192,1
TIME 0000000c 1444742194,1
TIME 0000000c 1444742195,1
TIME 0000000c 1444742200,1
TIME 0000000c 1444742204,1
TIME 0000000c 1444742205,1
TIME 0000000c 1444742207,1
TIME 0000000c 1444742210,1
TIME 0000000c 1444742213,1
TIME 0000000c 1444742215,1
TIME 0000000c 1444742217,1
TIME 0000000c 1444742218,1
TIME 0000000c 1444742220,1
TIME 0000000c 1444742225,1
TIME 0000000c 1444742226,1
TIME 0000000c 1444742230,1
TIME 0000000e 1444742230.1,1
TIME 0000000c 1444742231,1
TIME 0000000c 1444742233,1
TIME 0000000c 1444742235,1
TIME 0000000c 1444742239,1
TIME 0000000c 1444742240,1
TIME 0000000c 1444742243,1
TIME 0000000c 1444742244,1
TIME 0000000c 1444742245,1
TIME 0000000c 1444742246,1
TIME 0000000c 1444742250,1
TIME 0000000c 1444742252,1
TIME 0000000c 1444742255,1
TIME 0000000c 1444742256,1
TIME 0000000c 1444742257,1
TIME 0000000c 1444742259,1
TIME 0000000c 1444742260,1
TIME 0000000c 1444742265,1
TIME 0000000c 1444742269,1
TIME 0000000c 1444742270,1
TIME 0000000c 1444742272,1
TIME 0000000c 1444742275,1
TIME 0000000c 1444742278,1
TIME 0000000c 1444742280,1
TIME 0000000c 1444742282,1
TIME 0000000c 1444742283,1
TIME 0000000c 1444742285,1
TIME 0000000c 1444742290,1
TIME 0000000c 1444742291,1
TIME 0000000c 1444742295,1
TIME 0000000c 1444742296,1
TIME 0000000c 1444742298,1
TIME 0000000c 1444742300,1
TIME 0000000c 1444742304,1
TIME 0000000c 1444742305,1
TIME 0000000c 1444742308,1
TIME 0000000c 1444742309,1
TIME 0000000c 1444742310,1
TIME 0000000c 1444742311,1
TIME 0000000c 1444742315,1
TIME 0000000c 1444742317,1
TIME 0000000c 1444742320,1
TIME 0000000c 1444742321,1
TIME 0000000c 1444742322,1
TIME 0000000c 1444742324,1
TIME 0000000c 1444742325,1
TIME 0000000c 1444742330,1
TIME 0000000c 1444742334,1
TIME 0000000c 1444742335,1
TIME 0000000c 1444742337,1
TIME 0000000c 1444742340,1
TIME 0000000c 1444742343,1
TIME 0000000c 1444742345,1
TIME 0000000c 1444742347,1
TIME 0000000c 1444742348,1
TIME 0000000c 1444742350,1
TIME 0000000c 1444742355,1
TIME 0000000c 1444742356,1
TIME 0000000c 1444742360,1
TIME 0000000c 1444742361,1
TIME 0000000c 1444742363,1
TIME 0000000c 1444742365,1
TIME 0000000c 1444742369,1
TIME 0000000c 1444742370,1
TIME 0000000c 1444742373,1
TIME 0000000c 1444742374,1
TIME 0000000c 1444742375,1
TIME 0000000c 1444742376,1
TIME 0000000c 1444742380,1
TIME 0000000c 1444742382,1
TIME 0000000c 1444742385,1
TIME 0000000c 1444742386,1
TIME 0000000c 1444742387,1
TIME 0000000c 1444742389,1
TIME 0000000c 1444742390,1
TIME 0000000c 1444742395,1
TIME 0000000c 1444742399,1
TIME 0000000c 1444742400,1
TIME 0000000c 1444742402,1
TIME 0000000c 1444742405,1
TIME 0000000c 1444742408,1
TIME 0000000c 1444742410,1
TIME 0000000c 1444742412,1
TIME 0000000c 1444742413,1
TIME 0000000c 1444742415,1
TIME 0000000c 1444742420,1
TIME 0000000c 1444742421,1
TIME 0000000c 1444742425,1
TIME 0000000c 1444742426,1
TIME 0000000c 1444742428,1
TIME 0000000c 1444742430,1
TIME 0000000c 1444742434,1
TIME 0000000c 1444742435,1
TIME 0000000c 1444742438,1
TIME 0000000c 1444742439,1
TIME 0000000c 1444742440,1
TIME 0000000c 1444742441,1
TIME 0000000c 1444742445,1
TIME 0000000c 1444742447,1
TIME 0000000c 1444742450,1
TIME 0000000c 1444742451,1
TIME 0000000c 1444742452,1
TIME 0000000c 1444742454,1
TIME 0000000c 1444742455,1
TIME 0000000c 1444742460,1
TIME 0000000c 1444742464,1
TIME 0000000c 1444742465,1
TIME 0000000c 1444742467,1
TIME 0000000c 1444742470,1
TIME 0000000c 1444742473,1
TIME 0000000c 1444742475,1
TIME 0000000c 1444742477,1
TIME 0000000c 1444742478,1
TIME 0000000c 1444742480,1
TIME 0000000c 1444742485,1
TIME 0000000c 1444742486,1
TIME 0000000c 1444742490,1
TIME 0000000c 1444742491,1
TIME 0000000c 1444742493,1
TIME 0000000c 1444742495,1
TIME 0000000c 1444742499,1
TIME 0000000c 1444742500,1
TIME 0000000c 1444742503,1
TIME 0000000c 1444742504,1
TIME 0000000c 1444742505,1
TIME 0000000c 1444742506,1
TIME 0000000c 1444742510,1
TIME 0000000c 1444742512,1
TIME 0000000c 1444742515,1
TIME 0000000c 1444742516,1
TIME 0000000c 1444742517,1
TIME 0000000c 1444742519,1
TIME 0000000c 1444742520,1
TIME 0000000c 1444742525,1
TIME 0000000c 1444742529,1
TIME 0000000c 1444742530,1
TIME 0000000c 1444742532,1
TIME 0000000c 1444742535,1
TIME 0000000c 1444742538,1
TIME 0000000c 1444742540,1
TIME 0000000c 1444742542,1
TIME 0000000c 1444742543,1
TIME 0000000c 1444742545,1
TIME 0000000c 1444742550,1
TIME 0000000c 1444742551,1
TIME 0000000c 1444742555,1
TIME 0000000c 1444742556,1
TIME 0000000c 1444742558,1
TIME 0000000c 1444742560,1
TIME 0000000c 1444742564,1
TIME 0000000c 1444742565,1
TIME 0000000c 1444742568,1
TIME 0000000c 1444742569,1
TIME 0000000c 1444742570,1
TIME 0000000c 1444742571,1
TIME 0000000c 1444742575,1
TIME 0000000c 1444742577,1
TIME 0000000c 1444742580,1
TIME 0000000c 1444742581,1
TIME 0000000c 1444742582,1
TIME 0000000c 1444742584,1
TIME 0000000c 1444742585,1
TIME 0000000c 1444742590,1
TIME 0000000c 1444742594,1
TIME 0000000c 1444742595,1
TIME 0000000c 1444742597,1
TIME 0000000c 1444742600,1
TIME 0000000c 1444742603,1
TIME 0000000c 1444742605,1
TIME 0000000c 1444742607,1
TIME 0000000c 1444742608,1
TIME 0000000c 1444742610,1
TIME 0000000c 1444742615,1
TIME 0000000c 1444742616,1
TIME 0000000c 1444742620,1
TIME 0000000c 1444742621,1
TIME 0000000c 1444742623,1
TIME 0000000c 1444742625,1
TIME 0000000c 1444742629,1
TIME 0000000c 1444742630,1
TIME 0000000c 1444742633,1
TIME 0000000c 1444742634,1
TIME 0000000c 1444742635,1
TIME 0000000c 1444742636,1
TIME 0000000c 1444742640,1
TIME 0000000c 1444742642,1
TIME 0000000c 1444742645,1
TIME 0000000c 1444742646,1
TIME 0000000c 1444742647,1
TIME 0000000c 1444742649,1
TIME 0000000c 1444742650,1
TIME 0000000c 1444742655,1
TIME 0000000c 1444742659,1
TIME 0000000c 1444742660,1
TIME 0000000c 1444742662,1
TIME 0000000c 1444742665,1
TIME 0000000c 1444742668,1
TIME 0000000c 1444742670,1
TIME 0000000c 1444742672,1
TIME 0000000c 1444742673,1
TIME 0000000c 1444742675,1
TIME 0000000c 1444742680,1
TIME 0000000c 1444742681,1
TIME 0000000c 1444742685,1
TIME 0000000c 1444742686,1
TIME 0000000c 1444742688,1
TIME 0000000c 1444742690,1
TIME 0000000c 1444742694,1
TIME 0000000c 1444742695,1
TIME 0000000c 1444742698,1
TIME 0000000c 1444742699,1
TIME 0000000c 1444742700,1
TIME 0000000c 1444742701,1
TIME 0000000c 1444742705,1
TIME 0000000c 1444742707,1
TIME 0000000c 1444742710,1
TIME 0000000c 1444742711,1
TIME 0000000c 1444742712,1
TIME 0000000c 1444742714,1
TIME 0000000c 1444742715,1
TIME 0000000c 1444742720,1
TIME 0000000c 1444742724,1
TIME 0000000c 1444742725,1
TIME 0000000c 1444742727,1
TIME 0000000c 1444742730,1
TIME 0000000c 1444742733,1
TIME 0000000c 1444742735,1
TIME 0000000c 1444742737,1
TIME 0000000c 1444742738,1
TIME 0000000c 1444742740,1
TIME 0000000c 1444742745,1
TIME 0000000c 1444742746,1
TIME 0000000c 1444742750,1
TIME 0000000c 1444742751,1
TIME 0000000c 1444742753,1
TIME 0000000c 1444742755,1
TIME 0000000c 1444742759,1
TIME 0000000c 1444742760,1
TIME 0000000c 1444742763,1
TIME 0000000c 1444742764,1
TIME 0000000c 1444742765,1
TIME 0000000c 1444742766,1
TIME 0000000c 1444742770,1
TIME 0000000c 1444742772,1
TIME 0000000c 1444742775,1
TIME 0000000c 1444742776,1
TIME 0000000c 1444742777,1
TIME 0000000c 1444742779,1
TIME 0000000c 1444742780,1
TIME 0000000c 1444742785,1
TIME 0000000c 1444742789,1
TIME 0000000c 1444742790,1
TIME 0000000c 1444742792,1
TIME 0000000c 1444742795,1
TIME 0000000c 1444742798,1
TIME 0000000c 1444742800,1
TIME 0000000c 1444742802,1
TIME 0000000c 1444742803,1
TIME 0000000c 1444742805,1
TIME 0000000c 1444742810,1
TIME 0000000c 1444742811,1
TIME 0000000c 1444742815,1
TIME 0000000c 1444742816,1
TIME 0000000c 1444742818,1
TIME 0000000c 1444742820,1
TIME 0000000c 1444742824,1
TIME 0000000c 1444742825,1
TIME 0000000c 1444742828,1
TIME 0000000c 1444742829,1
TIME 0000000c 1444742830,1
TIME 0000000c 1444742831,1
TIME 0000000c 1444742835,1
TIME 0000000c 1444742837,1
TIME 0000000c 1444742840,1
TIME 0000000c 1444742841,1
TIME 0000000c 1444742842,1
TIME 0000000c 1444742844,1
TIME 0000000c 1444742845,1
TIME 0000000c 1444742850,1
TIME 0000000c 1444742854,1
TIME 0000000c 1444742855,1
TIME 0000000c 1444742857,1
TIME 0000000c 1444742860,1
TIME 0000000c 1444742863,1
TIME 0000000c 1444742865,1
TIME 0000000c 1444742867,1
TIME 0000000c 1444742868,1
TIME 0000000c 1444742870,1
TIME 0000000c 1444742875,1
TIME 0000000c 1444742876,1
TIME 0000000c 1444742880,1
TIME 0000000c 1444742881,1
TIME 0000000c 1444742883,1
TIME 0000000c 1444742885,1
TIME 0000000c 1444742889,1
TIME 0000000c 1444742890,1
TIME 0000000c 1444742893,1
TIME 0000000c 1444742894,1
TIME 0000000c 1444742895,1
TIME 0000000c 1444742896,1
TIME 0000000c 1444742900,1
TIME 0000000c 1444742902,1
TIME 0000000c 1444742905,1
TIME 0000000c 1444742906,1
TIME 0000000c 1444742907,1
TIME 0000000c 1444742909,1
TIME 0000000c 1444742910,1
TIME 0000000c 1444742915,1
TIME 0000000c 1444742919,1
TIME 0000000c 1444742920,1
TIME 0000000c 1444742922,1
TIME 0000000c 1444742925,1
TIME 0000000c 1444742928,1
TIME 0000000c 1444742930,1
TIME 0000000c 1444742932,1
TIME 0000000c 1444742933,1
TIME 0000000c 1444742935,1
TIME 0000000c 1444742940,1
TIME 0000000c 1444742941,1
TIME 0000000c 1444742945,1
TIME 0000000c 1444742946,1
TIME 0000000c 1444742948,1
TIME 0000000c 1444742950,1
TIME 0000000c 1444742954,1
TIME 0000000c 1444742955,1
TIME 0000000c 1444742958,1
TIME 0000000c 1444742959,1
TIME 0000000c 1444742960,1
TIME 0000000c 1444742961,1
TIME 0000000c 1444742965,1
TIME 0000000c 1444742967,1
TIME 0000000c 1444742970,1
TIME 0000000c 1444742971,1
TIME 0000000c 1444742972,1
TIME 0000000c 1444742974,1
TIME 0000000c 1444742975,1
TIME 0000000c 1444742980,1
TIME 0000000c 1444742984,1
TIME 0000000c 1444742985,1
TIME 0000000c 1444742987,1
TIME 0000000c 1444742990,1
TIME 0000000c 1444742993,1
TIME 0000000c 1444742995,1
TIME 0000000c 1444742997,1
TIME 0000000c 1444742998,1
TIME 0000000c 1444743000,1
TIME 0000000c 1444743005,1
TIME 0000000c 1444743006,1
TIME 0000000c 1444743010,1
TIME 0000000c 1444743011,1
TIME 0000000c 1444743013,1
TIME 0000000c 1444743015,1
TIME 0000000c 1444743019,1
TIME 0000000c 1444743020,1
TIME 0000000c 1444743023,1
TIME 0000000c 1444743024,1
TIME 0000000c 1444743025,1
TIME 0000000c 1444743026,1
TIME 0000000c 1444743030,1
TIME 0000000c 1444743032,1
TIME 0000000c 1444743035,1
TIME 0000000c 1444743036,1
TIME 0000000c 1444743037,1
TIME 0000000c 1444743039,1
TIME 0000000c 1444743040,1
TIME 0000000c 1444743045,1
TIME 0000000c 1444743049,1
TIME 0000000c 1444743050,1
TIME 0000000c 1444743052,1
TIME 0000000c 1444743055,1
TIME 0000000c 1444743058,1
TIME 0000000c 1444743060,1
TIME 0000000c 1444743062,1
TIME 0000000c 1444743063,1
TIME 0000000c 1444743065,1
TIME 0000000c 1444743070,1
TIME 0000000c 1444743071,1
TIME 0000000e 1444743073.1,1
DISC 0000003c 6795184426424404343:7002720270484310391 from 127.0.0.1:59295
DISC 00000027 6205108723613202185:3955614762 from R01
DISC 00000036 6205108723613202185:3482309487 from internal:R:control
DISC 00000027 6205108723613202185:1865318693 from S01
