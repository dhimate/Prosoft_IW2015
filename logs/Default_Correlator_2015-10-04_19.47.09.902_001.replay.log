VERS 00000001 4
HEAD 00000e07 <?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="/resources/transform.xslt"?><header><componentName>correlator</componentName><version>5.1.0.0</version><build>rel/5.1.0.x@217480</build><buildPlatform>amd64-win64-msvc9</buildPlatform><platform>Windows Server 2008 R2 (Service Pack 1)</platform><cputype>AuthenticAMD family 15 model 8 stepping 0 Six-Core AMD Opteron(tm) Processor 2427</cputype><cpus>4</cpus><javaEnabled>true</javaEnabled><replayLogMode>replayLog</replayLogMode><args><arg>C:\SoftwareAG\Apama 5.1\bin\correlator.exe</arg><arg>--logQueueSizePeriod</arg><arg>0</arg><arg>--port</arg><arg>15903</arg><arg>--loglevel</arg><arg>INFO</arg><arg>--name</arg><arg>Apama Studio Correlator for Prosoft_IW2015(Prosoft_IW2015:Default Correlator)</arg><arg>-j</arg><arg>--jmsConfig</arg><arg>C:\SoftwareAG\ApamaWork_5.1\studio_workspace\.metadata\.plugins\org.eclipse.core.resources\.projects\Prosoft_IW2015\com.apama.text\JMS_Correlator-Integrated_Adapter</arg><arg>--replayLog</arg><arg>logs/Default_Correlator_${START_TIME}_${ID}.replay.log</arg></args><environment><variable>ALLUSERSPROFILE=C:\ProgramData</variable><variable>APAMA_HOME=C:\SoftwareAG\Apama 5.1</variable><variable>APAMA_WORK=C:\SoftwareAG\ApamaWork_5.1</variable><variable>APPDATA=C:\Users\ydhimate\AppData\Roaming</variable><variable>COMMONPROGRAMFILES=C:\Program Files\Common Files</variable><variable>COMMONPROGRAMFILES(X86)=C:\Program Files (x86)\Common Files</variable><variable>COMMONPROGRAMW6432=C:\Program Files\Common Files</variable><variable>COMPUTERNAME=WMSERVER11</variable><variable>COMSPEC=C:\Windows\system32\cmd.exe</variable><variable>FP_NO_HOST_CHECK=NO</variable><variable>HOMEDRIVE=C:</variable><variable>HOMEPATH=\Users\ydhimate</variable><variable>LOCALAPPDATA=C:\Users\ydhimate\AppData\Local</variable><variable>LOGONSERVER=\\JUPITOR</variable><variable>NUMBER_OF_PROCESSORS=4</variable><variable>OS=Windows_NT</variable><variable>PATH=C:\SoftwareAG\Apama 5.1\third_party\jre\bin\server;C:\SoftwareAG\Apama 5.1\third_party\jre\bin;C:\SoftwareAG\Apama 5.1\third_party\jre\lib\amd64\server;C:\SoftwareAG\Apama 5.1\third_party\jre\lib\amd64;C:\SoftwareAG\Apama 5.1\bin;C:\ProgramData\Oracle\Java\javapath;C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\</variable><variable>PATHEXT=.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC</variable><variable>PROCESSOR_ARCHITECTURE=AMD64</variable><variable>PROCESSOR_IDENTIFIER=AMD64 Family 16 Model 8 Stepping 0, AuthenticAMD</variable><variable>PROCESSOR_LEVEL=16</variable><variable>PROCESSOR_REVISION=0800</variable><variable>PROGRAMDATA=C:\ProgramData</variable><variable>PROGRAMFILES=C:\Program Files</variable><variable>PROGRAMFILES(X86)=C:\Program Files (x86)</variable><variable>PROGRAMW6432=C:\Program Files</variable><variable>PROMPT=$P$G</variable><variable>PSMODULEPATH=C:\Windows\system32\WindowsPowerShell\v1.0\Modules\</variable><variable>PUBLIC=C:\Users\Public</variable><variable>SYSTEMDRIVE=C:</variable><variable>SYSTEMROOT=C:\Windows</variable><variable>TEMP=C:\Users\ydhimate\AppData\Local\Temp</variable><variable>TMP=C:\Users\ydhimate\AppData\Local\Temp</variable><variable>USERDNSDOMAIN=PROSOFTHQ.COM</variable><variable>USERDOMAIN=PROSOFTHQ</variable><variable>USERNAME=ydhimate</variable><variable>USERPROFILE=C:\Users\ydhimate</variable><variable>WINDIR=C:\Windows</variable><variable>WINDOWS_TRACING_FLAGS=3</variable><variable>WINDOWS_TRACING_LOGFILE=C:\BVTBin\Tests\installpackage\csilogfile.log</variable></environment><version>5.1.0.0</version></header>
RAND 00000009 897017564
CONN 00000027 6201958683091171081/3955614762 from R01
CONN 00000036 6201958683091171081/3482309487 from internal:R:control
CONN 00000027 6201958683091171081/1865318693 from S01
TIME 00000010 1444006032.138,1
CONN 0000003c 1829400198888423424/1829400198888423424 from 127.0.0.1:62325
TIME 0000000e 1444006032.2,1
MONF 00000f0b //*****************************************************************************
// Title:         DashboardSupport.mon
// Description:   Monitor defining events to be sent when a client connects
//                or disconnects from a dashboard.  The monitor also provides
//                multi-context support for the connect/disconnect events.
// Dependencies:  None
// $Copyright(c) 2010 Progress Software Corporation (PSC). All rights reserved.$
// $Copyright (c) 2013 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or Terracotta Inc., San Francisco, CA, USA, and/or Software AG (Canada) Inc., Cambridge, Ontario, Canada, and/or, Software AG (UK) Ltd., Derby, United Kingdom, and/or Software A.G. (Israel) Ltd., Or-Yehuda, Israel and/or their licensors.$
// Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG
//
//*****************************************************************************

package com.apama.dashboard;


event DashboardClientConnected {
	string userName;
	string sessionId;
	dictionary<string,string> extraParams;
}

event DashboardClientDisconnected {
	string userName;
	string sessionId;
	dictionary<string,string> extraParams;
}

// Events to support parallel execution (contexts)

event RegisterContextForDashboardClientConnections {
	context instanceContext;
}

event DeregisterContextForDashboardClientConnections {
	context instanceContext;
}


/**
 * This monitor provides the context forwarders needed to allow
 * the Dashboard connect and disconnect notification events to be sent to
 * the registered contexts.
 * The notifications are always sent to the main context.
 */
monitor DashboardSupport
{
	// Used to persist contexts interested in notifications
	sequence < context > notifyContexts;

	action onload {
		
		log "Loaded Dashboard Client Connect Notification service" at INFO;
		
		// Forwarders to support parallel execution (contexts)
		setupContextForwarders();
		
	}
	
	action setupContextForwarders()
	{

		DashboardClientConnected connect;
		on all DashboardClientConnected(): connect {
			log "Dashboard Client Connected - User:" + connect.userName +
				"  Session:" + connect.sessionId at DEBUG;
			if notifyContexts.size() > 0 then {
				context ctx;
				for ctx in notifyContexts {
					enqueue connect to ctx;
				}
			}
		}

		DashboardClientDisconnected disconnect;
		on all DashboardClientDisconnected(): disconnect {
			log "Dashboard Client Disconnected - User:" + disconnect.userName +
				"  Session:" + disconnect.sessionId at DEBUG;
			if notifyContexts.size() > 0 then {
				context ctx;
				for ctx in notifyContexts {
					enqueue disconnect to ctx;
				}
			}
		}
		
		RegisterContextForDashboardClientConnections regCtx;
		on all RegisterContextForDashboardClientConnections():regCtx registerCtx(regCtx.instanceContext);
	
		DeregisterContextForDashboardClientConnections deregCtx;
		on all DeregisterContextForDashboardClientConnections():deregCtx deregisterCtx(deregCtx.instanceContext);
	}
	
	action registerCtx(context ctx)
	{		
		notifyContexts.append(ctx);
	}

	action deregisterCtx(context ctx)
	{
		if notifyContexts.size() > 0 then {
			integer ctxId := notifyContexts.indexOf(ctx);
			if ctxId >= 0 then {
				notifyContexts.remove(ctxId);
			}
		}
	}

	action ondie() {
		if (notifyContexts.size() != 0) then {
			log "ondie: Dashboard Support service is terminating but there may still be contexts subscribed to dashboard connect events" at ERROR;
		}
		else {
			log "ondie: Dashboard Support service is terminating" at INFO;
		}
	}

	action onunload {
		log "Unloaded Dashboard Support service" at INFO;
	}


}
 00000035 C:\SoftwareAG\Apama 5.1\monitors\DashboardSupport.mon
RMDT 00000015 &INPUT(1,5,true,true)
MONF 000048c2 package com.apama.dataview;

/*
 * $Copyright(c) 2007, 2008 Progress Software Corporation (PSC). All rights reserved.$
 * $Copyright (c) 2013 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or Terracotta Inc., San Francisco, CA, USA, and/or Software AG (Canada) Inc., Cambridge, Ontario, Canada, and/or, Software AG (UK) Ltd., Derby, United Kingdom, and/or Software A.G. (Israel) Ltd., Or-Yehuda, Israel and/or their licensors.$
 * Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG
 */


/* This is the definition the Apama DataViewService API.
 *
 * Several implementations of this interface will exist. 
 * Each implementation is in a separate file - inject the one you wish to use.
 *   e.g. DataViewService_Impl_Dict.mon
 * 
 * This service enables MonitorScript or JMon applications to expose a simple 
 * read-only "DataView" interface. DataViews may be viewed using Apama Dashboard 
 * Studio in a similar way to Scenarios.
 *
 * Route vs. Emit
 * The standard implementations of the DataViewService will always ROUTE 
 * any com.apama.dataview.* events, with the expectation that applications
 * using the service are co-located in the same correlator as the service.
 * If your architecture requires the client application to be in a separate 
 * correlator to the DataView service, then two "emitter" monitors are 
 * available.
 * DataViewService_ServiceEmitter.mon  would be injected into the same 
 * correlator as the DataView service after injecting the DataViewService 
 * interface but before injecting the implementation.
 * DataViewService_ApplicationEmitter.mon  would be injected into the same 
 * correlator as the client application after injecting the DataViewService 
 * interface but before injecting the client application.
 * 
 *
 * Notes:
 * 
 * 1) Every event has an initial field called msgId. Clients may choose to put 
 *    some identifier in this field when sending messages to the service. Any 
 *    event routed by the service in response will contain the same identifier.
 *
 * 2) Most events contain a field called "dvName". This string 
 *    uniquely identifies a DataView inside the correlator. 
 *
 * 3) Every event has a final field called extraParams that is a string:string
 *    dictionary. Some implementations may choose to use this field. It provides
 *    a way of future-proofing the interface to a certain extent.
 *
 * $Revision: 215887 $
 */





/* ==========================================================================
 * ==========================================================================
 * Events to send to the DataViewService to manage the DataView schemas
 * ==========================================================================
 * ========================================================================== */


/* Define a new DataView type.
 * Expect either a DataViewDefinition or a DataViewException in response.
 *
 * See also: DataViewDefinition() DataViewException(), DataViewAddItem()
 *
 * Direction: From the customer Monitor to the DataViewService.
 */
event DataViewAddDefinition {
	string msgId;                   // [OPTIONAL] A messageId that applications may choose to use to identify "responses".
	string dvName;			        // The DataView Name (e.g. conventionally DataView_XXX)
	string dvDisplayName;		    // The display name of the DataView (e.g. "XXX manager")
	string dvDescription;		    // A description of the DataView (e.g. "This DataView exposes XXX objects")
	sequence<string> fieldNames;	// Names of any fields
	sequence<string> fieldTypes;	// One of: string, float, integer, boolean, enumeration (must match values in oNames)
	sequence<string> keyFields;     // [OPTIONAL] Names of field(s) whose values in an Item are to be combined to 
	                                //     make a unique key that may be used instead of a dvItemId
	
	dictionary<string, string> extraParams;  // [OPTIONAL] Some implementations may choose to make use of this field.
}


/* Remove an existing DataView type.
 *
 * Direction: From the customer Monitor to the DataViewService.
 *
 * Response: DataViewUnloaded()
 */
event DataViewDeleteDefinition {
	string msgId;                            // [OPTIONAL] A messageId that applications may choose to use to identify "responses".
	string dvName;                           // The DataView Name (e.g. conventionally DataView_XXX)
	dictionary<string, string> extraParams;  // [OPTIONAL] Some implementations may choose to make use of this field.
}


/* Request helper dictionary to facilitate sequence position lookup
 *    by field name.
 *
 * See also: DataViewFieldLookup()
 *
 * Direction: From the customer Monitor to the DataViewService.
 *
 * Response: DataViewFieldLookup()
 */
event DataViewGetFieldLookup {
	string msgId;                            // [OPTIONAL] A messageId that applications may choose to use to identify "responses".
	string dvName;                           // The DataView Name (e.g. conventionally DataView_XXX)
	dictionary<string, string> extraParams;  // [OPTIONAL] Some implementations may choose to make use of this field.
}



/* ==========================================================================
 * ==========================================================================
 * Events to send to the DataViewService to manage individual DataView Items
 * ==========================================================================
 * ========================================================================== */


/* Request that a new Item is added to a specific DataView.
*
* See also: DataViewItem()
*
* Direction: From the customer Monitor to the DataViewService.
*/
event DataViewAddItem {
	string msgId;                            // [OPTIONAL] A messageId that applications may choose to use to identify "responses".
	string dvName;                           // the unique name of the DataView
	string owner;                            // the owner (user) of the Item.
	float timeStamp;                         // the timestamp of the initial update (seconds since epoch). If the value given is -1.0 then the service will populate it using correlator currentTime.
	sequence<string> fieldValues;            // complete sequence of field values in string form
	dictionary<string, string> extraParams;  // [OPTIONAL] Some implementations may choose to make use of this field.
}


/* Request that a new Item is added to a specific DataView if it does not already exist, 
* or is updated when it does exist. This will ONLY work when keyFields are used.
* Attempts to change the owner of an existing item will be rejected with a DataViewItemException.
*
* See also: DataViewItem()
*
* Direction: From the customer Monitor to the DataViewService.
*/
event DataViewAddOrUpdateItem {
	string msgId;                            // [OPTIONAL] A messageId that applications may choose to use to identify "responses".
	string dvName;                           // the unique name of the DataView
	string owner;                            // the owner (user) of the Item - ONLY used for new items.
	float timeStamp;                         // the timestamp of the initial update (seconds since epoch). If the value given is -1.0 then the service will populate it using correlator currentTime.
	sequence<string> fieldValues;            // complete sequence of field values in string form
	dictionary<string, string> extraParams;  // [OPTIONAL] Some implementations may choose to make use of this field.
}


/* Contains updated DataView Item fields.
 * Use this to update the fields.
 *
 * Direction: From the customer Monitor to the DataViewService.
 *
 */
event DataViewUpdateItem { 
	string msgId;                            // [OPTIONAL] A messageId that applications may choose to use to identify "responses".
	string dvName;                           // the unique name of the DataView
	integer dvItemId;                        // the ID of the Item within the DataView (may be -1 if using keyFields instead)
	float timeStamp;                         // the timestamp of the update (seconds since epoch). If the value given is -1.0 then the service will populate it using correlator currentTime.
	sequence<string> fieldValues;            // sequence of field values in string form
	dictionary<string, string> extraParams;  // [OPTIONAL] Some implementations may choose to make use of this field.
}


/* Contains updated DataView Item fields.
 * Use this to update the fields.
 *
 * Direction: From the customer Monitor to the DataViewService.
 *
 */
event DataViewUpdateItemDelta { 
	string msgId;                            // [OPTIONAL] A messageId that applications may choose to use to identify "responses".
	string dvName;                           // the unique name of the DataView
	integer dvItemId;                        // the ID of the Item within the DataView (may be -1 if using keyFields instead)
	float timeStamp;                         // the timestamp of the update (seconds since epoch). If the value given is -1.0 then the service will populate it using correlator currentTime.
	dictionary<integer,string> fieldValues;  // values to be updated. Dictionary Key is index into fields sequence, Value is new field value in sequence. 
	                                         // If not using dvItemId, then the dictionary MUST contain the key values (even though they have not changed)
	dictionary<string, string> extraParams;  // [OPTIONAL] Some implementations may choose to make use of this field.
}


/* Request that a specific Item within a specific DataView is deleted.
 *
 * See also: DataViewItemDeleted()
 *
 * Direction: From the customer Monitor to the DataViewService.
 */
event DataViewDeleteItem {
	string msgId;                            // [OPTIONAL] A messageId that applications may choose to use to identify "responses".
	string dvName;                           // the unique name of the DataView
	integer dvItemId;                        // the ID of the Item within the DataView (may be -1 if using keyFields instead)
	sequence<string> keyFields;              // [OPTIONAL] sequence of ONLY key field values (if not using the dvItemId)
	dictionary<string, string> extraParams;  // [OPTIONAL] Some implementations may choose to make use of this field.
}


/* Request that all Items within a specific DataView are deleted.
 *
 * See also: DataViewAllItemsDeleted()
 *
 * Direction: From the customer Monitor to the DataViewService.
 */
event DataViewDeleteAllItems {
	string msgId;                            // [OPTIONAL] A messageId that applications may choose to use to identify "responses".
	string dvName;                           // the unique name of the DataView
	dictionary<string, string> extraParams;  // [OPTIONAL] Some implementations may choose to make use of this field.
}


/* ==========================================================================
 * ==========================================================================
 * Events to that are callbacks from DatavViewService
 * ==========================================================================
 * ========================================================================== */


/** Confirmation that a specific DataView definition has been added.
 *
 * See also: DataViewAddDefinition()
 *
 * Direction: From the DataViewService to the customer Monitor.
 */
event DataViewDefinition {
	string msgId;                            // [OPTIONAL] A messageId that applications may choose to use to identify "responses".
	string dvName;                           // the unique name of the DataView
	string dvDisplayName;		             // The display name of the DataView (e.g. "XXX manager")
	string dvDescription;		             // A description of the DataView (e.g. "This DataView exposes XXX objects")
	sequence<string> fieldNames;	         // Names of any fields
	sequence<string> fieldTypes;             // One of: string, float, integer, boolean, enumeration (must match values in oNames)
	sequence<string> keyFields;              // [OPTIONAL] Names of field(s) whose values in an Item are to be combined to 
	                                         //     make a unique key that may be used instead of a dvItemId
	dictionary<string, string> extraParams;  // [OPTIONAL] Some implementations may choose to make use of this field.
}


/* Indicates that a specific DataView definition is being unloaded.
 *
 * Direction: From the DataViewService to the customer Monitor.
 */
event DataViewDefinitionDeleted { 
	string msgId;                            // [OPTIONAL] A messageId that applications may choose to use to identify "responses".
	string dvName;                           // the unique name of the DataView
	dictionary<string, string> extraParams;  // [OPTIONAL] Some implementations may choose to make use of this field.
}


/* Notifies all interested clients that a new Item has been added to a specific 
 * DataView. 
 * The event provides the unique itemID, owner (user), and initial values for 
 * all fields.
 *
 * See also: DataViewAddItem()
 *
 * Direction: From the DataViewService to the customer Monitor.
 *
 */
event DataViewItem { 
	string msgId;                            // [OPTIONAL] A messageId that applications may choose to use to identify "responses".
	string dvName;                           // the unique name of the DataView
	integer dvItemId;                        // the ID of the Item within the DataView
	string owner;                            // the owner (user) of the Item.
	sequence<string> fieldValues;            // sequence of field values in string form
	dictionary<string, string> extraParams;  // [OPTIONAL] Some implementations may choose to make use of this field.
}


/* Notifies all interested clients that a specific Item within a specific 
 * DataView has been deleted.
 *
 * See also: DataViewDeleteItem()
 *
 * Direction: From the DataViewService to the customer Monitor.
 *
 */
event DataViewItemDeleted {
	string msgId;                            // [OPTIONAL] A messageId that applications may choose to use to identify "responses".
	string dvName;                           // the unique name of the DataView
	integer dvItemId;                        // the ID of the Item within the DataView
	sequence<string> keyFields;              // sequence of ONLY key field values (for those not using the dvItemId)
	dictionary<string, string> extraParams;  // [OPTIONAL] Some implementations may choose to make use of this field.
}


/* Notifies all interested clients that all Items within a specific 
 * DataView have been deleted.
 *
 * See also: DataViewDeleteAllItems()
 *
 * Direction: From the DataViewService to the customer Monitor.
 *
 */
event DataViewAllItemsDeleted {
	string msgId;                            // [OPTIONAL] A messageId that applications may choose to use to identify "responses".
	string dvName;                           // the unique name of the DataView
	dictionary<string, string> extraParams;  // [OPTIONAL] Some implementations may choose to make use of this field.
}


/* The helper dictionary to facilitate sequence position lookup
 *    by field name.
 *
 * See also: DataViewGetFieldLookup()
 *
 * Direction: From the DataViewService to the customer Monitor.
 */
event DataViewFieldLookup {
	string msgId;                            // [OPTIONAL] A messageId that applications may choose to use to identify "responses".
	string dvName;                           // The DataView Name (e.g. conventionally DataView_XXX)
	dictionary <string, integer> fields;     // A map of fieldName:fieldIndex
	dictionary<string, string> extraParams;  // [OPTIONAL] Some implementations may choose to make use of this field.
}


/* Indicates that an exception occurred within the DataViewService, and indicates 
* the name of the specific DataView.
*
* Direction: From the DataViewService to the customer Monitor.
*/
event DataViewException {
	string msgId;                            // [OPTIONAL] A messageId that applications may choose to use to identify "responses".
	string dvName;                           // the unique name of the DataView
	wildcard string message;                 // The message in the exception. This is designed to be human readable, and may change between implementations/versions, hence the wildcard.
	dictionary<string, string> extraParams;  // [OPTIONAL] Some implementations may choose to make use of this field.
}

/* Indicates that an exception occurred within the DataViewService, and indicates 
* the name of the specific DataView, and the Id of the specific Item.
*
* Direction: From the DataViewService to the customer Monitor.
*/
event DataViewItemException {
	string msgId;                            // [OPTIONAL] A messageId that applications may choose to use to identify "responses".
	string dvName;                           // the unique name of the DataView
	integer dvItemId;                        // the ID of the Item within the DataView
	wildcard string message;                 // The message in the exception. This is designed to be human readable, and may change between implementations/versions, hence the wildcard.
	dictionary<string, string> extraParams;  // [OPTIONAL] Some implementations may choose to make use of this field.
}


/* Indicates that the DataView service is being unloaded.
 *
 * Direction: From the DataViewService to the customer Monitor.
 */
event DataViewServiceUnloaded { 
	dictionary<string, string> extraParams;  // [OPTIONAL] Some implementations may choose to make use of this field.
}


monitor DataViewService_Interface {
	// MetaData relating to the interface
	dictionary<string,string> interfaceMetaData := {
		"interface.package"     :"com.apama.dataview",
		"interface.name"        :"DataViewService_Interface",
		"interface.fileName"    :"DataViewService_Interface.mon",
		"interface.vendor"      :"Apama",
		"interface.version"     :"5.1.0.0",
		"interface.fullVersion" :"rel/5.1.0.x@217480",
		"interface.language"    :"MonitorScript"
	};

	action onload {
		log "DataViewService interface loaded. MetaData: "+interfaceMetaData.toString() at INFO;
	}
}

 0000003e C:\SoftwareAG\Apama 5.1\monitors\DataViewService_Interface.mon
RMDT 00000016 &INPUT(1,19,true,true)
TIME 0000000e 1444006032.3,1
MONF 00012470 package com.apama.scenario;

/**
 * This file contains the shared event definitions that are generic across 
 * all Scenarios.  
 *
 * WARNING: 
 *    The event definitions contained in this file form an internal protocol 
 *    and may change between software releases.
 *
 * Notes:
 * 1) The Event definitions contained in this file MUST be considered
 *    as an internal implementation of the communications protocol
 *    between the Apama client API and an Apama server.  As such
 *    these event definitions MUST NOT be considered "stable" and are 
 *    subject to change in any future software release.
 *
 *    The ONLY supported public APIs to the Scenario Service are the 
 *    Java client API (in the com.apama.services.scenario package) and the 
 *    .NET client API (in the Apama.Services.Scenario namespace).  
 *    Customers should not attempt to interface at the event or 
 *    EPL layer. Some events have been changed over time (as 
 *    noted here).
 *
 * 2) Most events now contain an initial field called "scenarioId". This string 
 *    uniquely identifies a scenario inside the correlator, and is used as 
 *    the package name, in several events, and for making up a part of the 
 *    data and control channel names.
 *
 * 3) Events that are intended to be used in a request-response pattern contain
 *    a "messageId" field.  The value of this field must be copied from the 
 *    request event into the response event. The mechanism allows clients to 
 *    match up request-response pairs.
 *
 *
 * $Copyright(c) 2005-2011 Progress Software Corporation (PSC). All rights reserved.$
 * $Copyright (c) 2013 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or Terracotta Inc., San Francisco, CA, USA, and/or Software AG (Canada) Inc., Cambridge, Ontario, Canada, and/or, Software AG (UK) Ltd., Derby, United Kingdom, and/or Software A.G. (Israel) Ltd., Or-Yehuda, Israel and/or their licensors.$
 * Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG
 *
 * $Revision: 216311 $
 */

/**
 * Request that a new instance of a specific scenario is created.
 *
 * See also: Created(), Acknowledge()
 *
 * Direction: From the client to the correlator.
 *
 * Response: Acknowledge()
 */
event Create {
	string scenarioId;                   // the unique name of the scenario
	integer messageId;                   // the unique message ID (for request-response matching)
	string owner;                        // the owner (user) of the instance.
	sequence<string> inputFieldValues;   // sequence of INPUT field values in string form
}


/**
 * Notifies all interested clients that a new instance of a specific 
 * scenario has been created. 
 * The event provides the owner (user), initial state, and initial values for 
 * all input fields and all output fields.
 *
 * See also: Create()
 *
 * Direction: From the correlator to the client.
 *
 * Channel: <scenarioId>.Data and <scenarioId>.Data.Raw
 */
event Created { 
	string scenarioId;                   // the unique name of the scenario
	integer messageId;                   // the unique message ID (for request-response matching)
	integer scenarioInstanceId;          // the ID of the scenario instance
	string owner;                        // the owner (user) of the instance.
	string state;                        // the initial state of the instance.
	sequence<string> inputFieldValues;   // sequence of INPUT field values in string form
	sequence<string> outputFieldValues;  // sequence of OUTPUT field values in string form
}


/**
 * Notifies the interested clients of child scenarios created from
 * a parent scenario.
 *
 * Direction: Internal in the correlator
 *
 * Channel: <none>
 */
event ParentChildRelationship {
	string parentScenarioId;
	integer parentScenarioInstanceId;
	string childScenarioId;
	integer childScenarioInstanceId;
}


/**
 * Request that a specific instance of a specific scenario is edited (the input 
 * field values are changed).
 *
 * See also: Edited(), Acknowledge()
 *
 * Direction: From the client to the correlator.
 *
 * Response: Acknowledge()
 */
event Edit { 
	string scenarioId;                   // the unique name of the scenario
	integer messageId;                   // the unique message ID (for request-response matching)
	integer scenarioInstanceId;          // the ID of the scenario instance
	sequence<string> inputFieldValues;   // sequence of INPUT field values in string form
}


/**
 * Notifies all interested clients that a specific instance of a specific 
 * scenario has been edited (the input field values have changed).
 *
 * See also: Edit()
 *
 * Direction: From the correlator to the client.
 *
 * Channel: <scenarioId>.Data and <scenarioId>.Data.Raw
 */
event Edited { 
	string scenarioId;                   // the unique name of the scenario
	integer messageId;                   // the unique message ID (for request-response matching)
	integer scenarioInstanceId;          // the ID of the scenario instance
	sequence<string> inputFieldValues;   // sequence of INPUT field values in string form
	sequence<string> outputFieldValues;  // sequence of OUTPUT field values in string form
}


/**
 * Request that a specific instance of a specific scenario is deleted.
 *
 * See also: Deleted(), Acknowledge()
 *
 * Direction: From the client to the correlator.
 *
 * Response: Acknowledge()
 */
event Delete {
	string scenarioId;                   // the unique name of the scenario
	integer messageId;                   // the unique message ID (for request-response matching)
	integer scenarioInstanceId;          // the ID of the scenario instance
}


/**
 * Notifies all interested clients that a specific instance of a specific 
 * scenario has been deleted.
 *
 * See also: Delete()
 *
 * Direction: From the correlator to the client.
 *
 * Channel: <scenarioId>.Data and <scenarioId>.Data.Raw
 */
event Deleted {
	string scenarioId;                   // the unique name of the scenario
	integer messageId;                   // the unique message ID (for request-response matching)
	integer scenarioInstanceId;          // the ID of the scenario instance
}


/**
 * Indicates that a specific instance of a specific scenario has died.
 * This is emitted as a result of a scenario instance use of MonitorScript ondie.
 * This occurs for any of deleting a running scenario, a scenario failing, or 
 * entering the end state.
 *
 * Direction: From the correlator to the client.
 *
 * Channel: <scenarioId>.Data and <scenarioId>.Data.Raw
 */
event InstanceDied {
	string scenarioId;                   // the unique name of the scenario
	integer scenarioInstanceId;          // the ID of the scenario instance
}


/**
 * Contains updated scenario instance output fields.
 * Note that this is the ONLY event type that is emitted on the 
 * "<scenarioId>.Data" channel.
 *
 * Direction: From the correlator to the client.
 *
 * Channel: <scenarioId>.Data and <scenarioId>.Data.Raw
 */
event Update { 
	string scenarioId;                   // the unique name of the scenario
	integer scenarioInstanceId;          // the ID of the scenario instance
	float timeStamp;                     // the time of the update (seconds since epoch)
	sequence<string> outputFieldValues;  // sequence of OUTPUT field values in string form
}


/**
 * A general Acknowledgement event that is the "response" to various "request"
 * events such as Create, Edit, Delete.
 *
 * Direction: From the correlator to the client.
 *
 * Channel: <scenarioId>.Control
 */
event Acknowledge { 
	string scenarioId;                   // the unique name of the scenario
	integer messageId;                   // the unique message ID (for request-response matching)
	integer scenarioInstanceId;          // the id of the scenario instance
	boolean success;                     // boolean indication of success
	sequence<string> outputFieldValues;  // sequence of the OUTPUT field values in string form, 
	                                     //   or an empty sequence if success = false
}


/**
 * Indicates that a specific instance of a specific scenario has changed 
 * state, where valid states include "ENDED", "FAILED", "RUNNING".
 *
 * Direction: From the correlator to the client.
 *
 * Channel: <scenarioId>.Data and <scenarioId>.Data.Raw
 */
event StateChange { 
	string scenarioId;                   // the unique name of the scenario.
	integer scenarioInstanceId;          // the ID of the scenario instance.
	string state;                        // the new state.
}


/**
 * Request that each scenario loaded in the correlator send its meta
 * information out on the supplied channel. When all scenarios have
 * sent out this information, a final RequestScenariosDone event will
 * be sent on the same channel.
 *
 * As soon as this event is received, a RequestScenariosAck will be
 * sent on the same channel so client can stop resending the RequestScenarios
 * event.
 *
 * See also: Scenario, RequestScenariosDone, RequestScenariosAck
 *
 * Direction: From the client to the correlator.
 *
 * Response: Scenario() from each loaded scenario.
 */
event RequestScenarios { 
	// renamed for clarity - was Request
	string channel;                      // Name of the private response channel.
}


/**
 * This is a simple marker event that is sent by the correlator to indicate 
 * that it has finished sending all of the Scenario events in response
 * to a RequestScenarios event.
 * 
 * See also: RequestScenarios, Scenario.
 *
 * Direction: From the correlator to the client.
 *
 * Channel: The private channel that was specified in the RequestScenarios event.
 */
event RequestScenariosDone {}

/* This is a simple ack event that is sent by the correlator to indicate the
 * RequestScenarios event is received and the request is being processed
 *
 * See also: RequestScenarios
 *
 * Direction: From the correlator to the client.
 *
 * Channel: The private channel that was specified in the RequestScenarios event.
 */
event RequestScenariosAck {}

/**
 * Request that each instance of the specified scenario send an Instance event 
 * out on the supplied channel. When all instances for the scenario have been 
 * sent out, a final RequestInstancesDone event will be sent on the same channel.
 *
 * See also: Instance, RequestInstancesDone
 *
 * Direction: From the client to the correlator.
 *
 * Response: Instance() from each scenario instance.
 */
event RequestInstancesOnChannel { 
	string scenarioId;                   // Identifier of the scenario for which to return instances. 
	integer messageId;                   // the unique message ID (for request-response matching)
	string channel;                      // Name of the private response channel.
}

/**
 * Request that each instance for the specified user of the specified scenario
 * send an Instance event out on the supplied channel. When all instances for
 * the scenario have been sent out, a final RequestInstancesDone event will be 
 * sent on the same channel.
 *
 * See also: Instance, RequestInstancesDone
 *
 * Direction: From the client to the correlator.
 *
 * Response: Instance() from each scenario instance.
 */
event RequestInstancesOnChannelByUser { 
	string scenarioId;                   // Identifier of the scenario for which to return instances. 
	integer messageId;                   // the unique message ID (for request-response matching)
	string channel;                      // Name of the private response channel.
	string owner;                        // the username to filter by
}


/**
 * This is a simple marker event that is sent by the correlator to indicate 
 * that it has finished sending all of the Instance events in response
 * to a RequestInstancesInternal event.
 * 
 * See also: RequestInstancesInternal, Scenario.
 *
 * Direction: From the correlator to the client.
 *
 * Channel: A unique private channel as specified by the client in a 
 *          RequestScenariosOnChannel event.
 *
 *          Note that previously it would have been on <scenarioId>.Data and 
 *          <scenarioId>.Data.Raw, but that behaviour is now deprecated.
 */
event RequestInstancesDone {
	string scenarioId;                   // Identifier of the scenario for instances were returned. 	
	integer messageId;                   // the unique message ID (for request-response matching)
}


/**
 * Describes the meta-information about a scenario that is loaded in the 
 * correlator.
 * 
 * See also: RequestScenarios, RequestScenariosDone, ScenarioUnloaded
 * 
 * Direction: From correlator to client.
 *
 * Channel:   1) com.apama.scenario to broadcast when loaded.
 *            2) A unique private channel as specified by the client in a 
 *               RequestScenarios event.
 *
 * This event has gained the executionMode field in Apama 4.2
 */
event Scenario {
	string scenarioId;                   // unique identifier for Scenario, e.g. Scenario_statistical$002darbitrage
	string displayName;                  // user-specified name for Scenario, e.g. statistical-arbitrage
	string description;                  // description of the Scenario
	sequence<string> inputNames;         // input parameter names
	sequence<string> inputTypes;         // input parameter types
	sequence<string> inputConstraints;   // input parameter contraints
	sequence<string> inputDefaults;      // input parameter default values
	sequence<string> outputNames;        // output parameter names
	sequence<string> outputTypes;        // output parameter types
	integer executionMode;               // 0 = serial, 1 = parallel, 2 = parallel child. New as of 4.2
}



/**
 * Indicates that a specific Scenario definition is being unloaded.
 *
 * Direction: From the correlator to the client.
 *
 * Channel: <scenarioId>.Control
 */
event ScenarioUnloaded { 
	string scenarioId;                   // the unique name of the scenario
}

/**
 * Provides a dump of the current state of a scenario instance.
 * The event definition is identical to the Created event, and includes the 
 * owner (user), initial state, and current values for all input fields and 
 * all output fields.
 *
 * Instance events are sent in response to RequestInstancesOnChannel event 
 * and the deprecated RequestInstancesInternal event; 
 *
 * See also: RequestInstancesOnChannel, RequestInstancesDone, RequestInstancesInternal
 *
 * Direction: From the correlator to the client.
 *
 * Channel: A unique private channel as specified by the client in a 
 *          RequestScenariosOnChannel event.
 *
 *          Note that previously it would have been on <scenarioId>.Data and 
 *          <scenarioId>.Data.Raw, but that behaviour is now deprecated.
 */
event Instance {
	string scenarioId;                   // the unique name of the scenario. 
	integer messageId;                   // the unique message ID (for request-response matching)
	integer scenarioInstanceId;          // the ID of the scenario instance. 
	string owner;                        // the owner (user) of the instance.
	string state;                        // the initial state of the instance.
	sequence<string> inputFieldValues;   // sequence of INPUT field values in string form. 
	sequence<string> outputFieldValues;  // sequence of OUTPUT field values in string form. 
}


/**
 * Indicates this shared MonitorScript has been loaded.
 *
 * Direction: From the correlator to the client.
 *
 * Channel: com.apama.scenario to broadcast when loaded.
 */
event ScenarioServiceLoaded { 
}

/**
 * Indicates this shared MonitorScript is being unloaded.
 *
 * Direction: From the correlator to the client.
 *
 * Channel: com.apama.scenario to broadcast when unloaded.
 */
event ScenarioServiceUnloaded { 
}


/**
 * Set the period over which updates will be queued and coalesced before being
 * sent out on the data channel. Defaults to zero, which means they won't be
 * queued. If it is negative then we won't send any updates on the data channel.
 * This event is deprecated and the ConfigureUpdates event should be used 
 * instead (see below)
 */
event SetThrottlingPeriod {
	float period;   // The period in seconds. Default zero.
}


/**
 * Configures how updates are sent from scenarios.
 * Each scenario is controlled by two configurations - a global default,
 * and an optional per scenario configuration.  The per scenario
 * configuration takes precedence over the global default.
 * The configuration is made up of a number of entries in 
 * the configuration dictionary. The ConfigureUpdate event 
 * is merged into any previous configuration.
 *
 * Global configuration can be modified by specifying an empty string 
 * for scenarioId, and empty values remove values.
 */
event ConfigureUpdates {
	string scenarioId; // empty indicates a default 
	/** 
	 * A set of the configurations modified by this event
	 * the key and meaning is one of:
	 * sendThrottled - boolean - whether to send Updates to the 
	 *                           Throttled (.Data) channel (default=true)
	 * throttlePeriod - float - period with which to send Updates. 
	 *                          0.0 means updates are not throttled - 
	 *                          every update is sent on the Throttled 
	 *                          channel. (default=0.0)
	 * sendRaw - boolean - whether to send Updates on the Raw channel 
	 *                     (.Raw) (default=true)
 	 * sendThrottledUser - boolean - whether to send Updates to the 
	 *                     throttled filtered (.Data:username) channel
	 *                     (default=false)
 	 * sendRawUser - boolean - whether to send Updates to the Raw 
	 *                     channel (.Raw:username) (default=false)
	 * routeUpdate - boolean - whether to route Update (and Edited, Deleted) events.
	 * An empty value removes that entry from the configuration
	 */
	dictionary<string,string> configuration;
}

/**
 * Immediately flushes to receivers any scenario Update events that were 
 * waiting for the next throttling period before being sent. 
 * 
 */
event SendQueuedUpdatesNow {
	
}

/* ==========================================================================
 * The following describes INTERNAL event definitions that should not be sent 
 * into the correlator, nor relied upon.
 * ==========================================================================
 */

/**
 * Request that each instance of the specified scenario send an Instance event 
 * out on the scenario Data or Raw channel. When all instances for the scenario
 * have been sent out, a final RequestInstancesDone event will be sent on the 
 * same channel.
 *
 * See also: Instance, RequestInstancesDone, RequestInstancesOnChannel, RequestInstancesOnChannelByUser
 *
 * Direction: From the ScenarioService to the scenario
 *
 * Response: Instance() from each scenario instance, RequestInstancesDone when finished.
 */
event RequestInstancesInternal { 
	string scenarioId;                   // Identifier of the scenario for which to return instances. 
	integer messageId;                   // the unique message ID (for request-response matching)
	string channel;                      // Name of the private response channel.
	boolean internal;                    // if true, events should be routed/ enqueue-to'd the main context
	string owner;                        // owner filter (optional)
	boolean ownerFilter;                 // whether to filter by owner
}

/**
 * A scenario has finished running, but is still discoverable.
 * (i.e. entered end state or failed - but not deleted).
 * Note that this event contains the state as of the last
 * Update/ Edited event - i.e. if an action modified an output variable 
 * and then caused the scenario to fail, the prior modification
 * would not be reflected in this event.
 *
 * This event contains sufficient information for discovery of the
 * scenario instance later
 * 
 * Direction: from scenarios to the ScenarioService sub-monitor (spawned per scenario)
 */
event ScenarioFinished {
	string scenarioId;                   // Identifier of the scenario which has failed. 
	integer scenarioInstanceId;          // the ID of the scenario instance. 
	string owner;                        // the owner (user) of the instance.
	string state;                        // the initial state of the instance.
	sequence<string> inputFieldValues;   // sequence of INPUT field values in string form. 
	sequence<string> outputFieldValues;  // sequence of OUTPUT field values in string form. 
}
/**
 * Only used internally to tell all the scenarios to start routing their
 * meta data (Scenario). It is followed by a sweeper FinishedScenarioRecovery
 * event which indicates that all the scenarios have reported in.
 */
event StartScenarioRecovery {}

/**
 * Sweeper event to indicate that scenario recovery is done. Only used internally.
 */
event FinishedScenarioRecovery {}

/**
 * Trigger discovery of a parallel scenario. Sent from a sub-monitor of
 * ScenarioService to RequestInstancesHandler to create a new sub-monitor.
 */
event RequestInstancesParallel {
	RequestInstancesInternal request;          // the original request event
	dictionary<integer, context> instances;    // all scenario instances and their running context
	integer highestInstanceId;                 // the highest scenarioInstanceId listed in instances (or more accurately, the highest when discovery started)
}

/**
 * Discovery protocol of a parallel scenario. Sent from a scenario instance
 * to RequestInstancesHandler.
 */
event RequestInstancesParallelDone {
	string scenarioId;                   // the unique name of the scenario
	integer messageId;                   // the unique message ID (for request-response matching)
	integer scenarioInstanceId;          // the ID of the scenario instance
}

/**
 * Notification of a new scenario instance
 */
event ParallelStarting {
	string scenarioId;                   // the unique name of the scenario
	integer scenarioInstanceId;          // the ID of the scenario instance
	string owner;                        // the owner of the scenario instance
	context runningCtx;                  // the context the scenario is running in
}

/**
 * Get the current configuration for a given scenario and the default configuration
 */
event GetConfiguration {
	string scenarioId;                   // the unique name of the scenario
}

/**
 * The current configuration for a given scenario and the default configuration
 * @see ConfigureUpdates
 */
event Configuration {
	string scenarioId;                        // the unique name of the scenario
	dictionary<string, string> defaults;      // the global defaults
	dictionary<string, string> configuration; // the scenario configuration (takes precedence)
}


/**
 * An operation has completed. Sent from parallel scenarios to the main context.
 */
event OperationCompleted {
	string scenarioId;
	integer scenarioInstanceId;
	integer messageId;
}

/**
 * Notification that a scenario has loaded a ConfigureUpdates event
 */
event ScenarioProcessedUpdates {
	string scenarioId;
}

/**
 * Request all configuration
 */
event GetAllConfiguration {
	integer requestId;
}

/** 
 * Response all configuration
 */
event AllConfiguration {
	integer requestId;
	dictionary<string, string> defaultConfig;
	dictionary<string, dictionary<string, string> > configurations;
}


/**
 * Library of utiltiy actions
 */
event ScenarioServiceLibrary {

	/**
	 * Get the control channel for a scenario Id. This channel
	 * is always enabled (uses an event set scenario ID)
	 */
	action getControlChannel(string scenarioId) returns string
	{
		return scenarioId+".Control";
	}
	/**
	 * Get the data channel for a scenario ID. This channel 
	 * is enabled by the sendThrottled configuration key and 
	 * the throttlePeriod key (Update events may be throttled)
	 */
	action getDataChannel(string scenarioId) returns string
	{
		return scenarioId+".Data";
	}
	/**
	 * Get the raw channel for a scenario ID. This channel
	 * is enabled by the sendRaw configuration key.
	 */
	action getRawChannel(string scenarioId) returns string
	{
		return scenarioId+".Data.Raw";
	}
	/**
	 * Get the data channel for a scenario Id. This channel 
	 * is enabled by the sendThrottledUser configuration key and 
	 * the throttlePeriod key (Update events may be throttled)
	 */
	action getDataUserChannel(string channel, string owner) returns string
	{
		return channel+":"+owner;
	}
	/**
	 * Get the raw channel for a scenario Id. This channel
	 * is enabled by the sendRawUser configuration key.
	 */
	action getRawUserChannel(string channel, string owner) returns string
	{
		return channel+":"+owner;
	}
	
	/**
	 * Merge configuration. Any entries in updates overwrite entries in configuration.
	 * An empty string value removes the value.
	 * @see ConfigureUpdates
	 */
	action mergeConfiguration(dictionary<string, string> updates, dictionary<string, string> configuration) {
		string k;
		for k in updates.keys() {
			configuration[k]:=updates[k];
			if updates[k]="" then {
				configuration.remove(k);
			}
		}
	}
	
	// implementation note: the defaults for sendThrottled, sendRaw, throttlePeriod, etc are in the following actions:
	/**
	 * Get the sendThrottled value from the given configuration
	 * @see ConfigureUpdates
	 */
	action getSendThrottled(dictionary<string,string> defaults, dictionary<string,string> config) returns boolean {
		string c:=getConfig(defaults, config, "sendThrottled", "true");
		return c = "true";
	}

	/**
	 * Get the sendThrottledUser value from the given configuration
	 * @see ConfigureUpdates
	 */
	action getSendThrottledUser(dictionary<string,string> defaults, dictionary<string,string> config) returns boolean {
		string c:=getConfig(defaults, config, "sendThrottledUser", "false");
		return c = "true";
	}
	
	/**
	 * Get the sendRaw value from the given configuration
	 * @see ConfigureUpdates
	 */
	action getSendRaw(dictionary<string,string> defaults, dictionary<string,string> config) returns boolean {
		string c:=getConfig(defaults, config, "sendRaw", "true");
		return c = "true";
	}
	
	/**
	 * Get the sendRawUser value from the given configuration
	 * @see ConfigureUpdates
	 */
	action getSendRawUser(dictionary<string,string> defaults, dictionary<string,string> config) returns boolean {
		string c:=getConfig(defaults, config, "sendRawUser", "false");
		return c = "true";
	}
	
	/**
	 * Get the throttlePeriod value from the given configuration
	 * @see ConfigureUpdates
	 */
	action getThrottlePeriod(dictionary<string,string> defaults, dictionary<string,string> config) returns float {
		string c:=getConfig(defaults, config, "throttlePeriod", "0.0");
		return float.parse(c);
	}
	
	/**
	 * Get the routeUpdate value from the given configuration
	 * @see ConfigureUpdates
	 */
	action getRouteUpdate(dictionary<string,string> defaults, dictionary<string,string> config) returns boolean {
		string c:=getConfig(defaults, config, "routeUpdate", "false");
		return c = "true";
	}
	

	/**
	 * Get the specified key from the configuration dictionaries, reverting to the default 
	 * if none specified.
	 */
	action getConfig(dictionary<string,string> defaults,
	                 dictionary<string,string> config, 
	                 string key, string _default) returns string {
		if config.hasKey(key) then {
			return config[key];
		}
		if defaults.hasKey(key) then {
			return defaults[key];
		}
		return _default;
	}

	action configurationManager(dictionary<string, string> defaultConfig, dictionary<string, dictionary<string, string> > configurations) {
		// the recognised ConfigureUpdates configuration keys, as above:
		dictionary<string,boolean> KNOWN_CONFIG_KEYS := {"sendThrottled":true, "throttlePeriod":false,
		 "sendRaw":true, "sendThrottledUser":true, "sendRawUser":true, "routeUpdate":true};

		dictionary <string,string> EMPTY_DICT:=new dictionary<string,string>;
		ConfigureUpdates cu;
		on all ConfigureUpdates():cu {
			string key;
			for key in cu.configuration.keys() {
				if not KNOWN_CONFIG_KEYS.hasKey(key) then {
					log "Unrecognized configuration property "+key+" in event "+cu.toString() at WARN;
				}
			}
			if cu.scenarioId = "" then {
				mergeConfiguration(cu.configuration, defaultConfig);
				log "Received "+cu.toString()+" : defaults applicable to all scenarios" at INFO;
			} else {
				if not configurations.hasKey(cu.scenarioId) then {
					configurations.add(cu.scenarioId, new dictionary<string,string>);
				}
				mergeConfiguration(cu.configuration, configurations[cu.scenarioId]);
				on ScenarioProcessedUpdates(cu.scenarioId) -> completed ConfigureUpdates(scenarioId=cu.scenarioId) {
					log "Received "+cu.toString()+" : applied to scenario" at INFO;
				}
				on completed ConfigureUpdates(scenarioId=cu.scenarioId) and not ScenarioProcessedUpdates(cu.scenarioId) {
					log "Received "+cu.toString()+" : for scenario that is not yet defined" at INFO;
				}
			}
		}

		GetConfiguration getConfig;
		on all GetConfiguration():getConfig {
			dictionary<string,string> config:=EMPTY_DICT;
			if configurations.hasKey(getConfig.scenarioId) then {
				config:=configurations[getConfig.scenarioId];
			}
			route Configuration(getConfig.scenarioId, defaultConfig, config);
		}	
		GetAllConfiguration gac;
		on all GetAllConfiguration():gac {
			route AllConfiguration(gac.requestId, defaultConfig, configurations);
		}
	}
		
}

event CallbackHelper {
	sequence<action<> > callbacks;
	action callback {
		action<> c;
		for c in callbacks {
			c();
		}
	}
}



/**
 * Base event for tracking configuration for a given scenario
 */
event ScenarioServiceUpdaterBase {
	// these are internal and should not be set by users
	string scenarioId;
	dictionary<string,string> defaultConfig;
	dictionary<string,string> config;
	ScenarioServiceLibrary lib;
	boolean sendThrottled;
	boolean sendRaw;
	boolean sendAny;
	boolean emitAny;
	boolean sendThrottledUser;
	boolean sendRawUser;
	boolean routeUpdate;
	float throttlePeriod;
	float throttleStart;
	sequence<listener> listeners;
	string controlChannel;
	string rawChannel;
	string dataChannel;

	/**
	 * Called by monitor at onload time
	 * Will maintain configuration for this scenario
	 * @param sId the scenarioId
	 */
	action init(string sId, action<> cb_onUpdate) {
		scenarioId:=sId;
		controlChannel := lib.getControlChannel(scenarioId);
		rawChannel := lib.getRawChannel(scenarioId);
		dataChannel := lib.getDataChannel(scenarioId);
		route GetConfiguration(scenarioId);
		Configuration c;
		listener l:=on Configuration(scenarioId=scenarioId):c {
			config := c.configuration;
			defaultConfig := c.defaults;
			configurationUpdated();
			cb_onUpdate();
		}
		listeners.append(l);
	}

	/**
	 * Listen for further configuration changes.
	 * @param cb_onUpdate callback upon configuration having been updated
	 */	
	action listenToConfigureUpdates(action<> cb_onUpdate) {
		ConfigureUpdates cu;
		listener l:=on all ConfigureUpdates(scenarioId=""):cu or all ConfigureUpdates(scenarioId=scenarioId):cu {
			if(cu.scenarioId != "") then {
				route ScenarioProcessedUpdates(cu.scenarioId);
			}
			onConfigureUpdates(cu);
			cb_onUpdate();
		}
		listeners.append(l);
	}

	/**
	 * Called when new ConfigureUpdates event available
	 * @param sId the scenarioId
	 */
	action onConfigureUpdates(ConfigureUpdates cu) {
		if cu.scenarioId = "" then {
			lib.mergeConfiguration(cu.configuration, defaultConfig);
		} else {
			lib.mergeConfiguration(cu.configuration, config);
		}
		configurationUpdated();
	}
	
	/**
	 * Called when the configuration should be re-parsed.
	 * @param sId the scenarioId
	 */
	action configurationUpdated() {
		sendThrottled:=lib.getSendThrottled(defaultConfig, config);
		sendThrottledUser:=lib.getSendThrottledUser(defaultConfig, config);
		if sendThrottled or sendThrottledUser then {
			throttlePeriod:=lib.getThrottlePeriod(defaultConfig, config);
			if(throttlePeriod < 0.0) then {
				sendThrottled:=false;
				sendThrottledUser:=false;
			}
			throttleStart:=currentTime;
		}
		sendRaw:=lib.getSendRaw(defaultConfig, config);
		sendRawUser:=lib.getSendRawUser(defaultConfig, config);
		routeUpdate:=lib.getRouteUpdate(defaultConfig, config);
		sendAny:= sendRaw or sendThrottled or routeUpdate or sendRawUser or sendThrottledUser;
		emitAny:= sendRaw or sendThrottled or sendRawUser or sendThrottledUser;
	}

	/** 
	 * Get whether this scenario should send on the throttled (Data) channel
	 */
	action isSendThrottled() returns boolean {
		return sendThrottled or sendThrottledUser;
	}

	/** 
	 * Get whether this scenario should send on the raw channel
	 */
	action isSendRaw() returns boolean {
		return sendRaw or sendRawUser;
	}

	action doEmit(string emitted, string owner) {
		if sendRaw then {
			emit emitted to rawChannel;
		}
		if sendThrottled then {
			emit emitted to dataChannel;
		}
		if sendRawUser then {
			emit emitted to lib.getRawUserChannel(rawChannel, owner);
		}
		if sendThrottledUser then {
			emit emitted to lib.getDataUserChannel(dataChannel, owner);
		}
	}

	/**
 	 * Kill any listeners this object has started
	 */
	action destroy() {
		listener l;
		for l in listeners {
			l.quit();
		}
	}
}


/**
 * Utilitiy event for tracking configuration for a given scenario.
 * This event is suitable for use by monitors which spawn per instance
 * (e.g. Scenarios)
 * 
 * This event also uses a callback to get the updates (supplied in
 * instanceInit). If the scenario is configured to only send throttled 
 * updates, the callback is only called when the throttling period 
 * determines an update should be sent - thus, the scenario does not
 * need to generate the output sequence<string> except when needed,
 * which can improve performance in such a configuration.
 * 
 * actions starting with an underscore should be considered private 
 * and not called by users of this event.
 */
event ScenarioServiceUpdaterSingleInstance {
	// these are internal and should not be set by users
	string scenarioId;
	integer scenarioInstanceId;
	ScenarioServiceLibrary lib;
	listener throttlingListener;
	ScenarioServiceUpdaterBase base;
	boolean havePending;
	float latestUpdate;
	action<> returns sequence<string> getUpdate;
	Update update;
	boolean needUpdate;
	context mainContext;
	string owner;
	string controlChannel;
	string rawChannel;
	string dataChannel;

	/**
	 * Called by monitor at onload time
	 * Will maintain configuration for this scenario
	 */
	action init(string sId) {
		init_cb(sId, _noopAction);
	}
	
	/**
	 * Called by monitor at onload time
	 * Will maintain configuration for this scenario.
	 * cb_init is called when initialisation is complete
	 */
	action init_cb(string sId, action<> cb_init) {
		base.init(sId, cb_init);
		scenarioId:=sId;
		controlChannel := lib.getControlChannel(scenarioId);
		rawChannel := lib.getRawChannel(scenarioId);
		dataChannel := lib.getDataChannel(scenarioId);
		base.listenToConfigureUpdates(_noopAction);
		mainContext:=context.current();
	}

	action _noopAction() {
	}
	

	/**
	 * Called by monitor after spawn
	 * Will maintain configuration for this scenario, and update listeners appropriately.
	 * @param getUpdateCallback a callback to get the latest outputFieldValues - may be called at any time, must 
         *        always return a consistent set of outputs
	 */
	action instanceInit(integer id, action<> returns sequence<string> getUpdateCallback, string _owner) {
		scenarioInstanceId:=id;
		owner:=_owner;
		getUpdate:=getUpdateCallback;
		update.scenarioId:=scenarioId;
		update.scenarioInstanceId:=scenarioInstanceId;
		base.listenToConfigureUpdates(_configurationUpdated);
		_configurationUpdated();
		listener l:=on all SendQueuedUpdatesNow() {
			_sendThrottledUpdate();
		}
		base.listeners.append(l);
	}

	/** 
	 * Get whether this scenario should route updates
	 */
	action isRouteUpdate() returns boolean {
		return base.routeUpdate;
	}

	/**
 	 * Kill any listeners this object has started
	 */
	action destroy() {
		base.destroy();
		throttlingListener.quit();
	}
	  
	/**
	 * called in instances (not factories) when configuration has changed
	 */
	action _configurationUpdated {
		if base.isSendThrottled() then {
			throttlingListener.quit();
			flushPending();
			if(base.throttlePeriod >= 0.0) then {
				if havePending then {
					_setupThrottleListener();
				}
			}
		}
	}

	/**
	 * set up a throttled listener according to throttlePeriod control
	 */
	action _setupThrottleListener {
		if base.throttlePeriod > 0.0 then {
			float offset:=currentTime-base.throttleStart;
			float t:=((offset/base.throttlePeriod).floor()+1).toFloat();
			throttlingListener:=on wait((t*base.throttlePeriod)-offset) {
				_sendThrottledUpdate();
			}
		} else {
			_sendThrottledUpdate();
		}
	}

	/**
	 * actually send an update on the throttled channel
	 */
	action _sendThrottledUpdate {
		if not havePending then {
			return;
		}
		if needUpdate then {
			update.outputFieldValues:=getUpdate();
			update.timeStamp:=latestUpdate;
			needUpdate:=false;
		}
		if base.sendThrottled then {
			emit update to dataChannel;
		}
		if base.sendThrottledUser then {
			emit update to lib.getDataUserChannel(dataChannel, owner);
		}
		havePending:=false;
	}

	/**
	 * flush any pending update on the throttled channel.
	 */
	action flushPending() {
		if havePending then {
			_sendThrottledUpdate();
			throttlingListener.quit();
		}
	}	

	/**
 	 * Called when a new update is available.
	 */
	action newUpdateAvailable() {
		needUpdate:=true;
		latestUpdate:=currentTime;
 		if base.sendRaw or base.routeUpdate then {
			if needUpdate then {
				update.outputFieldValues:=getUpdate();
				update.timeStamp:=currentTime;
				needUpdate:=false;
			}
			if base.sendRaw then {
				emit update to rawChannel;
			}
			if base.sendRawUser then {
				emit update to lib.getRawUserChannel(rawChannel, owner);
			}
			if base.routeUpdate then {
				route update;
			}
		}
		if base.isSendThrottled() and not havePending then {
			havePending:=true;
			_setupThrottleListener();
		}
	}
	
	/**
 	 * Called to emit a new Acknowledgement event.
	 */
	action emitAcknowledgement(integer messageId) {
		Acknowledge ack:=Acknowledge(scenarioId, messageId, scenarioInstanceId, true, getUpdate());
		if base.routeUpdate then {
			route ack;
		}
		if base.emitAny then {
			emit ack to controlChannel;
		}
	}
				
	/**
 	 * Called to emit a new Nak event.
	 */
	action emitNack(integer messageId) {
		Acknowledge nack:=Acknowledge(scenarioId, messageId, scenarioInstanceId, false, new sequence<string>);
		if base.routeUpdate then {
			route nack;
		}
		if base.emitAny then {
			emit nack to controlChannel;
		}
	}
	
	/**
 	 * Called to emit a new Created event.
	 */
	action emitCreated(integer messageId, string owner, string state, sequence<string> inputVariables, sequence<string> outputVariables) {
		if base.sendAny then {
			Created created:=Created(scenarioId, messageId, scenarioInstanceId, owner, state, inputVariables, outputVariables);
			route created;
			if base.emitAny then {
				base.doEmit(created.toString(), owner);
			}
		}
	}
	
	/**
 	 * Called to emit a new Edited event.
	 */
	action emitEdited(integer messageId, sequence<string> inputVariables) {
		flushPending();
		if base.sendAny then {
			Edited edited:=Edited(scenarioId, messageId, scenarioInstanceId, inputVariables, getUpdate());
			if base.routeUpdate then {
				route edited;
			}
			if base.emitAny then {
				base.doEmit(edited.toString(), owner);
			}
		}
		emitOpCompleted(messageId);
	}

	/**
 	 * Called to say an operation has completed; implied by emitEdited. Must be called before emitInstanceDied.
	 */
	action emitOpCompleted(integer messageId) {
		if(context.current().getId()!=mainContext.getId()) then {
			enqueue OperationCompleted(scenarioId, scenarioInstanceId, messageId) to mainContext;
		}
	}

	/**
 	 * Called to emit a new Deleted event.
	 */
	action emitDeleted(integer messageId) {
		flushPending();
		if base.sendAny then {
			Deleted deleted:=Deleted(scenarioId, messageId, scenarioInstanceId);
			if base.routeUpdate then {
				route deleted;
			}
			if base.emitAny then {
				base.doEmit(deleted.toString(), owner);
			}
		}
		throttlingListener.quit();
		notifyInstanceDied();
	}

	/**
 	 * Called to emit an instance Died event (either of failed, ended)
	 */
	action emitInstanceDied() {
		flushPending();
		if base.sendAny then {
			InstanceDied iDied:=InstanceDied(scenarioId, scenarioInstanceId);
			if base.emitAny then {
				base.doEmit(iDied.toString(), owner);
			}
			if mainContext.getId()=context.current().getId() then {
				route iDied;
			}
		}
		throttlingListener.quit();
	}

	/**
 	 * Called to notify the scenario service monitor that we have gone away - must be called 
 	 * after emitting any events regarding this instance going away. Implied by emitDeleted.
	 */
	action notifyInstanceDied() {
		if mainContext.getId()!=context.current().getId() then {
			InstanceDied iDied:=InstanceDied(scenarioId, scenarioInstanceId);
			enqueue iDied to mainContext;
		}
	}
	
	/**
 	 * Called to emit a new StateChange event.
	 */
	action emitStateChange(string state) {
		flushPending();
		StateChange stchange:=StateChange(scenarioId, scenarioInstanceId, state);
		if mainContext.getId()!=context.current().getId() then {
			enqueue stchange to mainContext;
		} else {
			route stchange;
		}
		if base.emitAny then {
			base.doEmit(stchange.toString(), owner);
		}
	}

	/**
 	 * Called to emit an instance in response to a RequestInstancesInternal event
	 */
	action emitInstance(RequestInstancesInternal request, string owner, string state, sequence<string> input, sequence<string> output) {
		Instance instance:=Instance(scenarioId, request.messageId, scenarioInstanceId, owner, state, input, output);
		if request.internal then {
			if mainContext.getId() != context.current().getId() then {
				enqueue instance to mainContext;
			} else {
				route instance;
			}
		} else {
			if(base.emitAny) then {
				emit instance to request.channel;
			}
		}
		if mainContext.getId() != context.current().getId() then {
			enqueue RequestInstancesParallelDone(scenarioId, request.messageId, scenarioInstanceId) to mainContext;
		}
	}

	/**
 	 * Called when the instance has failed.  input and output are the input
 	 * and output variables as at the last Update/ Edited point.
	 */
	action finished(string state, string owner, sequence<string> input, sequence<string> output) {
		ScenarioFinished scenFinished:=ScenarioFinished(scenarioId, scenarioInstanceId, owner, state, input, output);
		if mainContext.getId() != context.current().getId() then {
			enqueue scenFinished to mainContext;
		} else {
			route scenFinished;
		}
	}
	
}


/**
 * Utilitiy event for tracking configuration for a given scenario.
 * This event is suitable for use by monitors which spawn per scenario,
 * but not per instance. (e.g. ScenarioService, DataViewService)
 * 
 * actions starting with an underscore should be considered private 
 * and not called by users of this event.
 * 
 * Note that this updater only honours sendThrottledUser changes at the next throttling period
 * (it does not record the owner if sendThrottledUser is not true)
 */
event ScenarioServiceUpdaterMultipleInstances {
	// these are internal and should not be set by users
	string scenarioId;
	ScenarioServiceLibrary lib;
	listener throttlingListener;
	ScenarioServiceUpdaterBase base;
	boolean currentlySendingThrottledUser;
	dictionary<integer, Update> updates;
	dictionary<integer, string> owners;
	context mainContext;
	string controlChannel;
	string rawChannel;
	string dataChannel;

	/**
	 * Called by monitor for each scenario
	 * Will maintain configuration for this scenario Id
	 */
	action init(string sId, context mainCtx) {
		_init(sId, mainCtx, _configurationUpdated);
	}
	
	/**
	 * Called by monitor for each scenario
	 * Will maintain configuration for this scenario Id
	 */
	action init_cb(string sId, context mainCtx, action<> cb_initComplete) {
		CallbackHelper callbackHelper:=new CallbackHelper;
		callbackHelper.callbacks.append(cb_initComplete);
		callbackHelper.callbacks.append(_configurationUpdated);
		_init(sId, mainCtx, callbackHelper.callback);
	}

	/**
	 * Implementation of init and init_cb
	 */
	action _init(string sId, context mainCtx, action<> cb_initComplete) {
		base.init(sId, cb_initComplete);
		mainContext:=mainCtx;
		scenarioId:=sId;
		controlChannel := lib.getControlChannel(scenarioId);
		rawChannel := lib.getRawChannel(scenarioId);
		dataChannel := lib.getDataChannel(scenarioId);
		listener l:=on all SendQueuedUpdatesNow() {
			_sendThrottledUpdates();
		}
		base.listeners.append(l);
		base.listenToConfigureUpdates(_configurationUpdated);
	}
	
	/** 
	 * Get whether this scenario should route updates
	 */
	action isRouteUpdate() returns boolean {
		return base.routeUpdate;
	}

	/**
 	 * Kill any listeners this object has started
	 */
	action destroy() {
		base.destroy();
		throttlingListener.quit();
	}
	  

	/**
	 * called in instances (not factories) when configuration has changed
	 */
	action _configurationUpdated {
		if base.isSendThrottled() then {
			throttlingListener.quit();
			flushPending();
			if(base.throttlePeriod >= 0.0) then {
				_setupThrottleListener();
			}
		}
	}

	/**
	 * set up a throttled listener according to throttlePeriod control
	 */
	action _setupThrottleListener {
		if base.throttlePeriod > 0.0 then {
			throttlingListener:=on all wait(base.throttlePeriod) {
				_sendThrottledUpdates();
			}
		} else {
			_sendThrottledUpdates();
		}
	}

	/**
	 * actually send an update on the throttled channel
	 */
	action _sendThrottledUpdates {
		integer instance;
		if base.sendThrottled then {
			for instance in updates.keys() {
				emit updates[instance] to dataChannel;
			}
		}
		if currentlySendingThrottledUser then {
			for instance in updates.keys() {
				emit updates[instance] to lib.getDataUserChannel(dataChannel, owners[instance]);
			}
		}
		owners.clear();
		updates.clear();
		currentlySendingThrottledUser := base.sendThrottledUser;
	}

	/**
	 * flush any pending update on the throttled channel.
	 */
	action flushPending() {
		_sendThrottledUpdates();
	}	

	/**
 	 * Flush pending throttled data for one instance
	 */
	action flushPendingInstance(integer scenarioInstanceId) {
		if updates.hasKey(scenarioInstanceId) then {
			if base.sendThrottled then {
				emit updates[scenarioInstanceId] to dataChannel;
			}
			if currentlySendingThrottledUser then {
				emit updates[scenarioInstanceId] to lib.getDataUserChannel(dataChannel, owners[scenarioInstanceId]);
			}
			updates.remove(scenarioInstanceId);
			if owners.hasKey(scenarioInstanceId) then {
				owners.remove(scenarioInstanceId);
			}
		}
	}	

	/**
 	 * Called when a new update is available. (This variant allows setting of the time parameter)
	 */
	action emitUpdate_time(integer scenarioInstanceId, float time, sequence<string> output, string owner) {
		if base.sendAny then {
			Update update:=Update(scenarioId, scenarioInstanceId, time, output);
			if base.sendRaw then {
				emit update to rawChannel;
			}
			if base.sendRawUser then {
				emit update to lib.getRawUserChannel(rawChannel, owner);
			}
			if base.routeUpdate then {
				route update;
			}
			if base.isSendThrottled() then {
				if base.throttlePeriod > 0.0 then {
					updates.add(scenarioInstanceId, update);
					if currentlySendingThrottledUser then {
						owners.add(scenarioInstanceId, owner);
					}
				} else {
					emit update to dataChannel;
				}
			}
		}
	}
	
	/**
 	 * Called when a new update is available.
	 */
	action emitUpdate(integer scenarioInstanceId, sequence<string> output, string owner) {
		emitUpdate_time(scenarioInstanceId, currentTime, output, owner);
	}

	/**
 	 * Called to emit a new Acknowledgement event.
	 */
	action emitAcknowledgement(integer messageId, integer scenarioInstanceId, sequence<string> output) {
		Acknowledge ack:=Acknowledge(scenarioId, messageId, scenarioInstanceId, true, output);
		if base.routeUpdate then {
			route ack;
		}
		if base.emitAny then {
			emit ack to controlChannel;
		}
	}
				
	/**
 	 * Called to emit a new Nak event.
	 */
	action emitNack(integer messageId, integer scenarioInstanceId) {
		Acknowledge nack:=Acknowledge(scenarioId, messageId, scenarioInstanceId, false, new sequence<string>);
		if base.routeUpdate then {
			route nack;
		}
		if base.emitAny then {
			emit nack to controlChannel;
		}
	}
	
	/**
 	 * Called to emit a new Created event.
	 */
	action emitCreated(integer messageId, integer scenarioInstanceId, string owner, string state, sequence<string> inputVariables, sequence<string> outputVariables) {
		if base.sendAny then {
			Created created:=Created(scenarioId, messageId, scenarioInstanceId, owner, state, inputVariables, outputVariables);
			route created;
			if base.emitAny then {
				string sCreated:=created.toString();
				base.doEmit(sCreated, owner);
			}
		}
	}

	/**
 	 * Called to emit any received events (except for instance) for this scenario.
	 */
	action emitReceivedEvents() {
		dictionary<integer, string> instanceOwners:=new dictionary<integer, string>;
		{
			Update update;
			listener l:=on all Update(scenarioId = scenarioId):update {
				if base.sendRaw then {
					emit update to rawChannel;
				}
				if base.sendRawUser and instanceOwners.hasKey(update.scenarioInstanceId) then {	
					emit update to lib.getRawUserChannel(rawChannel, instanceOwners[update.scenarioInstanceId]);
				}
				if base.isSendThrottled() then {
					if base.throttlePeriod > 0.0 then {
						updates.add(update.scenarioInstanceId, update);
						string owner:="*";
						if instanceOwners.hasKey(update.scenarioInstanceId) then {
							owner:=instanceOwners[update.scenarioInstanceId];
						}
						if currentlySendingThrottledUser then {
							owners.add(update.scenarioInstanceId, owner);
						}
					} else {
						emit update to dataChannel;
					}
				}
			}
			base.listeners.append(l);
		}
		{
			Created created;
			listener l:=on all Created(scenarioId = scenarioId):created {
				if(created.owner != "*") then {
					instanceOwners.add(created.scenarioInstanceId, created.owner);
				}
				base.doEmit(created.toString(), created.owner);				
			}
			base.listeners.append(l);
		}
		{
			Deleted deleted;
			listener l:=on all Deleted(scenarioId = scenarioId):deleted {
				flushPendingInstance(deleted.scenarioInstanceId);
				string owner:="*";
				if instanceOwners.hasKey(deleted.scenarioInstanceId) then {
					owner:=instanceOwners[deleted.scenarioInstanceId];
					instanceOwners.remove(deleted.scenarioInstanceId);
				}
				base.doEmit(deleted.toString(), owner);		
			}
			base.listeners.append(l);
		}
		{
			Edited edited;
			listener l:=on all Edited(scenarioId = scenarioId):edited {
				flushPendingInstance(edited.scenarioInstanceId);
				string owner:="*";
				if instanceOwners.hasKey(edited.scenarioInstanceId) then {
					owner:=instanceOwners[edited.scenarioInstanceId];
				}
				base.doEmit(edited.toString(), owner);		
			}
			base.listeners.append(l);
		}
		{
			InstanceDied instanceDied;
			listener l:=on all InstanceDied(scenarioId = scenarioId):instanceDied {
				flushPendingInstance(instanceDied.scenarioInstanceId);
				string owner:="*";
				if instanceOwners.hasKey(instanceDied.scenarioInstanceId) then {
					owner:=instanceOwners[instanceDied.scenarioInstanceId];
				}
				base.doEmit(instanceDied.toString(), owner);		
			}
			base.listeners.append(l);
		}
	}
	
	/**
 	 * Called to emit a new Edited event.
	 */
	action emitEdited(integer messageId, integer scenarioInstanceId, sequence<string> inputVariables, sequence<string> outputVariables, string owner) {
		flushPendingInstance(scenarioInstanceId);
		if base.sendAny then {
			Edited edited:=Edited(scenarioId, messageId, scenarioInstanceId, inputVariables, outputVariables);
			if base.routeUpdate then {
				route edited;
			}
			if base.emitAny then {
				base.doEmit(edited.toString(), owner);
			}
		}
		emitOpCompleted(messageId, scenarioInstanceId);
	}

	/**
 	 * Called to say an operation has completed; implied by emitEdited. Must be called before emitInstanceDied.
	 */
	action emitOpCompleted(integer messageId, integer scenarioInstanceId) {
		if(context.current().getId()!=mainContext.getId()) then {
			enqueue OperationCompleted(scenarioId, scenarioInstanceId, messageId) to mainContext;
		}
	}

	/**
 	 * Called to emit a new Deleted event.
	 */
	action emitDeleted(integer messageId, integer scenarioInstanceId, string owner) {
		flushPendingInstance(scenarioInstanceId);
		if base.sendAny then {
			Deleted deleted:=Deleted(scenarioId, messageId, scenarioInstanceId);
			if base.routeUpdate then {
				route deleted;
			}
			if base.emitAny then {
				base.doEmit(deleted.toString(), owner);
			}
		}
		notifyInstanceDied(scenarioInstanceId);
	}

	/**
 	 * Called to notify the scenario service monitor that we have gone away - must be called 
 	 * after emitting any events regarding this instance going away. Implied by emitDeleted.
	 */
	action notifyInstanceDied(integer scenarioInstanceId) {
		if mainContext.getId()!=context.current().getId() then {
			InstanceDied iDied:=InstanceDied(scenarioId, scenarioInstanceId);
			enqueue iDied to mainContext;
		}
	}
	

	
	/**
 	 * Called to emit an instance Died event (either of failed, ended)
	 */
	action emitInstanceDied(integer scenarioInstanceId, string owner) {
		flushPendingInstance(scenarioInstanceId);
		if base.sendAny then {
			InstanceDied iDied:=InstanceDied(scenarioId, scenarioInstanceId);
			if base.emitAny then {
				base.doEmit(iDied.toString(), owner);
			}
			if mainContext.getId()=context.current().getId() then {
				route iDied;
			}
		}
	}
	
	/**
 	 * Called to emit a new StateChange event.
	 */
	action emitStateChange(string state, integer scenarioInstanceId, string owner) {
		flushPendingInstance(scenarioInstanceId);
		StateChange stchange:=StateChange(scenarioId, scenarioInstanceId, state);
		if mainContext.getId()!=context.current().getId() then {
			enqueue stchange to mainContext;
		} else {
			route stchange;
		}
		if base.emitAny then {
			base.doEmit(stchange.toString(), owner);
		}
	}

	/**
 	 * Called to emit an instance in response to a RequestInstancesInternal event
	 */
	action emitInstance(RequestInstancesInternal request, integer scenarioInstanceId, string owner, string state, sequence<string> input, sequence<string> output) {
		Instance instance:=Instance(scenarioId, request.messageId, scenarioInstanceId, owner, state, input, output);
		if request.internal then {
			if mainContext.getId() != context.current().getId() then {
				enqueue instance to mainContext;
			} else {
				route instance;
			}
		} else {
			if(base.emitAny) then {
				emit instance to request.channel;
			}
		}
		if mainContext.getId() != context.current().getId() then {
				enqueue RequestInstancesParallelDone(scenarioId, request.messageId, scenarioInstanceId) to mainContext;
		}
	}
	/**
 	 * Called to emit an instance that has already been seen in the current context
	 */
	action emitReceivedInstance(RequestInstancesInternal request, Instance instance) {
		if request.internal then {
			if mainContext.getId() != context.current().getId() then {
				enqueue instance to mainContext;
			}
		} else {
			if(base.emitAny) then {
				emit instance to request.channel;
			}
		}
	}
	
}


/*
 * Monitor that performs the following tasks:
 *   - routing/emitting ScenarioServiceLoaded when the service is loaded
 *   - routing/emitting ScenarioServiceUnloaded when the service is unloaded
 *   - routing/emitting a nack if a Create request is ignored
 *   - maintains latest configuration
 *   - tracks state of ended/ failed scenarios
 *   - forwards Edit, delete events to scenarios in other contexts
 *
 */
monitor ScenarioService {

	event PendingOperation {
		integer messageId;
		integer type; // 0 = delete, 1 = edit
	}

	listener throttledSenderListener;
	ScenarioServiceLibrary lib;
	RequestScenarios requestScenarios;
	boolean requestingScenarios;
	
	// MetaData relating to the interface
	dictionary<string,string> interfaceMetaData := {
		"interface.package"     :"com.apama.scenario",
		"interface.name"        :"ScenarioService",
		"interface.fileName"    :"ScenarioService.mon",
		"interface.vendor"      :"Apama",
		"interface.version"     :"5.1.0.0",
		"interface.fullVersion" :"rel/5.1.0.x@217480",
		"interface.language"    :"MonitorScript"
	};
	
	// Channel names	
	string scenarioServiceChannel := "com.apama.scenario";
	integer highestInstanceId;


	// the first mThread handles scenario discovery and maps some events to internal events
	action onload {
		// print version
		log "ScenarioService interface loaded. MetaData: "+interfaceMetaData.toString() at INFO;
		
		// generate the ScenarioServiceLoaded event
		route ScenarioServiceLoaded();
		emit ScenarioServiceLoaded() to scenarioServiceChannel;

		dictionary <string,string> defaultConfig:=new dictionary<string,string>;
		dictionary <string, dictionary<string,string> > configurations:=new dictionary<string, dictionary<string,string> >;
		lib.configurationManager(defaultConfig, configurations);
		RequestInstancesOnChannel requestInstancesOnChannel;
		on all RequestInstancesOnChannel():requestInstancesOnChannel {
			route RequestInstancesInternal(requestInstancesOnChannel.scenarioId, requestInstancesOnChannel.messageId, requestInstancesOnChannel.channel, false, "", false);
			on RequestInstancesDone(scenarioId=requestInstancesOnChannel.scenarioId, messageId=requestInstancesOnChannel.messageId) {
				emit RequestInstancesDone(requestInstancesOnChannel.scenarioId, requestInstancesOnChannel.messageId) to requestInstancesOnChannel.channel;
			}
		}

		RequestInstancesOnChannelByUser requestInstancesOnChannelByUser;
		on all RequestInstancesOnChannelByUser():requestInstancesOnChannelByUser {
			route RequestInstancesInternal(requestInstancesOnChannelByUser.scenarioId, requestInstancesOnChannelByUser.messageId, requestInstancesOnChannelByUser.channel, false, requestInstancesOnChannelByUser.owner, true);
			on RequestInstancesDone(scenarioId=requestInstancesOnChannelByUser.scenarioId, messageId=requestInstancesOnChannelByUser.messageId) {
				emit RequestInstancesDone(requestInstancesOnChannelByUser.scenarioId, requestInstancesOnChannelByUser.messageId) to requestInstancesOnChannelByUser.channel;
			}
		}
		Scenario scenario;
		on all Scenario():scenario {
			if requestingScenarios then {
				emit scenario to requestScenarios.channel;
			} else {
				spawn trackScenario(scenario);
			}
		}
		
		ScenarioUnloaded scenarioUnloaded;
		on all ScenarioUnloaded(): scenarioUnloaded {
			emit scenarioUnloaded to scenarioServiceChannel;
		}

		
		on all RequestScenarios():requestScenarios {
			emit RequestScenariosAck() to requestScenarios.channel;
			route StartScenarioRecovery();
			route FinishedScenarioRecovery();
			requestingScenarios:=true;
			on FinishedScenarioRecovery() {
				requestingScenarios:=false;
				emit RequestScenariosDone() to requestScenarios.channel;
			}
		}

		dictionary <string,string> EMPTY_DICT:=new dictionary<string,string>;
		// Pick up any requests for operations on invalid scenarioIds
		Create create;
		on all unmatched Create(): create {
			dictionary<string,string> config:=EMPTY_DICT;
			if configurations.hasKey(create.scenarioId) then {
				config:=configurations[create.scenarioId];
			}
			Acknowledge nack := new Acknowledge;
			nack.scenarioId := create.scenarioId;
			nack.messageId := create.messageId;
			nack.success := false;
			log create.scenarioId+": Scenario create ignored - unknown scenarioId." at WARN;
			emit nack to lib.getControlChannel(create.scenarioId);
			if lib.getRouteUpdate(defaultConfig, config) then {
				route nack;
			}
		}

		// The old SetThrottlingPeriod is mapped to a ConfigureUpdates event
		SetThrottlingPeriod setThrottlingPeriod;		
		on all SetThrottlingPeriod():setThrottlingPeriod {
			dictionary<string, string> configChanges:=new dictionary<string,string>;
			if setThrottlingPeriod.period >= 0.0 then {
				configChanges["sendThrottled"]:="true";
				configChanges["throttlePeriod"]:=setThrottlingPeriod.period.toString();
			} else {
				configChanges["sendThrottled"]:="false";
			}
			ConfigureUpdates cu:=ConfigureUpdates("", configChanges);
			log "Received deprecated event "+setThrottlingPeriod.toString()+", will re-route as "+cu.toString() at WARN;
			route cu;
		}
	}		
				
	
	action onunload {
		// generate the ScenarioServiceUnloaded event
		ScenarioServiceUnloaded unloaded := new ScenarioServiceUnloaded;
		route unloaded;
		emit unloaded to scenarioServiceChannel;
	}
	
	/**
	 * spawned per scenario, and handles any finished scenario instances.
	 * For parallel scenarios, it also tracks which instance runs in 
	 * which context and forwards Edit and Delete events.
	 */
	action trackScenario(Scenario scenario) {
		on ScenarioUnloaded(scenarioId=scenario.scenarioId) {
			die;
		}
		ScenarioServiceUpdaterMultipleInstances updater:=new ScenarioServiceUpdaterMultipleInstances;
		updater.init(scenario.scenarioId, context.current());
		ScenarioFinished finished;
		on all ScenarioFinished(scenarioId=scenario.scenarioId):finished {
			// Finished scenarios can be deleted (which terminates all listeners for this instance), 
			// discovered, and edits are Nacked 
			Delete delete;
			on Delete(scenarioId=scenario.scenarioId, scenarioInstanceId = finished.scenarioInstanceId):delete {
				updater.emitAcknowledgement(delete.messageId, finished.scenarioInstanceId, finished.outputFieldValues);
				updater.emitDeleted(delete.messageId, finished.scenarioInstanceId, finished.owner);
			}
			Edit edit;
			on all Edit(scenarioId=scenario.scenarioId, scenarioInstanceId=finished.scenarioInstanceId):edit and not 
			            Delete(scenarioId=scenario.scenarioId, scenarioInstanceId = finished.scenarioInstanceId) {
				updater.emitNack(edit.messageId, finished.scenarioInstanceId);
				log scenario.displayName+"("+finished.scenarioInstanceId.toString()+ "): Scenario edit ignored - Scenario is in "+finished.state+" state." at WARN;
			}
			RequestInstancesInternal requestInstances;
			if finished.owner = "*" then {
				on all RequestInstancesInternal(scenarioId=scenario.scenarioId):requestInstances and not
						Delete(scenarioId=scenario.scenarioId, scenarioInstanceId = finished.scenarioInstanceId) {
					updater.emitInstance(requestInstances, finished.scenarioInstanceId,
						finished.owner, finished.state, finished.inputFieldValues, finished.outputFieldValues);
				}
			} else {
				on all (RequestInstancesInternal(scenarioId=scenario.scenarioId, ownerFilter=false):requestInstances or
					RequestInstancesInternal(scenarioId=scenario.scenarioId, owner=finished.owner, ownerFilter=true):requestInstances) and not
						Delete(scenarioId=scenario.scenarioId, scenarioInstanceId = finished.scenarioInstanceId) {
					updater.emitInstance(requestInstances, finished.scenarioInstanceId,
						finished.owner, finished.state, finished.inputFieldValues, finished.outputFieldValues);
				}
			}
		}
		if scenario.executionMode > 0 then {
			// for parallel scenarios, we keep track of instance to context mapping:
			dictionary<integer, context> runningCtxs := new dictionary<integer, context>;
			// and to owner mapping:
			dictionary<integer, string> ownerCtxs := new dictionary<integer, string>;
			// and by user:
			dictionary<string, dictionary<integer, context> > runningCtxsByOwner := new dictionary<string, dictionary<integer, context> >;
			// maps from instanceId to sequence<messageId>
			dictionary<integer, sequence<PendingOperation> > pendingOperations := new dictionary<integer, sequence<PendingOperation> >;
			ParallelStarting starting;
			on all ParallelStarting(scenarioId = scenario.scenarioId):starting {
				runningCtxs.add(starting.scenarioInstanceId, starting.runningCtx);
				ownerCtxs.add(starting.scenarioInstanceId, starting.owner);
				if not runningCtxsByOwner.hasKey(starting.owner) then {
					runningCtxsByOwner.add(starting.owner, new dictionary<integer, context>);
				}
				runningCtxsByOwner[starting.owner].add(starting.scenarioInstanceId, starting.runningCtx);
				highestInstanceId := starting.scenarioInstanceId;
			}
			
			InstanceDied died;
			on all InstanceDied(scenarioId = scenario.scenarioId):died {
				if runningCtxs.hasKey(died.scenarioInstanceId) then {
					runningCtxs.remove(died.scenarioInstanceId);
				}
				if ownerCtxs.hasKey(died.scenarioInstanceId) then {
					string owner:=ownerCtxs[died.scenarioInstanceId];
					ownerCtxs.remove(died.scenarioInstanceId);
					if runningCtxsByOwner.hasKey(owner) then {
						if runningCtxsByOwner[owner].hasKey(died.scenarioInstanceId) then {
							runningCtxsByOwner[owner].remove(died.scenarioInstanceId);
						}
						if runningCtxsByOwner[owner].size()=0 then {
							runningCtxsByOwner.remove(owner);
						}
					}
				}
				if pendingOperations.hasKey(died.scenarioInstanceId) then {
					PendingOperation pending;
					for pending in pendingOperations[died.scenarioInstanceId] {
						if pending.type = 0 then {
							route Delete(scenario.scenarioId, pending.messageId, died.scenarioInstanceId);
						} else {
							if pending.type = 1 then {
								route Edit(scenario.scenarioId, pending.messageId, died.scenarioInstanceId, new sequence<string>);
							} else {
								log "error: unknown pending operation type "+pending.toString() at ERROR;
							}
						}
					}
					pendingOperations.remove(died.scenarioInstanceId);
				}
			}
			
			// and forward edits, deletes:
			Edit edit;
			on all unmatched Edit(scenarioId = scenario.scenarioId):edit {
				if runningCtxs.hasKey(edit.scenarioInstanceId) then {
					enqueue edit to runningCtxs[edit.scenarioInstanceId];
					addPendingOperation(pendingOperations, edit.scenarioInstanceId, edit.messageId, 1);
					on OperationCompleted(scenarioId = scenario.scenarioId, scenarioInstanceId = edit.scenarioInstanceId, messageId = edit.messageId) and not
					   ScenarioFinished(scenarioId = scenario.scenarioId, scenarioInstanceId = edit.scenarioInstanceId){
						removePendingOperation(pendingOperations, edit.scenarioInstanceId, edit.messageId);
					}
				} else {
					log scenario.displayName+"("+edit.scenarioInstanceId.toString()+"): Scenario edit ignored - unknown scenarioInstanceId." at WARN;
					updater.emitNack(edit.messageId, edit.scenarioInstanceId);
				}
			}
			Delete delete;
			on all unmatched Delete(scenarioId = scenario.scenarioId):delete {
				if runningCtxs.hasKey(delete.scenarioInstanceId) then {
					enqueue delete to runningCtxs[delete.scenarioInstanceId];
					addPendingOperation(pendingOperations, delete.scenarioInstanceId, delete.messageId, 0);
					on OperationCompleted(scenarioId = scenario.scenarioId, scenarioInstanceId = delete.scenarioInstanceId, messageId = delete.messageId) and not
					   ScenarioFinished(scenarioId = scenario.scenarioId, scenarioInstanceId = delete.scenarioInstanceId){
						removePendingOperation(pendingOperations, delete.scenarioInstanceId, delete.messageId);
					}
				} else {
					log scenario.displayName+"("+delete.scenarioInstanceId.toString()+"): Scenario delete ignored - unknown scenarioInstanceId." at WARN;
					updater.emitNack(delete.messageId, delete.scenarioInstanceId);
				}
			}
			
			// and request instances is handled by a separate monitor. Note that 
			// Finished scenarios are not in the dictionary, but are handled by the finished
			// listener above.
			RequestInstancesInternal reqInstances;
			on all RequestInstancesInternal(scenarioId=scenario.scenarioId):reqInstances {
				if reqInstances.ownerFilter then {
					if runningCtxsByOwner.hasKey(reqInstances.owner) then {
						dictionary<integer, context> rCtxs:=runningCtxsByOwner[reqInstances.owner];
						if runningCtxsByOwner.hasKey("*") then {
							rCtxs:=rCtxs.clone();
							integer i;
							dictionary<integer, context> wildcards:=runningCtxsByOwner["*"];
							for i in wildcards.keys() {
								rCtxs.add(i, wildcards[i]);
							}
						}
						route RequestInstancesParallel(reqInstances, rCtxs, highestInstanceId);
					} else {
						if runningCtxsByOwner.hasKey("*") then {
							route RequestInstancesParallel(reqInstances, runningCtxsByOwner["*"], highestInstanceId);
						} else {
							route RequestInstancesParallel(reqInstances, new dictionary<integer,context>, highestInstanceId);
						}
					}
				} else {
					route RequestInstancesParallel(reqInstances, runningCtxs, highestInstanceId);
				}
			}
			ConfigureUpdates cu;
			on all ConfigureUpdates(scenarioId=""):cu or all ConfigureUpdates(scenarioId=scenario.scenarioId):cu {
				integer inst;
				for inst in runningCtxs.keys() {
					enqueue cu to runningCtxs[inst];
				}
			}
			on all SendQueuedUpdatesNow() {
				SendQueuedUpdatesNow snow:=SendQueuedUpdatesNow();
				integer inst;
				for inst in runningCtxs.keys() {
					enqueue snow to runningCtxs[inst];
				}
			}
		}
	}
	
	action addPendingOperation(dictionary<integer,  sequence<PendingOperation> > pendingOperations, integer scenarioInstanceId, integer messageId, integer type) {
		if not pendingOperations.hasKey(scenarioInstanceId) then {
			pendingOperations.add(scenarioInstanceId, new sequence<PendingOperation>);
		}
		pendingOperations[scenarioInstanceId].append(PendingOperation(messageId, type));
	}
	
	action removePendingOperation(dictionary<integer, sequence<PendingOperation> > pendingOperations, integer scenarioInstanceId, integer messageId) {
		if not pendingOperations.hasKey(scenarioInstanceId) then {
			return;
		}
		integer idx:=-1, i:=0;
		while(i < pendingOperations[scenarioInstanceId].size()) {
			if pendingOperations[scenarioInstanceId][i].messageId = messageId then {
				idx:=i;
				break;
			}
			i:=i+1;
		}
		if(idx>=0) then {
			pendingOperations[scenarioInstanceId].remove(idx);
		}
		if pendingOperations[scenarioInstanceId].size() = 0 then {
			pendingOperations.remove(scenarioInstanceId);
		}
	}	
}

/*
 * Monitor that handles request instances for parallel scenarios:
 * - on a RequestInstancesOnChannel for a parallel scenario, the ScenarioService 
 *   routes a RequestInstancesParallel which triggers this monitor to spawn.
 * - this waits for a response (be it to say the request instances has been 
 *   handled or that the scenario has finished) before sending the 
 *   RequestInstancesDone event 
 *
 * Note that this monitor assumes scenarioInstancesIds always increase over time.
 */
monitor RequestInstancesHandler {
	RequestInstancesParallel req;
	action onload {
		on all RequestInstancesParallel():req {
			spawn handleRequest();
		}
	}
	
	/**
	 * Forward the request to every context and await responses. We remove 
	 * instances from the dictionary upon receiving an update for them. 
	 */
	action handleRequest() {
		ScenarioServiceUpdaterMultipleInstances updater:=new ScenarioServiceUpdaterMultipleInstances;
		updater.init(req.request.scenarioId, context.current());
		integer k;
		for k in req.instances.keys() {
			enqueue req.request to req.instances[k];
		}
		// if a scenario dies, it will send events in the order ScenarioFinished, InstanceDied:
		ScenarioFinished finished;
		on all ScenarioFinished(scenarioId=req.request.scenarioId, scenarioInstanceId <= req.highestInstanceId):finished {
			// if a scenario dies after it has sent the Instance, do not send another 
			// (the StateChange/ InstanceDied events are sufficient)
			if(req.instances.hasKey(finished.scenarioInstanceId)) then {
				updater.emitInstance(req.request, finished.scenarioInstanceId,
					finished.owner, finished.state, finished.inputFieldValues, finished.outputFieldValues);
			}
		}
		// A finished scenario should not be counted
		InstanceDied died;
		on all InstanceDied(scenarioId = req.request.scenarioId, scenarioInstanceId <= req.highestInstanceId):died {
			if(req.instances.hasKey(died.scenarioInstanceId)) then {
				req.instances.remove(died.scenarioInstanceId);
				checkFinished();
			}
		}
		RequestInstancesParallelDone pdone;
		on all RequestInstancesParallelDone(scenarioId = req.request.scenarioId, messageId = req.request.messageId):pdone {
			if(req.instances.hasKey(pdone.scenarioInstanceId)) then {
				req.instances.remove(pdone.scenarioInstanceId);
				checkFinished();
			}
		}
		checkFinished();
	}
	
	/**
	 * Check whether we are finished.
	 * We are finished if we have no instances left in our dictionary, in which 
	 * case we route a RequestInstancesDone (handled by the ScenarioService monitor)
	 * and terminate.
	 */
	action checkFinished() {
		if req.instances.size()=0 then {
			route RequestInstancesDone(req.request.scenarioId, req.request.messageId);
			die;
		}
	}
}

 00000034 C:\SoftwareAG\Apama 5.1\monitors\ScenarioService.mon
RMDT 00000016 &INPUT(1,45,true,true)
RMDT 0000001f &REPLAY_ID("EmittedSeqNum",1,0)
TIME 0000000e 1444006032.6,1
MONF 0000f613 package com.apama.dataview;

/*
 * $Copyright(c) 2007-2011 Progress Software Corporation (PSC). All rights reserved.$
 * $Copyright (c) 2013 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or Terracotta Inc., San Francisco, CA, USA, and/or Software AG (Canada) Inc., Cambridge, Ontario, Canada, and/or, Software AG (UK) Ltd., Derby, United Kingdom, and/or Software A.G. (Israel) Ltd., Or-Yehuda, Israel and/or their licensors.$
 * Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG
 */


/* This is an implementation of the Apama DataViewService API.
 *
 * You must first inject the "interface" - DataViewService_Interface.mon
 * Several implementations of the interface may exist. 
 * You may also need to inject optional "emitter" (see below).
 * Each implementation is in a separate file - inject the one you wish to use.
 *   e.g. this implementation is DataViewService_Impl_Dict.mon
 * 
 *
 * This service enables MonitorScript or JMon applications to expose a simple 
 * read-only "DataView" interface. DataViews may be viewed using Apama Dashboard 
 * Studio in a similar way to Scenarios.
*
 * Route vs. Emit
 * The standard implementations of the DataViewService will always ROUTE 
 * any com.apama.dataview.* events, with the expectation that applications
 * using the service are co-located in the same correlator as the service.
 * If your architecture requires the client application to be in a separate 
 * correlator to the DataView service, then two "emitter" monitors are 
 * available.
 * DataViewService_ServiceEmitter.mon  would be injected into the same 
 * correlator as the DataView service after injecting the DataViewService 
 * interface but before injecting the implementation.
 * DataViewService_ApplicationEmitter.mon  would be injected into the same 
 * correlator as the client application after injecting the DataViewService 
 * interface but before injecting the client application.
 *
 * Notes:
 * 
 * 1) Every event has an initial field called msgId. Clients may choose to put 
 *    some identifier in this field when sending messages to the service. Any 
 *    event routed by the service in response will contain the same identifier.
 *
 * 2) Most events contain a field called "dvName". This string 
 *    uniquely identifies a DataView inside the correlator. 
 *
 * 3) Every event has a final field called extraParams that is a string:string
 *    dictionary. Some implementations may choose to use this field. It provides
 *    a way of future-proofing the interface to a certain extent.
 *
 * $Revision: 215887 $
 */

using com.apama.scenario.Create;
using com.apama.scenario.Delete;
using com.apama.scenario.Edit;
using com.apama.scenario.RequestInstancesDone;
using com.apama.scenario.RequestInstancesInternal;
using com.apama.scenario.Scenario;
using com.apama.scenario.ScenarioServiceUpdaterMultipleInstances;
using com.apama.scenario.ScenarioUnloaded;
using com.apama.scenario.StartScenarioRecovery;

// PRIVATE event defs


/** Send events of this type to change the level of logging within this 
  * implementation. The default level is INFO.
  */
event SetLogLevel {
	string category;
	string level;  // DEBUG, INFO, WARN, ERROR
}


// INTERNAL API CODE

monitor DataViewService_Impl_Dict {

	/** Internal event used to store instances/items in a DataView. */
	event _Item {
		wildcard integer scenarioInstanceId;
		wildcard string owner;
		sequence<string> outputFields;
	}
	

	// Logging flags used by both the parent monitor and the spawned sub-monitor
	boolean LOG_DEBUG := false;
	boolean LOG_INFO := true;
	boolean LOG_WARN := true;
	boolean LOG_ERROR := true;
	string LOG_CATEGORY := "DataViewService_Impl_Dict";
	// MetaData relating to this specific implementation
	dictionary<string,string> implementationMetaData := {
		"implementation.package"       :"com.apama.dataview",
		"implementation.name"          :"DataViewService_Impl_Dict",
		"implementation.fileName"      :"DataViewService_Impl_Dict.mon",
		"implementation.vendor"        :"Apama",
		"implementation.version"       :"5.1.0.0",
		"implementation.fullVersion"   :"rel/5.1.0.x@217480",
		"implementation.language"      :"MonitorScript"
	};

	
	// Variables needed in the parent monitor
	dictionary <string, string> dataViewNamesDictionary;  // scenarioId : dvName
	DataViewAddDefinition dvAddDefinition;

	// Variables required in the per-DataView spawned sub-monitor 
	string dvName;  // this is without the PREFIX (which is defined in the onload)
	string scenarioId; // this is with the PREFIX (which is defined in the onload)
	integer NUM_FIELDS;
	sequence<integer> compoundKeyIndexes; // the indexes of the fields which form the compound unique key of a _Item
	sequence<string> compoundKeyNames;    // the names of the fields which form the compound unique key of a _Item
	dictionary <string, integer> compoundKeyInstanceDictionary; // scenarioInstanceCompoundKey : scenarioInstanceId
	dictionary <integer, _Item> instancesDictionary; // scenarioInstanceId : _Item
	integer scenarioInstanceId := 0;
	
	// Defect 9762.  Space, semi-colon and tab in dvName must be escaped 
	dictionary<string, string> escapeCharMap := {" ":"_",		// space
	                                             ";":"$003b",	// semi-colon
	                                             "	":"$0009",	// tab
	                                             "\t":"$0009"	// tab
	                                            };
	dictionary <string, string> escapedDvNamesDictionary; // unescaped dvname : escaped dvname
	dictionary <string, string> escapedScenarioIdDictionary; // unescaped scenarioId : escaped scenarioId

	ScenarioServiceUpdaterMultipleInstances updater;
	
	
	//===================================================================================
	
	/** A default no-arg constructor for an internal _Item. */
	action createDefaultItem() returns _Item {
		return _Item( -1, "", new sequence<string> );
	}

	/** action to take a string and escape all characters appeared in the escapeCharMap dictionary
	 *
	 * @param s - the string to be escaped
	 * 
	 * @return escaped string.  The original string is returned if there is nothing to be escaped
	**/
	action escapeDvName(string s) returns string {
		integer i;
		string retString := s;
		string unEscapeChar;
		for unEscapeChar in escapeCharMap.keys() {
			retString := _escapeIt(retString, unEscapeChar, escapeCharMap[unEscapeChar]);
		}
		
		return retString;
	}
	
	/** internal recursive method to escape the passed in string s.  s will be scanned for the the 
	    unEscapeChar and if found, replaced that with the escapeChar param.  This process will continue
	    until all characters in s is scanned.
	**/
	action _escapeIt( string s, string unEscapeChar, string escapeChar ) returns string {
		
		if (s.find(unEscapeChar) = -1) then {
			return s;
		}
		
		integer index := s.find(unEscapeChar);

		string rest := s.substring(index+1, s.length());
		string retString := s.substring(0, index) + escapeChar + _escapeIt(rest, unEscapeChar, escapeChar);
		
		return retString;
	}
	
	action getEscapedDvName( string rawDvName ) returns string {
		string s;

		// given the raw dvName, return the cached value
		if (escapedDvNamesDictionary.hasKey(rawDvName)) then {
			return escapedDvNamesDictionary[rawDvName];
		}
		
		// not found, just return original string
		return rawDvName;
	}
	
	action getUnescapedDvName( string escapedDvName ) returns string {
		
		string s;
		for s in escapedDvNamesDictionary.keys() {
			if (escapedDvNamesDictionary[s] = escapedDvName) then {
				return s;
			}
		}
		
		// not found, just return original string
		return escapedDvName;
	}
	
	action getEscapedScenarioId( string rawScenarioId ) returns string {
		string s;

		// given the raw scenarioId, return the cached value
		if (escapedScenarioIdDictionary.hasKey(rawScenarioId)) then {
			return escapedScenarioIdDictionary[rawScenarioId];
		}
		
		// not found, just return original string
		return rawScenarioId;
	}
	
	action getUnescapedScenarioId( string escapedScenarioId ) returns string {
		
		string s;
		for s in escapedScenarioIdDictionary.keys() {
			if (escapedScenarioIdDictionary[s] = escapedScenarioId) then {
				return s;
			}
		}
		
		// not found, just return original string
		return escapedScenarioId;
	}
	
	action convertToScenarioId( string in_dvName ) returns string {
		string PREFIX := "DV_";
		string out_scenarioId;
		
		// for now just prepend the prefix, but in future do more checks and escaping of the name
		out_scenarioId:=PREFIX+in_dvName;
		
		return out_scenarioId;
	}
	
	
	action onload {
		log "DataViewService implementation loaded. MetaData: "+implementationMetaData.toString() at INFO;
		
		initLogging(LOG_CATEGORY);
		
		debug("onload() - entered.");

		// Look for the event to define a new DataView
		on all DataViewAddDefinition():dvAddDefinition {
			string escapedDvName := escapeDvName(dvAddDefinition.dvName);
			
			// name must not be ""
			if (dvAddDefinition.dvName.length()=0) then {
				string msg := "Invalid name for new DataView - length must be greater than zero.";
				warn("onload().on_all_DataViewAddDefinition() - "+msg);
				route DataViewException(dvAddDefinition.msgId, escapedDvName, msg, new dictionary<string,string> );
				return;
			}
			
			//name can not start with MEMST (clashes with memorystore plugin)
			string MEMORY_STORE_PREFIX := "MEMST_";
			if (dvAddDefinition.dvName.find(MEMORY_STORE_PREFIX)=0) then {
				string msg := "Invalid name for new DataView - Must not start with " + MEMORY_STORE_PREFIX;
				warn("onload().on_all_DataViewAddDefinition() - "+msg);
				route DataViewException(dvAddDefinition.msgId, dvAddDefinition.dvName, msg, new dictionary<string,string> );
				return;
			}
			
			
			// displayName must not be ""
			if (dvAddDefinition.dvDisplayName.length()=0) then {
				string msg := "Invalid displayName for new DataView - length must be greater than zero.";
				warn("onload().on_all_DataViewAddDefinition() - "+msg);
				route DataViewException(dvAddDefinition.msgId, escapedDvName, msg, new dictionary<string,string> );
				return;
			}
			
			// use the escaped dvName here.  Will save to the escapedDvNamesDictionary
			// when validation is passed

			// both dvName and scenarioId are escaped
			dvName:=escapedDvName;
			scenarioId:=convertToScenarioId(dvName);
			string rawScenarioId:=convertToScenarioId(dvAddDefinition.dvName);
			
			// Validate the params we were given...
			
			// Make sure this is not already present as a DataView or Scenario
			if dataViewNamesDictionary.hasKey(scenarioId) then {
				string msg := "DataView name already exists";
				warn( "onload().on_all_DataViewAddDefinition() - \""+escapedDvName+"\" - "+msg);
				route DataViewException(dvAddDefinition.msgId, escapedDvName, msg, new dictionary<string,string>);
				return;
			}
			
				
			// Make sure we were given more than zero field names and types
			if (0=dvAddDefinition.fieldNames.size() or 0=dvAddDefinition.fieldTypes.size()) then {
				string msg := "There must be 1 or more fields. DataViewAddDefinition event supplied "+dvAddDefinition.fieldNames.size().toString() +" names, and "+dvAddDefinition.fieldTypes.size().toString()+" types.";
				warn( "onload().on_all_DataViewAddDefinition() - \""+escapedDvName+"\" - "+msg);
				route DataViewException(dvAddDefinition.msgId, escapedDvName, msg, new dictionary<string,string>);
				return;
			}
			
			// Make sure we were not given any duplicate field names or emptystring field names
			dictionary<string,boolean> validNames := new dictionary<string,boolean>;
			string fName;
			for fName in dvAddDefinition.fieldNames {
				// check for name=""
				if (0=fName.length()) then {
					string msg := "One of the supplied field names in a DataViewAddDefinition event is invalid. Field names must have a length greater than zero. The field names supplied were: "+dvAddDefinition.fieldNames.toString();
					warn( "onload().on_all_DataViewAddDefinition() - \""+escapedDvName+"\" - "+msg);
					route DataViewException(dvAddDefinition.msgId, escapedDvName, msg, new dictionary<string,string>);
					return;					
				}
				// check for duplicates
				if (validNames.hasKey(fName)) then {
					string msg := "One of the supplied field names in a DataViewAddDefinition event is a duplicate. Duplicate field name: \""+fName+"\". The field names supplied were: "+dvAddDefinition.fieldNames.toString();
					warn( "onload().on_all_DataViewAddDefinition() - \""+escapedDvName+"\" - "+msg);
					route DataViewException(dvAddDefinition.msgId, escapedDvName, msg, new dictionary<string,string>);
					return;
				}
				validNames[fName] := true;
			}
			
			// Make sure we were given enough types for the field names
			if (dvAddDefinition.fieldNames.size() != dvAddDefinition.fieldTypes.size()) then {
				string msg := "Each field name must have a corresponding type. DataViewAddDefinition event supplied "+dvAddDefinition.fieldNames.size().toString() +" names, and "+dvAddDefinition.fieldTypes.size().toString()+" types.";
				warn( "onload().on_all_DataViewAddDefinition() - \""+escapedDvName+"\" - "+msg);
				route DataViewException(dvAddDefinition.msgId, escapedDvName, msg, new dictionary<string,string>);
				return;
			}
			
			// Make sure the type strings we were given represent valid scenario variable types
			dictionary<string,boolean> validTypes := {"string":true, "float":true, "integer":true, "boolean":true, "enumeration":true};			
			integer i := 0;
			string t;
			for t in dvAddDefinition.fieldTypes {
				if not validTypes.hasKey(t) then {
					string msg := "One of the supplied field types in a DataViewAddDefinition event is invalid. The type supplied at index "+i.toString()+" was: \""+t+"\"";
					warn( "onload().on_all_DataViewAddDefinition() - \""+escapedDvName+"\" - "+msg);
					route DataViewException(dvAddDefinition.msgId, escapedDvName, msg, new dictionary<string,string>);
					return;
				}
				i:=i+1;
			}

			compoundKeyIndexes := new sequence<integer>; // ensure it is ALWAYS reset
			compoundKeyNames := new sequence<string>; // ensure it is ALWAYS reset
			// if we've been given some optional key fields, then validate these
			if (dvAddDefinition.keyFields.size() > 0) then {
				string k;
				for k in dvAddDefinition.keyFields {
					integer idx := dvAddDefinition.fieldNames.indexOf(k);
					if (-1 = idx) then {
						string msg := "One of the supplied keyField field names in a DataViewAddDefinition event is invalid. The invalid keyField name supplied was: \""+k+"\". The keyField names supplied were: "+dvAddDefinition.keyFields.toString();
						warn( "onload().on_all_DataViewAddDefinition() - \""+escapedDvName+"\" - "+msg);
						route DataViewException(dvAddDefinition.msgId, escapedDvName, msg, new dictionary<string,string>);
						return;						
					}
					if (-1 < compoundKeyIndexes.indexOf(idx)) then {
						string msg := "A duplicate keyField field name was given in a DataViewAddDefinition event. Duplicate keyField name: \""+k+"\". The keyField names supplied were: "+dvAddDefinition.keyFields.toString();
						warn( "onload().on_all_DataViewAddDefinition() - \""+escapedDvName+"\" - "+msg);
						route DataViewException(dvAddDefinition.msgId, escapedDvName, msg, new dictionary<string,string>);
						return;												
					}
					compoundKeyIndexes.append(idx); // since it is valid, add the index to the set.
				}
				compoundKeyNames := dvAddDefinition.keyFields;
			}

			// all fields are validated, save the escapedDvName and associate the scenarioId with the escapedName (dvName is escaped already)
			escapedDvNamesDictionary.add(dvAddDefinition.dvName, dvName);
			escapedScenarioIdDictionary.add(rawScenarioId, scenarioId);
			
			dataViewNamesDictionary.add(scenarioId, dvName);
			info("onload().on_all_DataViewAddDefinition() - \""+dvAddDefinition.dvName+"\" - adding new DataView definition with name: \""+dvAddDefinition.dvName+"\", and exposed externally with scenarioId: \""+scenarioId+"\"");
			debug("onload().on_all_DataViewAddDefinition() - \""+dvAddDefinition.dvName+"\" - spawning initializeScenario()...");
			spawn initializeScenario;

		}

		// look for requests to unload definitions and tidy up our records.
		// The actual (spawned) DataView *also* looks for this event and kills itself
		DataViewDeleteDefinition dvDeleteDefinition;
		on all DataViewDeleteDefinition():dvDeleteDefinition {
			string rawScenarioId := convertToScenarioId(dvDeleteDefinition.dvName);
			string escapedScenarioId := getEscapedScenarioId(rawScenarioId);
			if dataViewNamesDictionary.hasKey(escapedScenarioId) then {
				info("onload().on_all_DataViewDeleteDefinition() - \""+dvDeleteDefinition.dvName+"\" - removing DataView from dictionary with DataView name: \""+dvDeleteDefinition.dvName+"\", and exposed externally with scenarioId: \""+rawScenarioId+"\"");
				dataViewNamesDictionary.remove(escapedScenarioId);
				escapedDvNamesDictionary.remove(dvDeleteDefinition.dvName);  // key is unescapedDvName
				escapedScenarioIdDictionary.remove(rawScenarioId);  // key is unescapedScenarioId
			}
		}

		
		// Look for external (i.e. com.apama.scenario API events) to remove
		// existing scenarios from our list to ensure we're up to date.
		ScenarioUnloaded scenScenarioUnloaded;
		on all ScenarioUnloaded():scenScenarioUnloaded {
			// the following if statement should never now eval to true, as the entry in the dictionary 
			// should always have been previously deleted by the DataViewDeleteDefinition (see above). Done for completeness.
			if dataViewNamesDictionary.hasKey(scenScenarioUnloaded.scenarioId) then {
				string dvName := dataViewNamesDictionary[scenScenarioUnloaded.scenarioId];
				info("onload().on_all_ScenarioUnloaded() - \""+scenScenarioUnloaded.scenarioId+"\" - removing DataView from dictionary with DataView name: \""+dvName+"\", and exposed externally with scenarioId: \""+scenScenarioUnloaded.scenarioId+"\"");
				dataViewNamesDictionary.remove(scenScenarioUnloaded.scenarioId);
				escapedDvNamesDictionary.remove(getUnescapedDvName(dvName));  // key is unescapedDvName
				escapedScenarioIdDictionary.remove(getUnescapedScenarioId(scenScenarioUnloaded.scenarioId));  // key is unescapedScenarioId
			}			
		}

		
		// Look for DataViewItem* events for DataView names that do not exist and route exception events
		DataViewAddItem unmatchedAddItem;
		on all unmatched DataViewAddItem():unmatchedAddItem {
			string msg := "Unknown DataView name in a DataViewAddItem event";
			warn("unmatched DataViewAddItem() - "+msg);
			route DataViewException(unmatchedAddItem.msgId, escapeDvName(unmatchedAddItem.dvName), msg, new dictionary<string,string>);
		}
		DataViewAddOrUpdateItem unmatchedAddOrUpdateItem;
		on all unmatched DataViewAddOrUpdateItem():unmatchedAddOrUpdateItem {
			string msg := "Unknown DataView name in a DataViewAddOrUpdateItem event";
			warn("unmatched DataViewAddOrUpdateItem() - "+msg);
			route DataViewException(unmatchedAddOrUpdateItem.msgId, escapeDvName(unmatchedAddOrUpdateItem.dvName), msg, new dictionary<string,string>);
		}
		DataViewUpdateItem unmatchedUpdateItem;
		on all unmatched DataViewUpdateItem():unmatchedUpdateItem {
			string msg := "Unknown DataView name in a DataViewUpdateItem event";
			warn("unmatched DataViewUpdateItem() - "+msg);
			route DataViewItemException(unmatchedUpdateItem.msgId, escapeDvName(unmatchedUpdateItem.dvName), unmatchedUpdateItem.dvItemId, msg, new dictionary<string,string>);
		}
		DataViewUpdateItemDelta unmatchedUpdateItemDelta;
		on all unmatched DataViewUpdateItemDelta():unmatchedUpdateItemDelta {
			string msg := "Unknown DataView name in a DataViewUpdateItemDelta event";
			warn("unmatched DataViewUpdateItemDelta() - "+msg);
			route DataViewItemException(unmatchedUpdateItemDelta.msgId, escapeDvName(unmatchedUpdateItemDelta.dvName), unmatchedUpdateItemDelta.dvItemId, msg, new dictionary<string,string>);
		}
		DataViewDeleteItem unmatchedDeleteItem;
		on all unmatched DataViewDeleteItem():unmatchedDeleteItem {
			string msg := "Unknown DataView name in a DataViewDeleteItem event";
			warn("unmatched DataViewDeleteItem() - "+msg);
			route DataViewItemException(unmatchedDeleteItem.msgId, escapeDvName(unmatchedDeleteItem.dvName), unmatchedDeleteItem.dvItemId, msg, new dictionary<string,string>);
		}
		DataViewDeleteAllItems unmatchedDeleteAllItems;
		on all unmatched DataViewDeleteAllItems():unmatchedDeleteAllItems {
			string msg := "Unknown DataView name in a DataViewDeleteAllItems event";
			warn("unmatched DataViewDeleteAllItems() - "+msg);
			route DataViewException(unmatchedDeleteAllItems.msgId, escapeDvName(unmatchedDeleteAllItems.dvName), msg, new dictionary<string,string>);
		}
		DataViewGetFieldLookup unmatchedLookup;
		on all unmatched DataViewGetFieldLookup():unmatchedLookup {
			string msg := "Unknown DataView name in a DataViewGetFieldLookup event";
			warn("unmatched DataViewGetFieldLookup() - "+msg);
			route DataViewException(unmatchedLookup.msgId, escapeDvName(unmatchedLookup.dvName), msg, new dictionary<string,string>);
		}
		
		debug("onload() - complete.");
	}


	//===================================================================================

	
	// This defines the behaviour for each DataView bridge scenario type
	action initializeScenario {
		debug("initializeScenario() - \""+dvName+"\" - entered (spawned with this action).");
		initLogging(LOG_CATEGORY);
		updater.init(scenarioId, context.current());

		string SCENARIO_SERVICE_CHANNEL := "com.apama.scenario";
		Scenario scenario := new Scenario; // store the schema of the DataView

		// Build up the scenario definition event
		scenario.scenarioId := scenarioId;
		scenario.displayName := dvAddDefinition.dvDisplayName;
		scenario.description := dvAddDefinition.dvDescription;
		scenario.inputNames := [];
		scenario.inputTypes := [];
		scenario.inputConstraints := [];
		scenario.inputDefaults := [];
		scenario.outputNames := dvAddDefinition.fieldNames;
		scenario.outputTypes := dvAddDefinition.fieldTypes;
		scenario.executionMode := 0;
		NUM_FIELDS := scenario.outputTypes.size();
	
		// If we have dont have enough constraints then set default constraints for ALL inputs (ignore any we were given)
		// - no - don't need to do that - always ZERO INPUTS
		
		// If we have dont have enough default initial inputs set basic defaults for ALL inputs (ignore any we were given)
		// - no - don't need to do that - always ZERO INPUTS

		
		// Notify any client listeners when scenario loads
		route scenario;
		emit scenario to SCENARIO_SERVICE_CHANNEL;
		route DataViewDefinition(dvAddDefinition.msgId, dvName, dvAddDefinition.dvDisplayName, dvAddDefinition.dvDescription, dvAddDefinition.fieldNames, dvAddDefinition.fieldTypes, dvAddDefinition.keyFields, new dictionary<string,string>);

		// Build the helper dictionaries
		initialiseFieldLookup(scenario, dvName);
		
		// Look for the request to delete this bridge type
		DataViewDeleteDefinition delDef;
		on DataViewDeleteDefinition(dvName = getUnescapedDvName(dvName)):delDef {
			//Remove this bridge type
			// the "on unload" listener will generate the response.
			info("initializeScenario().on_DataViewDeleteDefinition() - \""+dvName+"\" - routing DataViewDefinitionDeleted/ScenarioUnloaded events...");
			route DataViewDefinitionDeleted(delDef.msgId, dvName, new dictionary<string,string>);
			route ScenarioUnloaded(scenarioId);
			info("initializeScenario().on_DataViewDeleteDefinition() - \""+dvName+"\" - Killing the mthread for this DataView.");
			die;
		}

		// RequestInstances handling (dumps current state of all instances by emitting Instance events)
		RequestInstancesInternal scenRequestInstances;
		on all RequestInstancesInternal(scenarioId = scenarioId): scenRequestInstances {
			debug("initializeScenario().on_all_RequestInstances() - \""+scenarioId+"\" - received request for instances. Initiating recovery on for request messageId: "+scenRequestInstances.messageId.toString());
			
			integer k;
			_Item item;
			for k in instancesDictionary.keys() {
				item := instancesDictionary[k];
				if (LOG_DEBUG) then {
					debug("dvItemMThread().on_all_RequestInstances() - \""+scenarioId+":"+k.toString()+"\" - routing an Instance event for this DataView Item...");
				}
				if(scenRequestInstances.ownerFilter = false or 
				   scenRequestInstances.owner = item.owner or 
				   item.owner = "*") then {
					updater.emitInstance(scenRequestInstances, item.scenarioInstanceId, item.owner, "RUNNING", new sequence<string>, item.outputFields);
				}
			}
			route RequestInstancesDone(scenarioId, scenRequestInstances.messageId);
		}
		
		// Look for the scenario recovery event and send out the definition of this Scenario/DataView. (remember we have spawned per Scenario)
		on all StartScenarioRecovery() {
			route scenario;
		}

		
		
		
		// ========= Listeners for Create/Delete/Edit/Update ==================
		
		
		// ####################################################################
		// ####################################################################	
		// CREATE
		// First if an instance is created via the scenario API (e.g. a dashboard)...
		Create scenCreate;
		on all Create(scenarioId = scenarioId): scenCreate {
			warn("initializeScenario().on_all_Create() - \""+scenarioId+"\" - Scenario instance create ignored - DataViewService does not handle incoming CREATE events from the ScenarioService.");
			emitNack(scenCreate.messageId, -1);
			return;
		}
		// ... secondly if it is created from the MonitorScript side of things
		DataViewAddItem dvAddItem;
		on all DataViewAddItem(dvName = getUnescapedDvName(dvName)): dvAddItem {
			if (LOG_DEBUG) then {
				debug("initializeScenario().on_all_DataViewAddItem() - \""+dvName+"\" - ");
			}
			addDataViewItem(dvAddItem);
		}
		
		
		// #########################################################
		// #########################################################
		// DELETE
		// From Scenario API - Ignore/Nack
		Delete scenDelete;
		on all Delete(scenarioId=scenarioId):scenDelete {
			warn("initializeScenario().on_all_Delete() - \""+scenarioId+":"+scenDelete.scenarioInstanceId.toString()+"\" - Scenario instance delete ignored - DataViewService does not handle incoming DELETE events from the ScenarioService.");
			emitNack(scenDelete.messageId, scenDelete.scenarioInstanceId);
			return;
		}
		// From DataViewService API
		DataViewDeleteItem dvDeleteItem;
		on all DataViewDeleteItem(dvName=getUnescapedDvName(dvName)):dvDeleteItem {
			if (LOG_DEBUG) then {
				debug("initializeScenario().on_all_DataViewDeleteItem() - \""+dvName+":"+dvDeleteItem.dvItemId.toString()+"\" - ");
			}
			deleteDataViewItem(dvDeleteItem);
		}
		// From DataViewService API
		DataViewDeleteAllItems dvDeleteAllItems;
		on all DataViewDeleteAllItems(dvName=getUnescapedDvName(dvName)):dvDeleteAllItems {
			if (LOG_DEBUG) then {
				debug("initializeScenario().on_all_DataViewDeleteAllItems() - \""+dvName+"\" - ");
			}
			deleteAllDataViewItems(dvDeleteAllItems);
		}
		
		
		// #########################################################
		// #########################################################
		// EDIT
		// From Scenario API - Ignore/Nack
		Edit scenEdit;
		on all Edit(scenarioId = scenarioId):scenEdit {
			warn("initializeScenario().on_all_Edit() - \""+scenarioId+":"+scenEdit.scenarioInstanceId.toString()+"\" - Scenario instance edit ignored - DataViewService does not handle incoming EDIT events from the ScenarioService.");
			emitNack(scenEdit.messageId, scenEdit.scenarioInstanceId);
			return;
		}		

		
		// #########################################################
		// #########################################################
		// ADD OR UPDATE (full)
		// Forward the AddOrUpdates from the Monitor via this DataViewService to the Scenario API
		DataViewAddOrUpdateItem dvAddOrUpdateItem;
		on all DataViewAddOrUpdateItem(dvName = getUnescapedDvName(dvName)):dvAddOrUpdateItem {
			addOrUpdateDataViewItem(dvAddOrUpdateItem);
		}

		// #########################################################
		// #########################################################
		// UPDATE (full)
		// Forward the Updates from the Monitor via this DataViewService to the Scenario API
		DataViewUpdateItem dvUpdateItem;
		on all DataViewUpdateItem(dvName = getUnescapedDvName(dvName)):dvUpdateItem {
			updateFullDataViewItem(dvUpdateItem);
		}

		// #########################################################
		// #########################################################
		// UPDATE (delta) - an update containing only deltas
		// Forward the Updates from the Monitor via this DataViewService to the Scenario API
		DataViewUpdateItemDelta dvUpdateItemDelta;
		on all DataViewUpdateItemDelta(dvName = getUnescapedDvName(dvName)):dvUpdateItemDelta {
			updateDeltaDataViewItem(dvUpdateItemDelta);
		}
		
		// ####################################################################
		// ####################################################################
		debug("initializeScenario() - \""+dvName+"\" - complete.");
	}
	
	
	//===================================================================================

	
	// Management Actions

	/** Build the fieldname-index lookup dictionary, and add a the DataViewGetFieldLookup listener. */
	action initialiseFieldLookup(Scenario theScenario, string dataViewName) {
		debug("initialiseFieldLookup() - building the dictionary, and adding a the DataViewGetFieldLookup listener");
		string s;
		integer count := 0;
		dictionary <string, integer> fieldLookupDictionary := new dictionary<string, integer>; // fieldName : index in sequence
		for s in theScenario.outputNames {
			fieldLookupDictionary.add(s, count);
			count := count + 1;
		}		


		// Look for requests for the helper lookup dictionaries and reply
		DataViewGetFieldLookup lookupReq;
		on all DataViewGetFieldLookup(dvName = getUnescapedDvName(dataViewName)):lookupReq {
			debug("initialiseFieldLookup().on_all_DataViewGetFieldLookup() - \""+dataViewName+"\" - routing DataViewFieldLookup event...");
			route DataViewFieldLookup(lookupReq.msgId, dataViewName, fieldLookupDictionary, new dictionary<string,string>);
		}		
	}
	

	action generateInstanceDied(_Item item) {
		// this should only ever be called once, from deleteDataViewItem() or deleteAllDataViewItems(), so we no longer need a flag to says its been called.
		debug("generateInstanceDied() - \""+scenarioId+":"+item.scenarioInstanceId.toString()+"\" - routing Died events.");
		updater.emitInstanceDied(item.scenarioInstanceId, item.owner);
	}
	
	
	//===================================================================================

	
	// Management Actions
	action onunload {
		route DataViewServiceUnloaded( new dictionary<string,string> );
		log "DataViewService implementation unloaded." at INFO;
	}
	
	
	//===================================================================================

	/* Build the compound key from a COMPLETE sequence of values (i.e. not just the keyFields).
	 * The key will ALWAYS be > "".  "" indicates an error.
	 * For a single-field (non-compound) key, whose value is "", just return the prefix.
	*/
	action buildCompoundKeyFromSeq(sequence<string> fieldValues) returns string {
		string key := "#";
		integer keyIndex;
		integer i:=0;
		if not (fieldValues.size() = NUM_FIELDS) then {
			warn("buildCompoundKeyfromSeq() - the given sequence of fields is the wrong size. Required: "+NUM_FIELDS.toString()+", Found: "+fieldValues.size().toString());
			return "";
		}
		for keyIndex in compoundKeyIndexes {
			if (fieldValues.size() <= keyIndex) then {
				warn("buildCompoundKeyfromSeq() - the given sequence of fields does not contain a required keyField: "+compoundKeyNames[i]+", index: "+keyIndex.toString());
				return "";
			}
			key := key + fieldValues[keyIndex]; 
			i:=i+1;
			if (compoundKeyIndexes.size() > i) then {
				key := key +":";
			}
		}
		return key;
	}

	/* Build the compound key from a sequence of keyField values ONLY (i.e. just the keyFields).
	 * The key will ALWAYS be > "".  "" indicates an error.
	 * For a single-field (non-compound) key, whose value is "", just return the prefix.
	*/
	action buildCompoundKeyFromKeySeq(sequence<string> keyFieldValues) returns string {
		string key := "#";
		string keyValue;
		integer i:=0;
		if not (keyFieldValues.size() = compoundKeyIndexes.size()) then {
			warn("buildCompoundKeyfromKeySeq() - the given sequence of keyFields is the wrong size. Required: "+compoundKeyIndexes.size().toString()+", Found: "+keyFieldValues.size().toString());
			return "";
		}
		for keyValue in keyFieldValues {
			key := key + keyValue; 
			i:=i+1;
			if (compoundKeyIndexes.size() > i) then {
				key := key +":";
			}
		}
		return key;
	}

	/* Build the compound key from a dictionary of fieldNAME<->fieldvalue. 
	 * The dictionary does not need to contain a complete set of fields, but must contain at least the keyFields.
	 * The key will ALWAYS be > "".  "" indicates an error.
	 * For a single-field (non-compound) key, whose value is "", just return the prefix.
	*/
	action buildCompoundKeyFromDict(dictionary<string,string> fields) returns string {
		string key := "#"; // all keys will have this prefix
		string keyName;
		integer i:=0;
		for keyName in compoundKeyNames {
			if not (fields.hasKey(keyName)) then {
				warn("buildCompoundKeyfromDict() - the given dictionary does not contain a required keyField: "+keyName);
				return "";
			}
			key := key + fields[keyName];
			i:=i+1;
			if (compoundKeyIndexes.size() > i) then {
				key := key +":";
			}
		}
		return key;
	}

	/* Build the compound key from a dictionary of fieldINDEX<->fieldvalue. 
	 * The dictionary does not need to contain a complete set of fields, but must contain at least the keyFields.
	 * The key will ALWAYS be > "".  "" indicates an error.
	 * For a single-field (non-compound) key, whose value is "", just return the prefix.
	*/
	action buildCompoundKeyFromIndexDict(dictionary<integer,string> fields) returns string {
		string key := "#"; // all keys will have this prefix
		integer keyIndex;
		integer i:=0;
		for keyIndex in compoundKeyIndexes {
			if not (fields.hasKey(keyIndex)) then {
				warn("buildCompoundKeyfromIndexDict() - the given dictionary does not contain a required keyField: "+compoundKeyNames[i]+", index: "+keyIndex.toString());
				return "";
			}
			key := key + fields[keyIndex];
			i:=i+1;
			if (compoundKeyIndexes.size() > i) then {
				key := key +":";
			}
		}
		return key;
	}
	
	
	/** Add a new DataViewItem to the current (spawned) DataView.
	 * This action is called as a result of matching a DataViewAddItem.
	 * 
	 * @exception Routes a DataViewException event if the new Item cannot be added.
	 */
	action addDataViewItem(DataViewAddItem dvAddItem) {
		if (LOG_DEBUG) then {
			debug("addDataViewItem() - \""+dvName+"\" - entered.");
		}
		
		if (dvAddItem.fieldValues.size() != NUM_FIELDS) then {
			string msg := "DataView addItem ignored - " + NUM_FIELDS.toString() + " output field(s) required but " + dvAddItem.fieldValues.size().toString() + " provided.";
			
			// dvName is escaped already
			warn("addDataViewItem() - \""+dvName+"\" - " + msg);
			route DataViewException(dvAddItem.msgId, dvName, msg, new dictionary<string,string>);
			return;
		}

		_Item newItem := createDefaultItem();
		newItem.owner := dvAddItem.owner;
		newItem.outputFields := dvAddItem.fieldValues;
		
		// are we using the automatic compound key feature? If so we must generate the key and store it in a dictionary
		if (compoundKeyIndexes.size()>0) then {
			// build the key
			string compoundKey := buildCompoundKeyFromSeq(newItem.outputFields);
			
			// dvName is escaped already
			if (LOG_DEBUG) then {
				debug("addDataViewItem() - \""+dvName+"\" - compoundKey is: "+compoundKey);
			}
			
			// do we already have an item with that key?
			if (compoundKeyInstanceDictionary.hasKey(compoundKey)) then {
				// reject the new item - duplicate key
				string msg := "DataView addItem ignored - the DataView uses the keyFields feature and the new item clashes with an existing item.  The supplied values were: "+dvAddItem.fieldValues.toString();
				warn("addDataViewItem() - \""+dvName+"\" - " + msg);
				route DataViewException(dvAddItem.msgId, dvName, msg, new dictionary<string,string>);
				return;
			}
			
			// add the new key to the dictionary to map it to the scenarioInstanceId(=dvItemId)
			compoundKeyInstanceDictionary.add(compoundKey, scenarioInstanceId);
		}
		
		//copy then increment the main instanceId counter
		newItem.scenarioInstanceId := scenarioInstanceId;
		scenarioInstanceId := scenarioInstanceId + 1;

		// store the newly created Item
		info("addDataViewItem() - \""+dvName+":"+newItem.scenarioInstanceId.toString()+"\" - storing Item...");
		instancesDictionary.add(newItem.scenarioInstanceId, newItem);
	
		// Send Created/Added events to both the Scenario and DataViewService APIs
		// This ensures that the Application MonitorScript and the Components such as Dashboards see the new instance
		if (LOG_DEBUG) then {
			debug("addDataViewItem() - \""+dvName+":"+newItem.scenarioInstanceId.toString()+"\" - routing Created/Added events...");
		}
		updater.emitCreated(-1, newItem.scenarioInstanceId, newItem.owner, "RUNNING", new sequence<string>, newItem.outputFields);
		
		if (LOG_DEBUG) then {
			debug("addDataViewItem() - \""+dvName+":"+newItem.scenarioInstanceId.toString()+"\" - routing initial Update event for this Item...");
		}
		float timeStamp := dvAddItem.timeStamp;
		if (-1.0=timeStamp) then {
			timeStamp:=currentTime;
		}
		updater.emitUpdate_time(newItem.scenarioInstanceId, timeStamp, newItem.outputFields, newItem.owner);
		
		route DataViewItem(dvAddItem.msgId, dvName, newItem.scenarioInstanceId, newItem.owner, newItem.outputFields, new dictionary<string,string>);

		if (LOG_DEBUG) then {
			debug("addDataViewItem() - \""+dvName+":"+newItem.scenarioInstanceId.toString()+"\" - complete.");
		}
	}
	
	
	/* Add a new DataViewItem to the current (spawned) DataView if it does not already exist, 
	 * or update it when it does exist. This will ONLY work when keyFields are used.
	 * Attempts to change the owner of an existing item will be rejected with a DataViewItemException.
	 *
	 * This action is called as a result of matching a DataViewAddOrUpdateItem.
	 * 
	 * @exception Routes a DataViewException event if the new Item cannot be added.
	 * @exception Routes a DataViewItemException event if the new Item attempts to change the owner of an existing item.
	 */
	action addOrUpdateDataViewItem(DataViewAddOrUpdateItem dvAddOrUpdateItem) {
		if (LOG_DEBUG) then {
			debug("addOrUpdateDataViewItem() - \""+dvName+"\" - entered.");
		}
		
		if (0=compoundKeyIndexes.size()) then { 
			// this DataView does not use keyFields - error - The DataViewAddOrUpdateItem event is only valid for DataViews which use keyFields
			string msg := "DataViewAddOrUpdateItem event is only valid for DataViews which use keyFields";
			warn("addOrUpdateDataViewItem() - \""+dvName+"\" - routing DataViewException event - "+msg);
			route DataViewException(dvAddOrUpdateItem.msgId, dvName, msg, new dictionary<string,string>);
			return;
		}

		if (dvAddOrUpdateItem.fieldValues.size() != NUM_FIELDS) then {
			string msg := "DataView addOrUpdateItem ignored - " + NUM_FIELDS.toString() + " output field(s) required but " + dvAddOrUpdateItem.fieldValues.size().toString() + " provided.";
			warn("addOrUpdateDataViewItem() - \""+dvName+"\" - " + msg);
			route DataViewException(dvAddOrUpdateItem.msgId, dvName, msg, new dictionary<string,string>);
			return;
		}

		_Item newItem := createDefaultItem();
		newItem.owner := dvAddOrUpdateItem.owner;
		newItem.outputFields := dvAddOrUpdateItem.fieldValues;
		
		// build the key
	
		string compoundKey := buildCompoundKeyFromSeq(newItem.outputFields);
		if (LOG_DEBUG) then {
			debug("addOrUpdateDataViewItem() - \""+dvName+"\" - compoundKey is: "+compoundKey);
		}
		
		// do we already have an item with that key?
		boolean alreadyExists := compoundKeyInstanceDictionary.hasKey(compoundKey);
		if (alreadyExists) then {
			// Yes we found the key - so we're going to get the existing item and update it (after a couple of checks)
			integer itemId := compoundKeyInstanceDictionary[compoundKey];
			newItem.scenarioInstanceId := itemId; // copy the ID for use when we send out the update
			if (LOG_DEBUG) then {
				debug("addOrUpdateDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - found dvItemId for keyFields");
			}
			
			// Get the existing item
			_Item item := instancesDictionary[itemId];
			
			// Check the owner is not changed
			if (item.owner != newItem.owner) then {
				// reject the new item - attempted to change OWNER
				string msg := "DataView addOrUpdateItem ignored - detected attempt to change the owner of an existing item.  Current owner: \""+item.owner+"\", attempted owner: \""+newItem.owner+"\"";
				warn("addOrUpdateDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - " + msg);
				route DataViewItemException(dvAddOrUpdateItem.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;
			}
			
			// Now we can make the change to the actual stored values
			item.outputFields := newItem.outputFields;
		}
		else {
			// No didn't find the key, so it must be new - add the new key to the dictionary to map it to the scenarioInstanceId(=dvItemId)
			compoundKeyInstanceDictionary.add(compoundKey, scenarioInstanceId);
			
			//copy then increment the main instanceId counter
			newItem.scenarioInstanceId := scenarioInstanceId;
			scenarioInstanceId := scenarioInstanceId + 1;

			// store the newly created Item
			info("addOrUpdateDataViewItem() - \""+dvName+":"+newItem.scenarioInstanceId.toString()+"\" - storing Item...");
			instancesDictionary.add(newItem.scenarioInstanceId, newItem);
		
			// Send Created/Added events to both the Scenario and DataViewService APIs
			// This ensures that the Application MonitorScript and the Components such as Dashboards see the new instance
			if (LOG_DEBUG) then {
				debug("addOrUpdateDataViewItem() - \""+dvName+":"+newItem.scenarioInstanceId.toString()+"\" - routing Created/Added events...");
			}
			updater.emitCreated(-1, newItem.scenarioInstanceId, newItem.owner, "RUNNING", new sequence<string>, newItem.outputFields);
		}

		// In either case (add or update), we now need to route the Update event
		if (LOG_DEBUG) then {debug("addOrUpdateDataViewItem() - \""+dvName+":"+newItem.scenarioInstanceId.toString()+"\" - routing an Update event with the following field values:"+newItem.outputFields.toString());}
		float timeStamp := dvAddOrUpdateItem.timeStamp;
		if (-1.0=timeStamp) then {
			timeStamp:=currentTime;
		}
		updater.emitUpdate_time(newItem.scenarioInstanceId, timeStamp, newItem.outputFields, newItem.owner);
		
		if (not alreadyExists) then {
		
			route DataViewItem(dvAddOrUpdateItem.msgId, dvName, newItem.scenarioInstanceId, newItem.owner, newItem.outputFields, new dictionary<string,string>);
		}

		// All done
		if (LOG_DEBUG) then {
			debug("addOrUpdateDataViewItem() - \""+dvName+":"+newItem.scenarioInstanceId.toString()+"\" - complete.");
		}
	}


	/** Delete an existing DataViewItem from the current (spawned) DataView.
	 * This action is called as a result of matching a DataViewDeleteItem.
	 * 
	 * @exception Routes a DataViewItemException event if the Item cannot be deleted (not found, etc).
	 */
	action deleteDataViewItem(DataViewDeleteItem dvDeleteItem) {
		integer itemId := dvDeleteItem.dvItemId;
		string compoundKey;
		if (0<=itemId) then { // an itemId was supplied
			if (not instancesDictionary.hasKey(itemId)) then {
				string msg := "Unknown dvItemId: "+itemId.toString();
				warn("deleteDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - routing DataViewItemException event - "+msg);
				route DataViewItemException(dvDeleteItem.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;
			}
		}
		else { // no itemId supplied
			if (0=compoundKeyIndexes.size()) then { 
				// this DataView does not use keyFields - error - must supply a dvItemId
				string msg := "A valid dvItemId must be supplied (this DataView does not use keyFields)";
				warn("deleteDataViewItem() - \""+dvName+"\" - routing DataViewItemException event - "+msg);
				route DataViewItemException(dvDeleteItem.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;				
			}
			if (dvDeleteItem.keyFields.size() != compoundKeyIndexes.size()) then {
				// invalid number of keys supplied
				string msg := "Incorrect number of key fields supplied. Found "+dvDeleteItem.keyFields.size().toString()+", require "+compoundKeyIndexes.size().toString();
				warn("deleteDataViewItem() - \""+dvName+"\" - routing DataViewItemException event - "+msg);
				route DataViewItemException(dvDeleteItem.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;				
			}

			// build the key
			compoundKey := buildCompoundKeyFromKeySeq(dvDeleteItem.keyFields);
			if (0=compoundKey.length()) then {
				// we get an error back from buildCompoundKey - most likely the key fields were not supplied
				string msg := "Invalid set of key fields supplied: "+dvDeleteItem.keyFields.toString();
				warn("deleteDataViewItem() - \""+dvName+"\" - routing DataViewItemException event - "+msg);
				route DataViewItemException(dvDeleteItem.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;								
			}
			
			
			// all valid - get the itemId from the dictionary
			if (not compoundKeyInstanceDictionary.hasKey(compoundKey)) then {
				// we built a valid key, but no dvItem is currently known with that key
				string msg := "No DataViewItem could be found for the keyFields supplied: "+dvDeleteItem.keyFields.toString();
				warn("deleteDataViewItem() - \""+dvName+"\" - routing DataViewItemException event - "+msg);
				route DataViewItemException(dvDeleteItem.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;
			}
			itemId := compoundKeyInstanceDictionary[compoundKey];
			if (LOG_DEBUG) then {
				debug("deleteDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - found dvItemId for keyFields");
			}
			
			// remove that compound key
			compoundKeyInstanceDictionary.remove(compoundKey);
		}
		_Item item := instancesDictionary[itemId];

		// Tell everyone about Deletion
		generateInstanceDied(item);
		if (LOG_DEBUG) then {
			debug("deleteDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - routing Deleted events...");
		}
		updater.emitDeleted(-1, itemId, item.owner);
		if (dvDeleteItem.keyFields.size() != compoundKeyIndexes.size()) then {
			// deleted using dvItemId, but this DataView is using keyFields, so we need to build the key to pass out in the Deleted event
			integer i := 0;
			while i < compoundKeyIndexes.size() {
				dvDeleteItem.keyFields.append( item.outputFields[compoundKeyIndexes[i]] );
				i := i + 1;
			}
		}
		route DataViewItemDeleted(dvDeleteItem.msgId, dvName, itemId, dvDeleteItem.keyFields, new dictionary<string,string>);
		info("deleteDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - removing Item...");
		instancesDictionary.remove(itemId);
		
		//debug("deleteDataViewItem() - instancesDictionary content after removal: "+instancesDictionary.toString());
	}


	
	/** Delete all existing DataViewItems from the current (spawned) DataView.
	 * This action is called as a result of matching a DataViewDeleteAllItems.
	 * 
	 * @exception Routes a DataViewItemException event if the Item cannot be deleted (not found, etc).
	 */
	action deleteAllDataViewItems(DataViewDeleteAllItems dvDeleteAllItems) {
		
		// Iterate all the items an delete each one
		integer itemId;
		_Item item;
		for itemId in instancesDictionary.keys() {
			item := instancesDictionary[itemId];
			// Tell everyone about Deletion
			generateInstanceDied(item);
			if (LOG_DEBUG) then {
				debug("deleteAllDataViewItems() - \""+dvName+":"+itemId.toString()+"\" - routing Deleted events...");
			}
			updater.emitDeleted(-1, itemId, item.owner);
		}
		
		// Clear the dictionaries
		info("deleteAllDataViewItems() - \""+dvName+"\" - removing ALL Items...");
		compoundKeyInstanceDictionary.clear();
		instancesDictionary.clear();

		route DataViewAllItemsDeleted(dvDeleteAllItems.msgId, dvName, new dictionary<string,string>);
		
		//debug("deleteAllDataViewItems() - instancesDictionary content after removal: "+instancesDictionary.toString());
	}


	/** Update ALL the field values of an existing DataViewItem in the current (spawned) DataView.
	 * This action is called as a result of matching a DataViewUpdateItem.
	 * 
	 * @exception Routes a DataViewItemException event if the Item cannot be updated (not found, keyField clash, etc).
	 */
	action updateFullDataViewItem(DataViewUpdateItem dvupdate) {
		integer itemId := dvupdate.dvItemId;
		
		// first check the number of fields (this is required before some of the other checks)
		if (dvupdate.fieldValues.size()!= NUM_FIELDS) then {
			string msg := "DataView updateItem ignored - " + NUM_FIELDS.toString() + " output field(s) required but " + dvupdate.fieldValues.size().toString() + " provided.";
			warn("updateFullDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - " + msg);
			route DataViewItemException(dvupdate.msgId, dvName, itemId, msg, new dictionary<string,string>);
			return;
		}

		string compoundKey := "";
		if (0>itemId) then { // no itemId supplied
			if (0=compoundKeyIndexes.size()) then { 
				// this DataView does not use keyFields - error - must supply a dvItemId
				string msg := "A valid dvItemId must be supplied (this DataView does not use keyFields)";
				warn("updateFullDataViewItem() - \""+dvName+"\" - routing DataViewItemException event - "+msg);
				route DataViewItemException(dvupdate.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;				
			}
			// build the key
			compoundKey := buildCompoundKeyFromSeq(dvupdate.fieldValues);
			if (LOG_DEBUG) then {
				debug("updateFullDataViewItem() - \""+dvName+"\" - compoundKey: "+compoundKey);
			}
			if (0=compoundKey.length()) then {
				// we get an error back from buildCompoundKey - most likely the key fields were not supplied?
				string msg := "Unable to construct compound key from field values: "+dvupdate.fieldValues.toString();
				warn("updateFullDataViewItem() - \""+dvName+"\" - routing DataViewItemException event - "+msg);
				route DataViewItemException(dvupdate.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;								
			}
			
			// all valid - get the itemId from the dictionary
			if (not compoundKeyInstanceDictionary.hasKey(compoundKey)) then {
				// we built a valid key, but no dvItem is currently known with that key
				string msg := "No DataViewItem could be found using the keyFields from the field values supplied: "+dvupdate.fieldValues.toString();
				warn("updateFullDataViewItem() - \""+dvName+"\" - routing DataViewItemException event - "+msg);
				route DataViewItemException(dvupdate.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;
			}
			itemId := compoundKeyInstanceDictionary[compoundKey];
			if (LOG_DEBUG) then {
				debug("updateFullDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - found dvItemId for keyFields");
			}
		}
		
		// check if we have an Item with the (supplied or calculated) itemId
		if (not instancesDictionary.hasKey(itemId)) then {
			string msg := "Unknown dvItemId: "+itemId.toString();
			warn("updateFullDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - routing DataViewItemException event - "+msg);
			route DataViewItemException(dvupdate.msgId, dvName, itemId, msg, new dictionary<string,string>);
			return;
		}
				
		_Item item := instancesDictionary[itemId];
		
		// IMPORTANT
		// check we have not altered a keyField value if this DataView is configured for their use!!
		if (0<compoundKeyIndexes.size()) then {
			string existingCompoundKey := buildCompoundKeyFromSeq(item.outputFields);
			if (0=compoundKey.length()) then {
				compoundKey := buildCompoundKeyFromSeq(dvupdate.fieldValues);
			}
			if not (compoundKey=existingCompoundKey) then {
				string msg := "DataView updateItem ignored - It is not permitted to change the value of a keyField. The supplied values were: "+dvupdate.fieldValues.toString();
				warn("updateFullDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - routing DataViewItemException event - "+msg);
				route DataViewItemException(dvupdate.msgId, dvName, itemId, msg, new dictionary<string,string>);

				if (LOG_DEBUG) then {debug("updateFullDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - existing compoundKey: \""+existingCompoundKey+"\", new compoundKey: \""+compoundKey+"\"");}
				
				return;				
			}
		}

		// Now we can make the change to the actual stored values
		integer i:=0;
		while(i<NUM_FIELDS) {
			item.outputFields[i] := dvupdate.fieldValues[i].clone();
			i:=i+1;
		}

		if (LOG_DEBUG) then {debug("updateFullDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - routing an Update event with the following field values:"+item.outputFields.toString());}
		float timeStamp := dvupdate.timeStamp;
		if (-1.0=timeStamp) then {
			timeStamp:=currentTime;
		}
		updater.emitUpdate_time(item.scenarioInstanceId, timeStamp, item.outputFields, item.owner);
	}
	
	
	/** Update a SUBSET of the field values of an existing DataViewItem in the current (spawned) DataView.
	 * This action is called as a result of matching a DataViewUpdateItemDelta.
	 * 
	 * @exception Routes a DataViewItemException event if the Item cannot be updated (not found, keyField clash, etc).
	 */
	action updateDeltaDataViewItem(DataViewUpdateItemDelta dvdelta) {

		integer numberOfUpdatedFields := dvdelta.fieldValues.size() - compoundKeyIndexes.size();
		if (numberOfUpdatedFields=0) or (dvdelta.fieldValues.size()=0) then {
			// empty delta
			if LOG_DEBUG then {debug("updateDeltaDataViewItem() - \""+dvName+":"+dvdelta.dvItemId.toString()+"\" - empty delta - ignored. Delta field values: "+dvdelta.fieldValues.toString());}
			//route DataViewItemException(dvName, dvdelta.dvItemId, "Empty delta - ignored. Delta field values: "+dvdelta.fieldValues.toString(), new dictionary<string,string>);
			return;
		}
		
		integer itemId := dvdelta.dvItemId;
		string compoundKey := "";
		
		if (0>itemId) then { // no itemId supplied
			if (0=compoundKeyIndexes.size()) then { 
				// this DataView does not use keyFields - error - must supply a dvItemId
				string msg := "A valid dvItemId must be supplied (this DataView does not use keyFields)";
				warn("updateDeltaDataViewItem() - \""+dvName+"\" - routing DataViewItemException event - "+msg);
				route DataViewItemException(dvdelta.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;				
			}
			if (numberOfUpdatedFields<0) then {
				// not enough dictionary items provided - must be at least the number of keyFields+1
				string msg := "Not enough delta field values provided. Must be at least number of keyFields +1 (="+ (compoundKeyIndexes.size()+1).toString() +"). Supplied delta field values: "+dvdelta.fieldValues.toString();
				warn("updateDeltaDataViewItem() - \""+dvName+"\" - routing DataViewItemException event - "+msg);
				route DataViewItemException(dvdelta.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;				
			}
			// build the key
			compoundKey := buildCompoundKeyFromIndexDict(dvdelta.fieldValues);
			if (LOG_DEBUG) then {
				debug("updateDeltaDataViewItem() - \""+dvName+"\" - compoundKey: "+compoundKey);
			}
			if (0=compoundKey.length()) then {
				// we get an error back from buildCompoundKey - most likely the key fields were not supplied?
				string msg := "Unable to construct compound key from delta field values: "+dvdelta.fieldValues.toString();
				warn("updateDeltaDataViewItem() - \""+dvName+"\" - routing DataViewItemException event - "+msg);
				route DataViewItemException(dvdelta.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;								
			}
			
			// all valid - get the itemId from the dictionary
			if (not compoundKeyInstanceDictionary.hasKey(compoundKey)) then {
				// we built a valid key, but no dvItem is currently known with that key
				string msg := "No DataViewItem could be found for the keyFields supplied: "+dvdelta.fieldValues.toString();
				warn("updateDeltaDataViewItem() - \""+dvName+"\" - routing DataViewItemException event - "+msg);
				route DataViewItemException(dvdelta.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;
			}
			itemId := compoundKeyInstanceDictionary[compoundKey];
			if (LOG_DEBUG) then {
				debug("updateDeltaDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - found dvItemId for keyFields");
			}
		}

		// check if we have an Item with the (supplied or calculated) itemId
		if (not instancesDictionary.hasKey(itemId)) then {
			string msg := "Unknown dvItemId: "+itemId.toString();
			warn("updateDeltaDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - routing DataViewItemException event - "+msg);
			route DataViewItemException(dvdelta.msgId, dvName, itemId, msg, new dictionary<string,string>);
			return;
		}
		
		//if (LOG_DEBUG) then {debug("updateDeltaDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - content of delta: "+dvdelta.fieldValues.toString());}
		_Item item := instancesDictionary[itemId];
		integer k;
		sequence<string> tmpFields := item.outputFields.clone(); // take a copy of the current values
		for k in dvdelta.fieldValues.keys() {
			if (k<0 or k>=NUM_FIELDS) then {
				string msg := "DataView updateItemDelta ignored - Invalid field index provided ("+k.toString()+") in the delta field values: "+dvdelta.fieldValues.toString();
				warn("updateDeltaDataViewItem() - \""+dvName+"\" - " + msg);					
				route DataViewItemException(dvdelta.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;
			}
			// no need to check for duplicate indexs, as we're getting them out of a dictionary - by definition there can't be duplicate keys!

			tmpFields[k] := dvdelta.fieldValues[k]; // overwrite a specific value with a new value
		}
		
		// IMPORTANT
		// check we have not altered a keyField value if this DataView is configured for their use!!
		if (0<compoundKeyIndexes.size()) then {
			string existingCompoundKey := buildCompoundKeyFromSeq(item.outputFields);
			if (0=compoundKey.length()) then {
				compoundKey := buildCompoundKeyFromSeq(tmpFields);
			}
			if not (compoundKey=existingCompoundKey) then {
				string msg := "DataView updateItemDelta ignored - It is not permitted to change the value of a keyField. The supplied values were: "+dvdelta.fieldValues.toString();
				warn("updateDeltaDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - routing DataViewItemException event - "+msg);
				route DataViewItemException(dvdelta.msgId, dvName, itemId, msg, new dictionary<string,string>);

				if (LOG_DEBUG) then {debug("updateDeltaDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - existing compoundKey: \""+existingCompoundKey+"\", new compoundKey: \""+compoundKey+"\"");}

				return;				
			}
		}

		// Now we can make the change to the actual stored values
		item.outputFields := tmpFields; // replace with the new updated set
		
		if (LOG_DEBUG) then {debug("updateDeltaDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - routing an Update event with the following field values: "+item.outputFields.toString());}
		float timeStamp := dvdelta.timeStamp;
		if (-1.0=timeStamp) then {
			timeStamp:=currentTime;
		}
		updater.emitUpdate_time(item.scenarioInstanceId, timeStamp, item.outputFields, item.owner);
	}

	
	//===================================================================================

	
	
	// The ACKs and NACKs for the Scenario API and the Scenario Bridge API.	
	action emitAcknowledgement(integer messageId, _Item item) {
		updater.emitAcknowledgement(messageId, item.scenarioInstanceId, item.outputFields);
	}

	action emitNack(integer messageId, integer scenarioInstanceId) {
		updater.emitNack(messageId, scenarioInstanceId);
	}


	
	////////////////////////////////////////////////////////////////////////////
	
	/** Initialise the listeners to enable dynamic changing of the log level.
	 * @param category The logging category that we are interested in.
	 */
	action initLogging(string category) {
		SetLogLevel config;
		on all SetLogLevel(category=category):config {
			LOG_DEBUG := false;
			LOG_INFO := false;
			LOG_WARN := false;
			LOG_ERROR := false;

			if (config.level="ERROR") then {
				LOG_ERROR:=true;
			}
			else if (config.level="WARN") then {
				LOG_WARN:=true;
				LOG_ERROR:=true;
			}
			else if (config.level="INFO") then {
				LOG_INFO:=true;
				LOG_WARN:=true;
				LOG_ERROR:=true;
			}
			else if (config.level="DEBUG") then {
				LOG_DEBUG:=true;
				LOG_INFO:=true;
				LOG_WARN:=true;
				LOG_ERROR:=true;
			}
			else {
				// All logging is turned OFF for this category
			}
		} // on all SetLogLevel
	} // action initLogging
	

	action debug(string msg) {
		if (LOG_DEBUG) then {
			log "[DEBUG] " + msg at INFO;
		}
	}
	
	action info(string msg) {
		if (LOG_INFO) then {
			log "[INFO]  " + msg at INFO;
		}
	}
	
	action warn(string msg) {
		if (LOG_WARN) then {
			log "[WARN]  " + msg at WARN;
		}
	}
	
	action error(string msg) {
		if (LOG_ERROR) then {
			log "[ERROR]  " + msg at ERROR;
		}
	}

}
 0000003e C:\SoftwareAG\Apama 5.1\monitors\DataViewService_Impl_Dict.mon
RMDT 00000015 &INPUT(1,2,true,true)
TIME 0000000e 1444006032.8,1
MONF 0000ae84 /*
 * $Copyright (c) 2012 Progress Software Corporation and/or its subsidiaries and affiliates. All rights reserved.$ 
 * $Copyright (c) 2013 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or Terracotta Inc., San Francisco, CA, USA, and/or Software AG (Canada) Inc., Cambridge, Ontario, Canada, and/or, Software AG (UK) Ltd., Derby, United Kingdom, and/or Software A.G. (Israel) Ltd., Or-Yehuda, Israel and/or their licensors.$ 
 * Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG 
 *
 * Event definitions for the Correlator-integrated Apama JMS adapter. 
 *
 * $Revision: 215887 $
 *
 */
package com.apama.correlator.jms;


// *****************************************************************************
// 
// Private event definitions - for internal use only. 
//

/** @private*/ event __AddSender
{
	string connectionId;
	string senderId;
	string senderReliability;
	dictionary<string,string> extraAddParams;
}

/** @private*/ event __RemoveSender
{
	string senderId;
}

/** @private*/ event __AddReceiver
{
	string connectionId;
	string receiverId;
	string destination;
	string receiverReliability;
	string durableTopicSubscriptionName;
	string messageSelector;
	boolean noLocal;
	dictionary<string,string> extraAddParams;
}

/** @private*/ event __RemoveReceiver
{
	string receiverId;
}

/** @private*/ event __JMSReceiverFlowControlWindowUpdate
{
	string receiverId;
	integer __processInstanceToken;
	integer __flowControlMarker;
	integer __flowControlWindow;
}

// *****************************************************************************
// 
// Public event API for dynamically adding/removing JMS senders and receivers
//
// To be notified about the successful addition or removal of senders and 
// receivers, applications should listen for the separate Sender/ReceiverStatus 
// events, looking for the OK or REMOVED status. 
//

/** An enumeration containing constants for the currently supported sender 
	reliability values.
*/
event JMSSenderReliability
{
	/** Best effort non-reliable messaging; events may be lost or duplicated 
		if a component fails. */
	constant string BEST_EFFORT := "BEST_EFFORT";
	/** Reliable messaging without duplicate detection. 
	
		Events may be  duplicated or reordered if a component fails, but will 
		not be lost. */
	constant string AT_LEAST_ONCE := "AT_LEAST_ONCE";
	/** Reliable messaging with duplicate detection identifiers. 
	
		Events may be reordered if a component fails, but will not be lost, 
		and will not be duplicated if the unique message ids are mapped into 
		the message and the receiving JMS client uses an appropriate duplicate 
		detection window. */
	constant string EXACTLY_ONCE := "EXACTLY_ONCE";
}

/** An event object representing an existing JMS sender. 
 *
 * A sender can be used to handle emitted Apama events to a Correlator channel, 
 * mapping them to JMS messages using the requested message reliability 
 * setting and sending them to any destination on the JMS message bus. 
 */
event JMSSender
{
	// Public
	
	/** Returns the unique identifier of this sender. */
	action getSenderId() returns string { return __senderId; }
	
	/** Returns the Correlator channel to use for emitting events that should 
	 * be sent to JMS using this sender. 
	 *
	 * Note that if this senderId does not exist or has been removed then 
	 * events sent to this channel will be lost without a warning. 
	 */
	action getChannel() returns string { return __channel; }
	
	/** Requests removal of this JMS sender. The removal will be performed 
	 * asynchronously, and completes after all events already emitted from this 
	 * context have been passed to JMS, and the associated JMS producer and 
	 * session have been closed. 
	 *
	 * EPL applications may listen for the REMOVED JMSSenderStatus event to 
	 * detect when the removal has completed. 
	 *
	 * If the connection is currently down there could be an unbounded delay 
	 * in completing the removal of the sender. The application should not 
	 * emit any more events to the sender once this action has been called. 
	 *
	 * It is an error to attempt to remove a JMS sender that does not exist, or 
	 * to attempt to remove a static JMS sender. Such errors will result in 
	 * the termination of the current EPL monitor instance. 
	 * 
	 * @see JMSSenderStatus#REMOVED
	 */
	action remove()
	{
		__plugin.processControlEvent(__RemoveSender(__senderId).toString());
	}

	/** Returns the number of events that have been emitted to this sender from 
	 * EPL, but are still queued waiting to be sent to JMS.
	 *
	 * This allows an EPL application to throttle or reduce the rate at which 
	 * it sends events based on the size of the backlog building up in the 
	 * Correlator's queues, to ensure that the Correlator does not run out of 
	 * memory due to a temporary peak in throughput rate or loss of the JMS 
	 * connection. 
	 *
	 * Calling this action is a slightly expensive operation, so it is best to 
	 * get the number of outstanding events once, then loop sending a batch of 
	 * events. Therefore do not call getOutstandingEvents inside a loop that is 
	 * continually sending events to JMS. 
	 *
	 * You must not call this method after calling remove().
	 */
	action getOutstandingEvents() returns integer
	{
		return __plugin.getOutstandingMessages(__senderId);
	}
	
	// Private
	
	/** @private*/ string __senderId;
	/** @private*/ string __channel;
	/** @private*/ import "JMSPlugin" as __plugin;

}

/** An event object representing the configuration of a new JMS sender, for 
 * dynamically adding JMS senders at runtime. 
 *
 * Call JMSConnection.createSenderConfiguration() to create an instance, and 
 * then use the setter actions to specify each required configuration option. 
 * Each setter method returns this configuration instance to make it possible 
 * to chain calls and specify all required options in a single statement. 
 *
 * @see JMSConnection#createSenderConfiguration() Creates a new 
 *	JMSSenderConfiguration event object. 
 * @see JMSConnection#addSenderWithConfiguration() Uses a JMSSenderConfiguration 
 *	to add a new JMS sender. 
 */
event JMSSenderConfiguration
{
	/** The unique identifier of this sender. */
	action getSenderId() returns string
	{ return __senderId; }

	/** The identifier of the connection this sender belongs to. */
	action getConnectionId() returns string
	{ return __connectionId; }
	
	/** Specifies the reliability mode to use for messages from this sender. 
	 * @param value Must be one of the enumeration constants from the 
	 * JMSSenderReliability event, or "" to indicate that the connection's 
	 * defaultSenderReliability should be used. 
	 * @see JMSSenderReliability
	 */
	action setSenderReliability(string value) returns JMSSenderConfiguration
	{ __senderReliability := value; return self; }
	/** Specifies the reliability mode to use for messages from this sender. */
	action getSenderReliability() returns string
	{ return __senderReliability; }
	

	// Private fields
	
	/** @private*/ string __connectionId;
	/** @private*/ string __senderId;
	/** @private*/ string __senderReliability;
	
	/** Initializes this object with required parameters 
	 * @private*/ 
	action __init(string connectionId, string senderId) 
	{
		self.__connectionId := connectionId;
		self.__senderId := senderId;
	}
	
	/** @private*/ 
	action __getAddSender() returns __AddSender
	{
		return __AddSender(
			getConnectionId(), 
			getSenderId(), 
			getSenderReliability(), 
			new dictionary<string,string>
			);
	}
}


/** An enumeration containing constants for the currently supported receiver 
	reliability values.
*/
event JMSReceiverReliability
{
	/** Best effort non-reliable messaging; events may be lost or duplicated 
		if a component fails. */
	constant string BEST_EFFORT := "BEST_EFFORT";
	/** Reliable messaging without duplicate detection; events may be 
		duplicated or reordered if a component fails, but will not be lost. */
	constant string AT_LEAST_ONCE := "AT_LEAST_ONCE";
	/** Reliable messaging with duplicate detection; events may be 
		reordered if a component fails, but will not be lost, and will not be 
		duplicated provided the unique message ids and duplicate detection 
		window are configured correctly. */
	constant string EXACTLY_ONCE := "EXACTLY_ONCE";
}

/** An event object representing an existing JMS receiver. 
 *
 * A receiver listeners for messages on a specific JMS queue or topic, maps 
 * them to Apama events and sends them to the Correlator's public contexts. 
 */
event JMSReceiver
{
	// Public
	
	/** Returns the unique identifier of this receiver. */
	action getReceiverId() returns string { return __receiverId; }
	
	
	/** Requests removal of this JMS receiver. 
	 *
	 * The removal will be performed asynchronously, and completes after all 
	 * events already received from this JMS destination have been enqueued to 
	 * the Correlator, any persisted uniqueMessageIds no longer required for 
	 * duplicate detection have been deleted, any durable topic subscription 
	 * has been removed from the JMS broker, and the associated JMS consumer 
	 * and session have been closed. 
	 *
	 * EPL applications may listen for the REMOVED JMSReceiverStatus event to 
	 * detect when the removal has completed. 
	 *
	 * If the connection is currently down there could be an unbounded delay 
	 * in completing the removal of the receiver. 
	 *
	 * It is an error to attempt to remove a JMS receiver that does not exist, 
	 * or to attempt to remove a static JMS receiver. Such errors will result 
	 * in the termination of the current EPL monitor instance. 
	 * 
	 * @see JMSReceiverStatus#REMOVED
	 */
	action remove()
	{
		__plugin.processControlEvent(__RemoveReceiver(__receiverId).toString());
	}
	
	// Private
	
	/** @private*/ string __receiverId;
	/** @private*/ import "JMSPlugin" as __plugin;

}

/** An event object representing the configuration of a new JMS receiver, for 
 * dynamically adding JMS receivers at runtime. 
 *
 * Call JMSConnection.createReceiverConfiguration() to create an instance, and 
 * then use the setter actions to specify each required configuration option. 
 * Each setter method returns this configuration instance to make it possible 
 * to chain calls and specify all required options in a single statement. 
 *
 * @see JMSConnection#createReceiverConfiguration() Creates a new 
 *	JMSReceiverConfiguration event object. 
 * @see JMSConnection#addReceiverWithConfiguration() Uses a 
 *	JMSReceiverConfiguration to add a new JMS receiver. 
 */
event JMSReceiverConfiguration
{
	/** The unique identifier of this receiver. */
	action getReceiverId() returns string
	{ return __receiverId; }

	/** The identifier of the connection this receiver belongs to. */
	action getConnectionId() returns string
	{ return __connectionId; }
	
	/** The queue or topic this receiver will listen to. */
	action getDestination() returns string
	{ return __destination; }
	
	/** Specifies the reliability mode to use for receiving messages. 
	 * @param value Must be one of the enumeration constants from the 
	 *	JMSReceiverReliability event, or "" to indicate that the connection's 
	 *	defaultReceiverReliability should be used. 
	 * @see JMSReceiverReliability
	 */
	action setReceiverReliability(string value) returns JMSReceiverConfiguration
	{ __receiverReliability := value; return self; }
	/** Specifies the reliability mode to use for receiving messages. */
	action getReceiverReliability() returns string
	{ return __receiverReliability; }
	
	/** Specifies the unique identifier for the subscription if a durable topic 
	 * subscription is to be created.
	 * @param value A unique JMS subscription name if a durable topic 
	 *	subscription should be created, or "" if a non-durable topic 
	 *	subscription should be made. Only valid for topics, and only if the 
	 *	reliability is not BEST_EFFORT.
	 */
	action setDurableTopicSubscriptionName(string value) returns JMSReceiverConfiguration
	{ __durableTopicSubscriptionName := value; return self; }
	/** Specifies the unique identifier for the subscription if a durable topic 
	 * subscription is to be created. */
	action getDurableTopicSubscriptionName() returns string
	{ return __durableTopicSubscriptionName; }

	/** Specifies the JMS message selector query string to select a subset of 
	 * queue/topic messages to be processed by this receiver. 
	 * @param value A message selector string, or "" to receive all messages. 
	 * See the JMS documentation for the javax.jms.Message interface for more 
	 * details. 
	 */
	action setMessageSelector(string value) returns JMSReceiverConfiguration
	{ __messageSelector := value; return self; }
	/** Specifies the JMS message selector query string to select a subset of 
	 * queue/topic messages to be processed by this receiver. */
	action getMessageSelector() returns string
	{ return __messageSelector; }

	/** Specifies an application-defined identifier to override how receivers 
	 * are grouped together for duplicate-detection purposes when using 
	 * EXACTLY_ONCE reliability. 
	 * @param value An arbitrary (but preferably short) string defined by the 
	 *	EPL application. All EXACTLY_ONCE receivers with this string will be 
	 *	grouped together to form a single duplicate detection domain. 
	 *
	 *	This is an advanced feature - by default, receivers are grouped into 
	 *	a duplicate detection domain together with other receivers in the 
	 *	same connectionId listening to the same destination, which is the 
	 *	correct setting in the majority of cases. 
	 */
	action setDupDetectionDomainId(string value) returns JMSReceiverConfiguration
	{ __dupDetectionDomainId := value; return self; }
	/** Specifies an application-defined identifier to override how receivers 
	 * are grouped together for duplicate-detection purposes when using 
	 * EXACTLY_ONCE reliability. */
	action getDupDetectionDomainId() returns string
	{ return __dupDetectionDomainId; }

	/** Specifies that messages sent to this destination by our own connection 
	 * should be ignored by the receiver. 
	 * @param value May be set to true or false for topic destinations. If 
	 *	the destination is a queue, the behaviour of noLocal=true is not 
	 *	specified, and will not work with many providers. The default value of 
	 *	false is usually fine. 
	 */
	action setNoLocal(boolean value) returns JMSReceiverConfiguration
	{ __noLocal := value; return self; }
	/** Specifies that messages sent to this destination by our own connection 
	 * should be ignored by the receiver. */
	action getNoLocal() returns boolean
	{ return __noLocal; }
	
	// Private fields
	
	/** @private*/ string __connectionId;
	/** @private*/ string __receiverId;
	/** @private*/ string __destination;
	/** @private*/ string __receiverReliability;
	/** @private*/ string __durableTopicSubscriptionName;
	/** @private*/ string __messageSelector;
	/** @private*/ string __dupDetectionDomainId;
	/** @private*/ boolean __noLocal;
	
	
	/** Initializes this object with required parameters 
	 * @private*/ 
	action __init(string connectionId, string receiverId, string destination) 
	{
		self.__connectionId := connectionId;
		self.__receiverId := receiverId;
		self.__destination := destination;
	}
	/** Initializes this object with required parameters 
	 * @private*/ 
	action __getAddReceiver() returns __AddReceiver
	{
		__AddReceiver result := new __AddReceiver;
		result.connectionId := getConnectionId();
		result.receiverId := getReceiverId();
		result.destination := getDestination();
		result.receiverReliability := getReceiverReliability();
		result.durableTopicSubscriptionName := getDurableTopicSubscriptionName();
		result.messageSelector := getMessageSelector();
		result.noLocal := getNoLocal();
		if getDupDetectionDomainId() != "" then { result.extraAddParams["dupDetectionDomainId"] := getDupDetectionDomainId(); }
		
		return result;
	}
}

/** An event object representing a JMS connection, with actions for 
 * manipulating a connection's existing senders and receivers, and also for 
 * dynamically adding senders and receivers at runtime. 
 *
 * Senders and receivers may be added dynamically either using the 
 * comprehensive JMSConnection.addReceiver/SenderWithConfiguration() actions 
 * which provide access to all configuration parameters, or one of the 
 * other addReceiver/Sender*() actions that simplify creation of 
 * senders/receivers using the more common configuration parameter sets. 
 *
 * @see JMS#getConnection() Use this method to get a JMSConnection
 */
event JMSConnection
{
	// Public
	
	/** The unique identifier of this connection. */
	action getConnectionId() returns string 
	{
		return __connectionId;
	}

	/** Get a JMSReceiver event object representing a receiver that already 
	 * exists, which might have been added dynamically, or defined statically 
	 * in the XML configuration file. 
	 *
	 * It is the caller's responsibility to specify a valid receiverId - the  
	 * specified identifier is not be validated as part of this action call. 
	 * If the identifier does not represent an existing receiver then 
	 * operations on the returned JMSReceiver (such as remove()) will cause an 
	 * error. 
	 */
	action getReceiver(string receiverId) returns JMSReceiver { return JMSReceiver(receiverId); }
	
	/** Get a JMSSender event object representing a sender that already 
	 * exists, which might have been added dynamically, or defined statically 
	 * in the XML configuration file. 
	 *
	 * It is the caller's responsibility to specify a valid senderId - the  
	 * specified identifier is not be validated as part of this action call. 
	 * If the identifier does not represent an existing sender then 
	 * operations on the returned JMSSender (such as remove()) will cause an 
	 * error. 
	 */
	action getSender(string senderId) returns JMSSender { return JMSSender(senderId, "jms:"+senderId); }

	/** Get a JMSSender event object representing the default sender for this 
	 * connection (which exists automatically if no other static senders 
	 * were explicitly configured). 
	 */
	action getDefaultSender() returns JMSSender { return getSender(__connectionId+"-default-sender"); }

	
	/** Requests the addition of a new dynamic JMS sender, with the specified 
	 * reliability setting. 
	 *
	 * EPL applications may listen for the JMSSenderStatus event to be notified 
	 * when the new sender has been added, and when it has reached the 
	 * "OK" state. Events can be emitted to the sender's channel as soon as 
	 * this action returns. 
	 *
	 * A unique senderId will be generated automatically. 
	 *
	 * The monitor instance will usually be terminated with an ERROR if invalid 
	 * arguments are provided. 
	 *
	 * @param senderReliability An enumeration value from JMSSenderReliability 
	 * indicating the reliability setting to use for sending events. 
	 * Alternatively, specify an empty string "" to use the connection's 
	 * defaultSenderReliability. 
	 *
	 * @return A JMSSender instance which can be used to get the senderId for 
	 * status monitoring, the channel to emit events to, and an action for 
	 * removing the sender when it is no longer required. 
	 * @see JMSSenderReliability
	 */
	action addSender(string senderReliability) returns JMSSender
	{
		return addSenderWithConfiguration(createSenderConfiguration(__makeUniqueId("sender", senderReliability))
			.setSenderReliability(senderReliability));
	}
	
	
	/** Requests the addition of a new dynamic JMS sender, with the specified 
	 * sender configuration. 
	 *
	 * EPL applications may listen for the JMSSenderStatus event to be notified 
	 * when the new sender has been added, and when it has reached the 
	 * "OK" state. Note that no events will actually be sent into the 
	 * Correlator until JMS.onApplicationInitialized() has been called. 
 	 *
	 * The monitor instance will usually be terminated with an ERROR if invalid 
	 * arguments are provided. 
	 *
	 * @param config An event representing the configuration of the new sender, 
	 * constructed using JMSConnection.createSenderConfiguration and the 
	 * setter methods on JMSSenderConfiguration.
	 *
	 * @return A JMSSender instance which can be used to get the senderId for 
	 * status monitoring, the channel to emit events to, and an action for 
	 * removing the sender when it is no longer required. 
	 *
	 * @see JMSConnection#createSenderConfiguration()
	 */
	action addSenderWithConfiguration(JMSSenderConfiguration config) returns JMSSender
	{
		__plugin.processControlEvent(config.__getAddSender().toString());
		return getSender(config.getSenderId());
	}
	
	/** Create a JMSSenderConfiguration for this connection that can be 
	 * used to add a new sender with the specified settings. 
	 *
	 * @param senderId An application-defined unique identifier for this 
	 * sender, used to track status and removal. The senderId must not be an 
	 * empty string or contain the colon ":" character - if it does, the 
	 * monitor will terminate with an error when trying to create the sender.
	 *
	 * Applications are encouraged to use <tt>integer.getUnique().toString()</tt> 
	 * or a similar generator of unique numbers for all or part of the senderId. 
	 *
	 * @see JMSConnection#addSenderWithConfiguration()
	 */
	action createSenderConfiguration(string senderId) returns JMSSenderConfiguration
	{
		JMSSenderConfiguration result := new JMSSenderConfiguration;
		result.__init(__connectionId, senderId);
		return result;
	}

	/** Requests the addition of a new dynamic JMS receiver, with the specified 
	 * queue/topic name and reliability setting. 
	 *
	 * EPL applications may listen for the JMSReceiverStatus event to be 
	 * notified when the new receiver has been added, and when it has reached 
	 * the "OK" state. 
	 *
	 * A unique receiverId will be generated automatically. 
	 *
	 * The monitor instance will usually be terminated with an ERROR if invalid 
	 * arguments are provided. 
	 *
	 * @param destination A JMS queue name, JMS topic name, or JNDI name, 
	 *	prefixed by <tt>"queue:"</tt>, <tt>"topic:"</tt> or <tt>"jndi:"</tt>.
	 
	 * @param receiverReliability An enumeration value from 
	 *	JMSReceiverReliability indicating the reliability setting to use. 
	 *	Alternatively, specify an empty string "" to use the connection's 
	 *	defaultReceiverReliability. 
	 *
	 * @return A JMSReceiver instance which can be used to get the receiverId 
	 *	for status monitoring, and an action for removing the receiver when it 
	 *	is no longer required. 
	 * @see JMSReceiverReliability
	 */
	action addReceiver(string destination, string receiverReliability) returns JMSReceiver
	{
		return addReceiverWithConfiguration(
			createReceiverConfiguration(__makeUniqueId("receiver", destination), destination)
			.setReceiverReliability(receiverReliability));
	}

	/** Requests the addition of a new dynamic JMS durable topic subscription. 
	 *
	 * EPL applications may listen for the JMSReceiverStatus event to be 
	 * notified when the new receiver has been added, and when it has reached 
	 * the "OK" state. 
	 *
	 * This durable topic subscription will remain on the JMS broker until this 
	 * dynamic receiver is removed using JMSReceiver.remove(). 
	 *
	 * A unique receiverId will be generated automatically. 
	 *
	 * The monitor instance will usually be terminated with an ERROR if invalid 
	 * arguments are provided. 
	 *
	 * @param destination A JMS topic name, or JNDI name, 
	 *	prefixed by <tt>"topic:"</tt> or <tt>"jndi:"</tt>.
	 *
	 * @param receiverReliability An enumeration value from 
	 *	JMSReceiverReliability indicating the reliability setting to use.
	 
	 *	For a durable topic subscription, this must not be BEST_EFFORT.  
	 *	Specify an empty string "" to use the connection's 
	 *	defaultReceiverReliability. 
	 *
	 * @param durableTopicSubscriptionName The unique identifier used by the 
	 *	JMS broker for for this durable topic subscription. 
	 *
	 *	Must not be "", and must not match any other subscription name with the 
	 *	same connection clientID. 
	 *
	 * @param messageSelector An optional JMS message selector query string to 
	 *	select a subset of topic messages to be processed by this receiver, or 
	 *	"" to receive all messages. 
	 *
	 *	See the JMS documentation for the javax.jms.Message interface for more 
	 *	details. 

	 * @return A JMSReceiver instance which can be used to get the receiverId 
	 *	for status monitoring, and an action for removing the receiver when it 
	 *	is no longer required. 
	 * @see JMSReceiverReliability
	 * @see JMSReceiver#remove()
	 */
	action addReceiverWithDurableTopicSubscription(string destination, string receiverReliability, 
		string durableTopicSubscriptionName, string messageSelector) returns JMSReceiver
	{
		return addReceiverWithConfiguration(
			createReceiverConfiguration(__makeUniqueId("durable-subscriber", durableTopicSubscriptionName), destination)
			.setReceiverReliability(receiverReliability)
			.setMessageSelector(messageSelector)
			.setDurableTopicSubscriptionName(durableTopicSubscriptionName)
			);
	}

	/** Requests the addition of a new dynamic JMS receiver, with the specified 
	 * receiver configuration. 
	 *
	 * EPL applications may listen for the JMSReceiverStatus event to be 
	 * notified when the new receiver has been added, and when it has reached 
	 * the "OK" state. 
	 *
	 * The monitor instance will usually be terminated with an ERROR if invalid 
	 * arguments are provided. 
	 *
	 * @param config An event representing the configuration of the new 
	 * receiver, constructed using JMSConnection.createReceiverConfiguration 
	 * and the setter methods on JMSReceiverConfiguration.
	 *
	 * @return A JMSReceiver instance which can be used to get the receiverId 
	 * for status monitoring, and an action for removing the receiver when it 
	 * is no longer required. 
	 *
	 * @see JMSConnection#createReceiverConfiguration()
	 */
	action addReceiverWithConfiguration(JMSReceiverConfiguration config) returns JMSReceiver
	{
		__plugin.processControlEvent(config.__getAddReceiver().toString());
		return getReceiver(config.getReceiverId());
	}
	
	/** Create a JMSReceiverConfiguration for this connection that can be 
	 * used to add a new receiver with the specified settings. 
	 *
	 * @param receiverId An application-defined unique identifier for this 
	 * receiver, used to track status and removal. The receiverId must not be an 
	 * empty string or contain the colon ":" character - if it does, the 
	 * monitor will terminate with an error when trying to create the receiver.
	 *
	 * Applications are encouraged to use <tt>integer.getUnique().toString()</tt> 
	 * or a similar generator of unique numbers for all or part of the receiverId. 
	 *
	 * @param destination A JMS queue name, JMS topic name, or JNDI name, 
	 * prefixed by <tt>"queue:"</tt>, <tt>"topic:"</tt> or <tt>"jndi:"</tt>.
	 *
	 * @see JMSConnection#addReceiverWithConfiguration()
	 */
	action createReceiverConfiguration(string receiverId, string destination) returns JMSReceiverConfiguration
	{
		JMSReceiverConfiguration result := new JMSReceiverConfiguration;
		result.__init(__connectionId, receiverId, destination);
		return result;
	}
	
	// Private
	
	/** @private*/ string __connectionId;
	/** @private*/ import "JMSPlugin" as __plugin;
	
	/** @private*/ 
	action __makeUniqueId(string requiredSuffix, string optionalSuffix) returns string {
		string result := __connectionId+"-"+requiredSuffix;
		if optionalSuffix != "" then {
			result := result+"-"+optionalSuffix;
		}
		result := result.replaceAll(":","-"); // ensure it's a valid identifier
		return result + "-" + integer.getUnique().toString();
	}
	
}

/** The top-level event object representing the Correlator-integrated JMS 
 * runtime.
 */
event JMS
{
	// Public
	
	/** Should be called by EPL applications after all EPL has been injected 
	 * and initialized, to indicate that the application is ready to receive 
	 * events from the JMS runtime, such as received JMS messages and 
	 * status notification events. 
	 *
	 * Invoking this action more than once will have no effect. 
	 *
	 */
	action onApplicationInitialized() 
	{
		__plugin.onApplicationInitialized();
	}
	
	/** Get a JMSConnection event object representing a connection defined  
	 * in the XML configuration file. 
	 */
	action getConnection(string connectionId) returns JMSConnection
	{
		return JMSConnection(connectionId);
	}
	
	/** Get a JMSReceiver event object representing a receiver that already 
	 * exists, which might have been added dynamically, or defined statically 
	 * in the XML configuration file. 
	 *
	 * It is the caller's responsibility to specify a valid receiverId - the  
	 * specified identifier is not be validated as part of this action call. 
	 * If the identifier does not represent an existing receiver then 
	 * operations on the returned JMSReceiver (such as remove()) will cause an 
	 * error. 
	 */
	action getReceiver(string receiverId) returns JMSReceiver { return (new JMSConnection).getReceiver(receiverId); }
	
	/** Get a JMSSender event object representing a sender that already 
	 * exists, which might have been added dynamically, or defined statically 
	 * in the XML configuration file. 
	 *
	 * It is the caller's responsibility to specify a valid senderId - the  
	 * specified identifier is not be validated as part of this action call. 
	 * If the identifier does not represent an existing sender then 
	 * operations on the returned JMSSender (such as remove()) will cause an 
	 * error. 
	 */
	action getSender(string senderId) returns JMSSender { return (new JMSConnection).getSender(senderId); }
	
	// Private
	
	/** @private*/ import "JMSPlugin" as __plugin;
}


//*****************************************************************************
//
// Status events
//

/** 
 * A notification event sent to an EPL application when a configured JMS 
 * connection encounters an error or changes state. 
 *
 * This event includes string constants for each supported status. 
 *
 * Note that all notification events will be held back until 
 * JMS.onApplicationInitialized() has been called. 
 */
event JMSConnectionStatus
{
	/** The unique identifier of the JMS connection. 
	*/
	string connectionId;

	/** An enumeration value specifying the status of the connection. The 
	 * values in the enumeration are provided as constants in this event. 
	 *
	 * If the status is OK then the connection is up. 
	 */
	string status;
	
	/** A user-readable string specifying the cause of the error. This should 
		always be a non-empty string when the status is "ERROR". */
	string errorMessage;
	
	/** Additional status information items. None are currently supported. */
	dictionary<string,string> extraStatusInfo;
	
	// enumeration constants for status field value:
	
	/** The status value indicating that the Correlator-JMS runtime is fully 
		connected to the JMS broker with a valid JMS Connection object. */
	constant string OK := "OK";
	
	/** The status value indicating that the Correlator-JMS runtime is trying
		to establish an initial connection.  */
	constant string CONNECTING := "CONNECTING";

	/** The status value indicating that the connection is not available due to 
		some non-fatal error condition; the Correlator-JMS runtime will keep 
		retrying in the background. */
	constant string ERROR := "ERROR";
}

/** 
 * A notification event sent to an EPL application when a configured JMS 
 * sender has been created successfully, encounters an error, or is removed. 
 *
 * This event includes string constants for each supported status, and 
 * fields specifying information about the configuration of this sender
 * (as specified when it was created). 
 *
 * Note that all notification events will be held back until 
 * JMS.onApplicationInitialized() has been called. 
 *
 * JMSSenderStatus events are sent for both static senders in the 
 * configuration file (or the implicitly defined default sender), and 
 * dynamic senders created with JMSConnection.addSender.
 */
event JMSSenderStatus
{
	/** The unique identifier of the JMS connection. 
	*/
	string connectionId;

	/** The unique identifier of this sender. 
	*/
	string senderId;

	/** An enumeration value specifying the status of the sender. The values
	 * in the enumeration are provided as constants in this event. 
	 *
	 * If the status is OK then the sender is functioning correctly; if it 
	 * is REMOVED then removal of the sender has completed.  
	 */
	string status;
	
	/** A user-readable string specifying the cause of the error. This is 
	 * guaranteed not empty if status="ERROR" or "FATAL_ERROR". */
	string errorMessage;
	
	/** Additional status information items. None are currently supported. */
	dictionary<string,string> extraStatusInfo;
	
	// enumeration constants for status field value:
	
	/** The status value indicating that the sender is fully connected to the 
		JMS broker with a valid JMS Producer object, and is available to send 
		messages. */
	constant string OK := "OK";
	
	/** The status value indicating that the sender is waiting for the 
		JMS connection or sender session to be established. */
	constant string CONNECTING := "CONNECTING";
	/** The status value indicating that the sender is not available due to 
		some non-fatal error condition; the Correlator-JMS runtime will keep 
		retrying in the background. */
	constant string ERROR := "ERROR";
	
	/** The status value indicating that the sender is not available due to 
		a fatal error condition. 
		
		Senders in this state are no longer useful and should be removed by the 
		EPL application (if dynamic) or the system administrator (if statically 
		defined in the XML config file). Note that the removal of such failed 
		senders does not happen automatically. */
	constant string FATAL_ERROR := "FATAL_ERROR";
	/** The status value indicating that the removal of a dynamic sender has 
		been completed, which will be sent some time after a sender removal 
		request, once all the associated state on the broker and the 
		Correlator's database has been removed. 
		
		In rare cases it's possible that a status event for a sender may be 
		sent after the REMOVED status; any such event should be ignored.  */
	constant string REMOVED := "REMOVED";
	
	// fields specifying the sender's configuration:

	/** Sender quality of service, specifying the reliability mode of the 
		messages from this sender. 
		
		One of the enumeration constants from the JMSSenderReliability event. */
	string senderReliability;

	/** Additional sender configuration parameters specified when it was added. 
	*/
	dictionary<string,string> extraAddParams;

}

/** 
 * A notification event sent to an EPL application when a configured JMS 
 * receiver has been created successfully, encounters an error, or is removed. 
 *
 * This event includes string constants for each supported status, and 
 * fields specifying information about the configuration of this receiver
 * (as specified when it was created). 
 *
 * Note that the ordering of JMSReceiverStatus events relative to received 
 * messages is not defined. Also note that notification events will be held 
 * back until JMS.onApplicationInitialized() has been called. 
 *
 * JMSReceiverStatus events are sent for both static receivers in the 
 * configuration file, and dynamic receivers created with 
 * JMSConnection.addReceiver.
 */
event JMSReceiverStatus
{
	/** The unique identifier of the JMS connection.  */
	string connectionId;
	
	/** The unique identifier of this receiver. */
	string receiverId;

	/** An enumeration value specifying the status of the receiver. The values
	 * in the enumeration are provided as constants in this event. 
	 *
	 * If the status is OK then the receiver is functioning correctly; if it 
	 * is REMOVED then removal of the receiver has completed.  
	 */
	string status;
	
	/** A user-readable string specifying the cause of the error. This is 
	 * guaranteed not empty if status="ERROR" or "FATAL_ERROR". */
	string errorMessage;

	// enumeration constants for status field value:
	
	/** The status value indicating that the receiver is fully connected to the 
		JMS broker with a valid JMS Consumer object, and is available to receive 
		messages. */
	constant string OK := "OK";
	
	/** The status value indicating that the receiver is waiting for the 
		JMS connection or receiver session to be established. */
	constant string CONNECTING := "CONNECTING";
	/** The status value indicating that the receiver is not available due to 
		some non-fatal error condition; the Correlator-JMS runtime will keep 
		retrying in the background. */
	constant string ERROR := "ERROR";

	/** The status value indicating the  receiver could not be found because of 
		a problem accessing the specified destination (i.e. a JMS or JNDI 
		error). */
	constant string DESTINATION_NOT_FOUND := "DESTINATION_NOT_FOUND"; 	

	/** The status value indicating that the receiver is not available due to 
		a fatal error condition. 
		
		Receivers in this state are no longer useful and should be removed by 
		the EPL application (if dynamic) or the system administrator (if 
		statically defined in the XML config file). The removal of such failed 
		receivers does not happen automatically. 
	*/
	constant string FATAL_ERROR := "FATAL_ERROR";

	/** The status value indicating that the removal of a dynamic receiver has 
		been completed, which will be sent some time after a receiver removal 
		request, once all the associated state on the broker and the 
		Correlator's database has been removed. 
		
		In rare cases it's possible that a status event for a receiver may be 
		sent after the REMOVED status; any such event should be ignored.  */
	constant string REMOVED := "REMOVED";
	
	/** Additional status information items. None are currently supported. */
	dictionary<string,string> extraStatusInfo;

	// fields specifying the receiver's configuration:
	
	/** A JMS queue name, JMS topic name, or JNDI name, prefixed by 
		<tt>"queue:"</tt>, <tt>"topic:"</tt> or <tt>"jndi:"</tt>. */
	string destination;
	/** Receiver quality of service, specifying the reliability mode used 
		for receiving messages. 
		
		One of the enumeration constants from the JMSReceiverReliability event*/
	string receiverReliability;
	/** A unique JMS subscription name if a durable topic subscription should 
		be created, or "" if a non-durable topic subscription should be made. */
	string durableTopicSubscriptionName;
	/** JMS message selector string, to specify a subset of messages from the 
		destination to be processed by this receiver. 
	*/
	string messageSelector;
	/** Specifies that messages sent to this destination by our own connection 
		should be ignored by the receiver. */
	boolean noLocal;
	/** Additional receiver configuration parameters. None currently supported. */
	dictionary<string,string> extraAddParams;
}

//*****************************************************************************
//
// Advanced control events
//


/** A control event periodically sent to an EPL application for each receiver 
 * with receiverFlowControl enabled, which the application uses to update 
 * the flow control window.
 *
 * This event is used as a baseline from which the EPL application specifies 
 * the size of the window of new events it is currently ready to receive, 
 * specified relative to the last event received before this marker. 
 *
 * The event is sent:
 * i) when a receiver with receiverFlowControl=true is first added 
 * (once onApplicationInitialized has been called), 
 * ii) during recovery (in a persistent correlator), and 
 * iii) also periodically as JMS messages are received and 
 * enqueued to the correlator (typically these events are sent as often as 
 * the configured maxBatchSize, e.g. at least once every 1000 events). 
 *
 * To correctly implement the receiver flow control protocol, applications must 
 * respond to this event by calling updateFlowControlWindow (see below) 
 * to indicate the maximum number of additional events that the JMS runtime 
 * should take from this receiver, using the point in the event stream at 
 * which this marker was received as the baseline. 
 *
 * Applications that wish to  use flow control to throttle message receiving 
 * based on the number of outstanding asynchronous operations from 
 * already-received messages (to put a finite bound on memory usage) should 
 * also cache the most recent JMSReceiverFlowControlMarker for each 
 * active JMSReceiver so that the flow control window can be updated 
 * (e.g. extended) as pending operations complete, since there is no guarantee 
 * another JMSReceiverFlowControlMarker event will be sent until the window 
 * is extended enough for more events to be received. 
 *
 * Note that the fields of this event (apart from receiverId) are intended as 
 * 'opaque' data for internal use only and should be ignored by customer code.
 *
 * @see JMSReceiverFlowControlMarker#updateFlowControlWindow() Set the flow 
 * control window for this receiver, relative to this marker. 
 */ 
event JMSReceiverFlowControlMarker
{
	/** The unique identifier of this receiver. */
	string receiverId;
	
	/** For internal use only, treat as opaque data. */ 
	integer __processInstanceToken;
	
	/** For internal use only, treat as opaque data. */ 
	integer __flowControlMarker;
	
	/**
	* Sets the current flow control window size for a given receiver, which 
	* indicates the number of extra Apama events that should be taken from JMS 
	* and passed to the application before blocking, relative to the last data 
	* event received before this marker. 
	*
	* @param windowSizeEvents The maximum number of new events that should be 
	* received from this JMS receiver and enqueued to the correlator, relative 
	* to the position in the event flow indicated by this marker. 
	* The window size may be a constant number (e.g. 10,000 events) for 
	* applications that immediately process received events to completion,
	* or it may have a number of 'pending' events subtracted from it to create 
	* a bound on on the number of events that may be received from the JMS 
	* broker but are not yet been fully processed by the application (e.g. if 
	* an asynchronous database operation must complete before the memory, data 
	* structures or event listeners associated with the event may be deleted).
	*
	* It is valid to supply a zero or negative number for this value, in which 
	* case the JMS runtime will attempt to pause receiving, and take no more 
	* messages from the JMS queue/topic until this action is called again 
	* with a positive window (though it is not possible to guarantee that the 
	* flow of events will stop immediately, since some events could already be 
	* queued up). To allow an unbounded number of events to be received, 
	* specify integer.MAX for windowSizeEvents.
	* 
	* It is important that the overall long-term maximum window size 
	* (i.e. the chosen constant upper bound, ignoring any currently pending 
	* operations) is greater than than the receiver's maxBatchSize 
	* (typically 1000). 
	*/
	action updateFlowControlWindow(integer windowSizeEvents)
	{
		// use 'UnlessDisabled' as this should be a no-op when JMS is disabled, to support replay log
		__plugin.processControlEventUnlessDisabled(__JMSReceiverFlowControlWindowUpdate(
			receiverId, __processInstanceToken, __flowControlMarker, windowSizeEvents).toString()
		);
	}
	
	/** @private*/ import "JMSPlugin" as __plugin;
}
 00000038 C:\SoftwareAG\Apama 5.1\monitors\CorrelatorJMSEvents.mon
RMDT 00000016 &INPUT(1,17,true,true)
MONF 00002fb9 //*****************************************************************************
// Title:       StatusSupport
// Description: Provides event definitions for generic status reporting from  
//              service monitors.
//
// Revision:    $Revision: 215887 $
//
// $Copyright(c) 2006-2007, 2008-2009, 2011-2012 Progress Software Corporation (PSC). All rights reserved.$
// $Copyright (c) 2013 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or Terracotta Inc., San Francisco, CA, USA, and/or Software AG (Canada) Inc., Cambridge, Ontario, Canada, and/or, Software AG (UK) Ltd., Derby, United Kingdom, and/or Software A.G. (Israel) Ltd., Or-Yehuda, Israel and/or their licensors.$
// Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG
//
//*****************************************************************************

package com.apama.statusreport;

/*
	The events defined in this file act as an API between applications
	or blocks and service monitors.  They provide functionality to 
	Subscribe to status messages.
	
	The aim of this API is to provide an abstraction over any adapter
	specific details - for example, some adapters may require an explicit 
	call to subscribe to such data, some may be sent it anyway.
	
	Any adapter specific information that the application needs to supply
	or be supplied can be passed in the extraParams dictionary - these 
	are free-form (though there are conventions on the keys, see below).
	
	The service monitor also needs to handle any session initiation that
	may be required.
	
	A Status event does not denote a change of state, merely what the current
	state is - in particular, one will be sent out after every 
	SubscribeStatus request.

	All operations and responses are keyed on serviceId (if none-blank), 
	object,	connection and subServiceID. Every event starts with these 4 
	fields.
	
*/


/**
 *	Sent to the service monitor to subscribe to status.
 *	
 */
event SubscribeStatus {
	/**
	 *	service ID to subscribe to - blank will target all services.
	 */
	string serviceID;
	
	/**
	 *	object to request status of - this may include:
	 *	"Connection" - whether connected or not
	 *	"Market" - a market may be "Open", "Closed", or other states
	 */
	string object;
	
	/**
	 *	subService ID to subscribe to.
	 *	Some services may expose several services.  The interpretation of
	 *	this string is adapter-specific.
	 */
	string subServiceID;
	
	/**
	 *	connection to subscribe to.
	 *	Some services may expose several services.  The interpretation of
	 *	this string is adapter-specific.
	 */
	string connection;
}

/**
 *	Sent to the service monitor to unsubscribe from status.
 *	
 */
event UnsubscribeStatus {	 
	/**
	 *	service ID to subscribe to - blank will target all services
	 */
	string serviceID;
	
	/**
	 *	object to request status of - this may include:
	 *	"Connection" - whether connected or not
	 *	"Market" - a market may be "Open", "Closed", or other states
	 */
	string object;
	
	/**
	 *	subService ID to subscribe to.
	 *	Some services may expose several services.  The interpretation of
	 *	this string is adapter-specific.
	 */
	string subServiceID;
	
	/**
	 *	connection to subscribe to.
	 *	Some services may expose several services.  The interpretation of
	 *	this string is adapter-specific.
	 */
	string connection;
}


/**
 *	Sent from the service monitor to notify the application of status for a 
 *	subscribed item.
 *	
 */
event Status {	
	/**
	 *	service ID to subscribe to - blank will target all services
	 */
	string serviceID;
	
	/**
	 *	object to request status of - this may include:
	 *	"Connection" - whether connected or not
	 *	"MarketState" - a market may be "Open", "Closed", or other states
	 */
	string object;
	
	/**
	 *	subService ID to subscribe to.
	 *	Some services may expose several services.  The interpretation of
	 *	this string is adapter-specific.
	 */
	string subServiceID;
	
	/**
	 *	connection to subscribe to.
	 *	Some services may expose several services.  The interpretation of
	 *	this string is adapter-specific.
	 */
	string connection;

	/**
	 *	status description.
	 *	A free-form text string giving a description of the status.
	 */
	string description;
	
	/**
	 *	A sequence of summary strings specifying information about the 
	 *	status of the specified object.  This will be a well recognized
	 *	sequence of words - for example, a financial market's
	 *	"MarketState" may be "Open", "Closed", "PreOpen", etc.  A Connection 
	 *	may be "Connected", "Disconnected", "Disconnected LoginFailed", 
	 *	"Disconnected TimedOut", etc. 
	 */
	sequence<string> summaries;

	/**
	 *	available.
	 *	True if the object is "available" - the exact meaning is adapter 
	 * 	specific; for example, connected, open for general orders, etc.
	 */
	 boolean available;
	 
	 /** 
	 *	extra parameters that do not map into any of the above.  Convention
	 *	is that keys are in TitleCase.  e.g. "Username", "CloseTime", etc.
	 */
	wildcard dictionary <string, string> extraParams;
}


event StatusError {
	/**
	 *	service ID to subscribe to - blank will target all services
	 */
	string serviceID;
	
	/**
	 *	object to request status of - this may include:
	 *	"Connection" - whether connected or not
	 *	"MarketState" - a market may be "Open", "Closed", or other states
	 */
	string object;
	
	/**
	 *	subService ID to subscribe to.
	 *	Some services may expose several services.  The interpretation of
	 *	this string is adapter-specific.
	 */
	string subServiceID;
	
	/**
	 *	connection to subscribe to.
	 *	Some services may expose several services.  The interpretation of
	 *	this string is adapter-specific.
	 */
	string connection;

	/**
	 *	status description.
	 *	A free-form text string giving a description of the status.
	 */
	string description;
	
	/**
	 *	Whether the subscription has been terminated.  Any subscribers will 
	 *	need to send a new SubscribeStatus request after this.
	 */
	boolean failed;
}
	
//*****************************************************************************
// Title:         ParallelStatusSupport
// Description:   ParallelStatusSupport description
// Dependencies:  None
// Author:        arrustem
//
//*****************************************************************************

/*
	Event definitions for block subject event wrappers;
*/
event SubscribeStatusToContext {
	context instanceContext;
	SubscribeStatus subscribe;
}

event UnsubscribeStatusToContext {
	context instanceContext;
	UnsubscribeStatus unsubscribe;
}

monitor ParallelStatusSupport {
	/*	dictionary < [symbol] , sequence of contexts > eventRouter;
	 - eventRouter will keep track of all contexts that are listening to a particular symbol
	 - The same d.s. will be used for both, Status and StatusError
	   since they are added/removed precisely at the same time. 
	*/
	dictionary < SubscribeStatus , sequence<context> > eventRouter;
	
	/*	dictionary < [event key], dictionary < [contextId], [key ctr] > > statusToContextCtr;
	 - Keeps count of number of listeners for each symbol on each context
	*/
	dictionary < SubscribeStatus, dictionary < integer, integer > > statusToContextCtr;

	/*	dictionary < [symbol], listener > statusListeners;
	 - keeps track of the local listeners for Status
		dictionary < [symbol], listener > errorListeners;
	 - keeps track of the local listeners for StatusError
	*/
	dictionary < SubscribeStatus, listener > statusListeners;
	dictionary < SubscribeStatus, listener > errorListeners;
	
	action onload() {
		// set up listeners for the wrapped events coming from subjects
		SubscribeStatusToContext subscribe;
		on all SubscribeStatusToContext():subscribe subscribeEventHandler(subscribe);
		
		UnsubscribeStatusToContext unsubscribe;
		on all UnsubscribeStatusToContext():unsubscribe unsubscribeEventHandler(unsubscribe);
	}
	
	action ondie() {
                // print out an error if statusToContextCtr is not empty
                if (statusToContextCtr.size() != 0) then {
                        log "ParallelStatusSupport is terminating but there may still be contexts subscribed to Status events" at ERROR;
                }
                else {
                        log "ParallelStatusSupport is terminating" at INFO;
                }
	}
	
	action onunload() {
		// not doing anything here since it is assumed that only one instance of this monitor is executing 
	}
	
	action subscribeEventHandler(SubscribeStatusToContext evt) {
		
		SubscribeStatus key := evt.subscribe;
		integer cId := evt.instanceContext.getId();
		
		// manage statusToContextCtr
		if not statusToContextCtr.hasKey(key) then {
			dictionary <integer, integer> entry := {cId:0};
			statusToContextCtr.add(key, entry);
		}
		else {
			if not statusToContextCtr[key].hasKey(cId) then {
				statusToContextCtr[key].add(cId, 0);
				
			}
		}
		statusToContextCtr[key][cId] := statusToContextCtr[key][cId] + 1;
		
		// manage eventRouter
		if not eventRouter.hasKey(key) then {
			sequence < context > entry := [];
			eventRouter.add(key, entry);
			addListener(key);
		}
		// look up context in the symbol
		if (eventRouter[key].indexOf(evt.instanceContext) = -1) then {
			eventRouter[key].append(evt.instanceContext);
		}

		route evt.subscribe;
	}

	action unsubscribeEventHandler(UnsubscribeStatusToContext evt) {
		
		// SubscribeStatus type for the "key" variable is only for the purposes of matching with the dictionary type 
		SubscribeStatus key := SubscribeStatus(evt.unsubscribe.serviceID, evt.unsubscribe.object, 
							   evt.unsubscribe.subServiceID, evt.unsubscribe.connection);
		
		integer cId := evt.instanceContext.getId();
		
		// manage statusToContextCtr
		if ((not statusToContextCtr.hasKey(key)) or 
			(not statusToContextCtr[key].hasKey(cId))) then {
			log "unsubscribeEventHandler: unexpected UnsubscribeStatusToContext received for (key=" + 
				key.toString() + ", contextId=" + cId.toString() + ")" at WARN;
		}
		else {
			statusToContextCtr[key][cId] := statusToContextCtr[key][cId] - 1;
			if (statusToContextCtr[key][cId] = 0) then {
				statusToContextCtr[key].remove(cId);
				integer i := eventRouter[key].indexOf(evt.instanceContext);
				if (i != -1) then {
					eventRouter[key].remove(i);
				}
			}
			if (statusToContextCtr[key].size() = 0) then {
				eventRouter.remove(key);
				removeListener(key);
			}
		}

		route evt.unsubscribe;
	}
	
	action addListener(SubscribeStatus evt) {
		listener dl, el;

		Status d;
		dl := on all Status(serviceID=evt.serviceID, object=evt.object, subServiceID=evt.subServiceID, connection=evt.connection):d {
			enqueue d to eventRouter[evt];
		}
		if statusListeners.hasKey(evt) then {
			log "[action addListener] statusListeners already contains a listener for entry " + evt.toString() at WARN;
		}
		else {
			statusListeners.add(evt, dl);
		}
		
		StatusError e;
		el := on all StatusError(serviceID=evt.serviceID, object=evt.object, subServiceID=evt.subServiceID, connection=evt.connection):e {
			enqueue e to eventRouter[evt];
		}
		if errorListeners.hasKey(evt) then {
			log "[action addListener] errorListeners already contains a listener for entry " + evt.toString() at WARN;
		}
		else {
			errorListeners.add(evt, el);
		}
	}
	
	action removeListener(SubscribeStatus evt) {

		if statusListeners.hasKey(evt) then {
			statusListeners[evt].quit();
			statusListeners.remove(evt);
		}
		else {
			log "[action removeListener] statusListeners does not contain a listener for entry " + evt.toString() at WARN;			
		}
		
		if errorListeners.hasKey(evt) then {
			errorListeners[evt].quit();
			errorListeners.remove(evt);
		}
		else {
			log "[action removeListener] errorListeners does not contain a listener for entry " + evt.toString() at WARN;			
		}
	}
}

 00000032 C:\SoftwareAG\Apama 5.1\monitors\StatusSupport.mon
RMDT 00000015 &INPUT(1,7,true,true)
CONN 0000003c 3852671336013955072/3852671336013955072 from 127.0.0.1:62323
TIME 0000000e 1444006032.9,1
MONF 00003423 /*
 * Apama Correlator-integrated JMS Status Manager service.
 *
 * Implements the StatusSupport event interface to allow an EPL application to 
 * monitor status information about the status of Correlator-Integrated JMS connections, 
 * senders and receivers.
 * 
 * $Copyright (c) 2012 Progress Software Corporation and/or its subsidiaries and affiliates. All rights reserved.$ 
 * $Copyright (c) 2013 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or Terracotta Inc., San Francisco, CA, USA, and/or Software AG (Canada) Inc., Cambridge, Ontario, Canada, and/or, Software AG (UK) Ltd., Derby, United Kingdom, and/or Software A.G. (Israel) Ltd., Or-Yehuda, Israel and/or their licensors.$ 
 * Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG 
 *
 */
package com.apama.correlator.jms;

using com.apama.correlator.jms.JMSConnectionStatus;
using com.apama.correlator.jms.JMSSenderStatus;
using com.apama.correlator.jms.JMSReceiverStatus;
using com.apama.statusreport.Status;
using com.apama.statusreport.StatusError;
using com.apama.statusreport.SubscribeStatus;
using com.apama.statusreport.UnsubscribeStatus;


/**
 * Provides a bridge between the JMS-specific status events and the generic 
 * StatusSupport API used by some Apama applications. 
 *
 * @see com.apama.statusreport.SubscribeStatus Generic StatusSupport 
 * status subscription request that an application may route to this monitor.
 * @see com.apama.statusreport.Status Generic StatusSupport 
 * status information routed to the application by this monitor for subscribed 
 * objects.
 */
monitor CorrelatorJMSStatusManager 
{
	dictionary<SubscribeStatus, integer> subs;

	dictionary<string, JMSConnectionStatusPublisher> csPubs;
	dictionary<string, JMSSenderStatusPublisher> ssPubs;
	dictionary<string, JMSReceiverStatusPublisher> rsPubs;

	action onload() 
	{
		// Set up listeners for client requests
		listenForSubscribeStatus();
		listenForUnsubscribeStatus();
	
		// Set up listeners for correlator-jms status events
		listenForNewJmsEntities();
	}

	action ondie()
	{
		//Can't distinguish between abnormal termination and shutdown,
		//so just log a message to indicate termination.
		log "CORRELATOR_JMS status manager has terminated." at INFO;
	}

	action listenForSubscribeStatus()
	{
		SubscribeStatus newSub;
		on all SubscribeStatus("CORRELATOR_JMS", *, *, *):newSub
		{
			if isValidSubscription(newSub) then 
			{
				log "Received status subscription: " + newSub.toString() at INFO;

				if subs.hasKey(newSub) then { subs.add(newSub, subs[newSub] + 1); }
				else { subs.add(newSub, 1); }

				boolean atLeastOneAckSent := false;
				
				JMSConnectionStatusPublisher csPub;
				for csPub in csPubs.values()
				{
					atLeastOneAckSent := csPub.ackMatchingNewSub(newSub) or atLeastOneAckSent;
				}

				JMSSenderStatusPublisher ssPub;
				for ssPub in ssPubs.values()
				{
					atLeastOneAckSent := ssPub.ackMatchingNewSub(newSub) or atLeastOneAckSent;
				}

				JMSReceiverStatusPublisher rsPub;
				for rsPub in rsPubs.values()
				{
					atLeastOneAckSent := rsPub.ackMatchingNewSub(newSub) or atLeastOneAckSent;
				}

				if not atLeastOneAckSent then 
				{
					log "No status events received yet from entities matching subscription: " + newSub.toString() at INFO;
					sequence<string> summaries := [ "UNKNOWN" ];
					dictionary<string,string> extraParams := {};	
					Status status := Status("CORRELATOR_JMS", newSub.object, newSub.subServiceID, newSub.connection, "No status events received yet from entities matching subscription", summaries, false, extraParams);
					route status; 
				}
			}
		}
	}

	action listenForUnsubscribeStatus() 
	{
		UnsubscribeStatus unsub;
		on all UnsubscribeStatus("CORRELATOR_JMS", *, *, *):unsub
		{
			if isValidUnsubscription(unsub) then
			{
				log "Received status unsubscription: " + unsub.toString() at INFO;
				SubscribeStatus key := SubscribeStatus(unsub.serviceID, unsub.object, unsub.subServiceID, unsub.connection);
	
				if subs.hasKey(key) then
				{
					if subs[key] <= 1 then
					{
						subs.remove(key);	
					}
					else { subs[key] := subs[key] - 1; }
				}
				else
				{
					log "No subscription exists that matches unsubscription: " + unsub.toString() at DEBUG;
				}
			}
		}
	}

	action listenForNewJmsEntities()
	{
		JMSConnectionStatus cs;
		on all JMSConnectionStatus():cs
		{
			if not csPubs.hasKey(cs.connectionId) then
			{
				log "Received connection status from new connection: " + cs.toString() at DEBUG;
				JMSConnectionStatusPublisher csPub := new JMSConnectionStatusPublisher;
				csPub.activate(cs, subs);
				csPubs.add(cs.connectionId, csPub);
			}
		}	

		JMSSenderStatus ss;
		on all JMSSenderStatus():ss
		{
			if not ssPubs.hasKey(ss.connectionId + ":" + ss.senderId) then
			{
				log "Received sender status from new sender: " + ss.toString() at DEBUG;
				JMSSenderStatusPublisher ssPub := new JMSSenderStatusPublisher;
				ssPub.activate(ss, subs);
				ssPubs.add(ss.connectionId + ":" + ss.senderId, ssPub);
			}
		}	

		JMSReceiverStatus rs;
		on all JMSReceiverStatus():rs
		{
			if not rsPubs.hasKey(rs.connectionId + ":" + rs.receiverId) then
			{
				log "Received receiver status from new receiver: " + rs.toString() at DEBUG;
				JMSReceiverStatusPublisher rsPub := new JMSReceiverStatusPublisher;
				rsPub.activate(rs, subs);
				rsPubs.add(rs.connectionId + ":" + rs.receiverId, rsPub);
			}
		}	
	}

	action isValidSubscription(SubscribeStatus sub) returns boolean 
	{ 
		return isValidSubOrUnsub(sub.serviceID, sub.object, sub.subServiceID, sub.connection, "SubscribeStatus", sub.toString()); 
	}	

	action isValidUnsubscription(UnsubscribeStatus unsub) returns boolean 
	{ 
		return isValidSubOrUnsub(unsub.serviceID, unsub.object, unsub.subServiceID, unsub.connection, "UnsubscribeStatus", unsub.toString()); 
	}	

	action isValidSubOrUnsub(string serviceID, string object, string subServiceID, string connection, string requestType, string asString) returns boolean
	{
		string errMsg;
		if serviceID = "CORRELATOR_JMS" then
		{
			if object = "" then
			{
				if not subServiceID = "" then
				{
					errMsg := "Invalid CORRELATOR_JMS " + requestType + " (subServiceID must be \"\" when object is \"\"): " + asString;	
					route StatusError(serviceID, object, subServiceID, connection, errMsg, true);
					return false;
				}
			}
			else if object = "CONNECTION" then
			{
				if connection = "" then
				{
					errMsg := "Invalid CORRELATOR_JMS " + requestType + " (connection may not be \"\" when object is \"CONNECTION\"): " + asString;
					route StatusError(serviceID, object, subServiceID, connection, errMsg, true);
					return false;
				}

				if not subServiceID = "" then
				{
					errMsg := "Invalid CORRELATOR_JMS " + requestType + " (subServiceID must be \"\" when object is \"CONNECTION\"): " + asString;	
					route StatusError(serviceID, object, subServiceID, connection, errMsg, true);
					return false;
				}
			}
			else if object = "SENDER" or object = "RECEIVER" then
			{
				if connection = "" then
				{
					errMsg := "Invalid CORRELATOR_JMS " + requestType + " (connection may not be \"\" when object is \"" + object + "\"): " + asString;
					route StatusError(serviceID, object, subServiceID, connection, errMsg, true);
					return false;
				}

				if subServiceID = "" then
				{
					errMsg := "Invalid CORRELATOR_JMS " + requestType + " (subServiceID may not be \"\" when object is \"" + object + "\"): " + asString;	
					route StatusError(serviceID, object, subServiceID, connection, errMsg, true);
					return false;
				}
			}
			else
			{ 
				errMsg := "Invalid CORRELATOR_JMS " + requestType + " (valid values for object field are \"CONNECTION\", \"SENDER\", \"RECEIVER\" or \"\"): " + asString;
				route StatusError(serviceID, object, subServiceID, connection, errMsg, true);
				return false; 
			} 
			
			return true;
		}
		else 
		{ 
			errMsg := "Unexpected request to validate non-CORRELATOR_JMS " + requestType + " (serviceID must be CORRELATOR_JMS): " + asString;
			route StatusError(serviceID, object, subServiceID, connection, errMsg, true);
			return false; 
		}
	}

	event JMSConnectionStatusPublisher
	{
		JMSConnectionStatus current;	
		dictionary<SubscribeStatus, integer> allSubs;
		
		action activate(JMSConnectionStatus cs, dictionary<SubscribeStatus, integer> subs) 
		{
			current := cs;
			allSubs := subs;

			if existsMatchingSub() then { sendStatus(); }

			JMSConnectionStatus update;
			on all JMSConnectionStatus(current.connectionId, *, *, *):update
			{
				current := update;	
				if existsMatchingSub() then { sendStatus(); }	
			}
		}

		action existsMatchingSub() returns boolean 
		{ 
			SubscribeStatus sub;
			for sub in allSubs.keys()
			{
				if matches(sub) then { return true; }
			}
			return false;
		}

		action matches(SubscribeStatus sub) returns boolean
		{
			return (sub.object = "" and (sub.connection = "" or sub.connection = current.connectionId)) or 
	 			(sub.object = "CONNECTION" and sub.connection = current.connectionId);
		}

		action ackMatchingNewSub(SubscribeStatus newSub) returns boolean 
		{ 
			if matches(newSub) then
			{
				sendStatus();
				return true;
			} 
			return false;
		}

		action sendStatus() 
		{
			boolean available := false;
			if (current.status = JMSConnectionStatus.OK) then { available := true; }

			sequence<string> summaries := [ current.status ];
			dictionary<string,string> extraParams := {};	
			Status status := Status("CORRELATOR_JMS", "CONNECTION", "", current.connectionId, current.errorMessage, summaries, available, extraParams);
			route status; 
		}
	}

	event JMSSenderStatusPublisher
	{
		JMSSenderStatus current;	
		dictionary<SubscribeStatus, integer> allSubs;

		action activate(JMSSenderStatus ss, dictionary<SubscribeStatus, integer> subs) 
		{
			current := ss;
			allSubs := subs;

			if existsMatchingSub() then { sendStatus(); }

			JMSSenderStatus update;
			on all JMSSenderStatus(current.connectionId, current.senderId, *, *, *, *, *):update
			{	
				current := update;	
				if existsMatchingSub() then { sendStatus(); }	
			}
		}

		action existsMatchingSub() returns boolean 
		{ 
			SubscribeStatus sub;
			for sub in allSubs.keys()
			{
				if matches(sub) then { return true; }
			}
			return false;
		}

		action matches(SubscribeStatus sub) returns boolean
		{
			return (sub.object = "" and (sub.connection = "" or sub.connection = current.connectionId)) or 
	 			(sub.object = "SENDER" and sub.connection = current.connectionId and sub.subServiceID = current.senderId);
		}

		action ackMatchingNewSub(SubscribeStatus newSub) returns boolean 
		{
			if matches(newSub) then
			{
				sendStatus();
				return true;
			} 
			return false;
		}

		action sendStatus() 
		{
			boolean available := false;
			if (current.status = JMSSenderStatus.OK) then { available := true; }

			sequence<string> summaries := [ current.status ];
			dictionary<string,string> extraParams := {};	
			Status status := Status("CORRELATOR_JMS", "SENDER", current.senderId, current.connectionId, current.errorMessage, summaries, available, extraParams);
			route status; 
		}
	}

	event JMSReceiverStatusPublisher
	{
		JMSReceiverStatus current;	
		dictionary<SubscribeStatus, integer> allSubs;

		action activate(JMSReceiverStatus rs, dictionary<SubscribeStatus, integer> subs) 
		{
			current := rs;
			allSubs := subs;

			if existsMatchingSub() then { sendStatus(); }
			
			JMSReceiverStatus update;
			on all JMSReceiverStatus(current.connectionId, current.receiverId, *, *, *, *, *, *, *, *, *):update
			{
				current := update;	
				if existsMatchingSub() then { sendStatus(); }	
			}
		}

		action existsMatchingSub() returns boolean 
		{ 
			SubscribeStatus sub;
			for sub in allSubs.keys()
			{
				if matches(sub) then { return true; }
			}
			return false;
		}

		action matches(SubscribeStatus sub) returns boolean
		{
			return (sub.object = "" and (sub.connection = "" or sub.connection = current.connectionId)) or 
	 			(sub.object = "RECEIVER" and sub.connection = current.connectionId and sub.subServiceID = current.receiverId);
		}

		action ackMatchingNewSub(SubscribeStatus newSub) returns boolean 
		{
			if matches(newSub) then
			{
				sendStatus();
				return true;
			} 
			return false;
		}

		action sendStatus() 
		{
			boolean available := false;
			if (current.status = JMSReceiverStatus.OK) then { available := true; }
			log "Sending receiver status report in response to status event: " + current.toString() at DEBUG;

			sequence<string> summaries := [ current.status ];
			dictionary<string,string> extraParams := {};	
			Status status := Status("CORRELATOR_JMS", "RECEIVER", current.receiverId, current.connectionId, current.errorMessage, summaries, available, extraParams);
			route status; 
		}
	}
}
 0000003f C:\SoftwareAG\Apama 5.1\monitors\CorrelatorJMSStatusManager.mon
RMDT 00000015 &INPUT(1,1,true,true)
EVNT 00000077 1829400198888423424 com.apama.scenario.RequestScenarios("com.apama.scenario.private_1829406886152699954_1444006032864")
RMDT 00000015 &INPUT(1,1,true,true)
RMDT 0000001f &REPLAY_ID("EmittedSeqNum",1,1)
RMDT 0000001f &REPLAY_ID("EmittedSeqNum",1,2)
MONF 00000a87 //*****************************************************************************
// Title:       ScenarioDeleterSupport
// Description: Provides event definitions for deleting Scenario instances. 
//
// Revision:    $Id: ScenarioDeleterSupport.mon 215887 2013-10-28 13:26:52Z matj $
//
// $Copyright(c) 2004-2005, 2008-2009 Progress Software Corporation (PSC). All rights reserved.$
// $Copyright (c) 2013 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or Terracotta Inc., San Francisco, CA, USA, and/or Software AG (Canada) Inc., Cambridge, Ontario, Canada, and/or, Software AG (UK) Ltd., Derby, United Kingdom, and/or Software A.G. (Israel) Ltd., Or-Yehuda, Israel and/or their licensors.$
// Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG
//
//*****************************************************************************

package com.apama.scenarios;

event DeleteAllScenarios {
}

event DeleteScenariosByUser {
	string owner;
}

event SubscribeDeleteScenariosToContext {
	context instanceContext;
}

event UnsubscribeDeleteScenariosToContext {
	context instanceContext;
}

monitor ScenarioDeleterSupport {
	
	dictionary<integer, context> deleteContexts;
	dictionary<integer, integer> deleteListenerCounts;
	
	
	action onload() {
		
		SubscribeDeleteScenariosToContext sds;
		on all SubscribeDeleteScenariosToContext():sds {
			integer ctxId := sds.instanceContext.getId(); 
			deleteContexts[ctxId] := sds.instanceContext;
			if (deleteListenerCounts.hasKey(ctxId)) then {
				deleteListenerCounts[ctxId] := deleteListenerCounts[ctxId] + 1; 
			} else {
				deleteListenerCounts[ctxId] := 0;
			}

		}

		UnsubscribeDeleteScenariosToContext uds;
		on all UnsubscribeDeleteScenariosToContext():uds {
			integer ctxId := uds.instanceContext.getId(); 
			deleteContexts[ctxId] := uds.instanceContext;
			if (deleteListenerCounts.hasKey(ctxId)) then {
				if (deleteListenerCounts[ctxId] > 0) then {
					deleteListenerCounts[ctxId] := deleteListenerCounts[ctxId] - 1; 
				} 
				if (deleteListenerCounts[ctxId] = 0) then {
					deleteListenerCounts.remove(ctxId);
				}
			} 
		}

		
		DeleteAllScenarios deleteAll;
		on all DeleteAllScenarios():deleteAll {
			integer cid;
			for cid in deleteContexts.keys() {
				enqueue deleteAll to deleteContexts[cid];
			}
		}
		
		DeleteScenariosByUser deleteByUser;
		on all DeleteScenariosByUser():deleteByUser {
			integer cid;
			for cid in deleteContexts.keys() {
				enqueue deleteByUser to deleteContexts[cid];
			}
		}
	}
	
}
 0000004c C:\SoftwareAG\Apama 5.1\monitors\scenario_support\ScenarioDeleterSupport.mon
RMDT 00000015 &INPUT(1,5,true,true)
MONF 0000037a //*****************************************************************************
// Title:         SensorEvents
// Description:   SensorEvents description
// Dependencies:  None
// Author:        ydhimate
//
//*****************************************************************************

package com.prosoftgroup.klgame;

event AddSensor {
	string	sensorName;
}

event UserObject {
	string	userId;
	string	name;
	string	beaconId;
	string	regionLabel;
	string	timestamp;
	string	eventType;
}

event HelloWorld {
	string message;
}

event IWStatus {
	string iwstatus;
	string destination;
}

event IWRegion {
	string iwregion;
	string destination;
}

event IWCustomer {
	string iwcustomer;
	string destination;
}

event RegionCount {
	string regionLabel;
	integer count;
}

event UserCount {
	string userId;
	string name;
	integer count;
}
 0000005d C:\SoftwareAG\ApamaWork_5.1\studio_workspace\Prosoft_IW2015\eventdefinitions\SensorEvents.mon
RMDT 00000015 &INPUT(1,8,true,true)
TIME 0000000c 1444006033,1
MONF 000010e3 //*****************************************************************************
// Title:         SensorMonitors
// Description:   SensorMonitors description
// Dependencies:  None
// Author:        ydhimate
//
//*****************************************************************************

package com.prosoftgroup.klgame;
using com.apama.correlator.jms.JMS;
using com.apama.aggregates.count;

// TODO: Monitors and event definitions here

monitor SensorMonitors {
	
	JMS jms;
	sequence <string> names;
	UserObject userObject;
	float regionEntryTime := 0.0;
	float timeInRegion := 0.0;
	string currentRegion := "";
	float dealTime := 0.0;
	constant float IDLE_TRIGGER := 12.0;
	constant float DEAL_TRIGGER := 30.0;
	constant float DEAL_WAIT := 30.0;
	
	
	action onload() {
		
		on all UserObject() : userObject {
			integer index;
			index := names.indexOf(userObject.userId);
			
			if index = -1 then{

				names.append(userObject.userId);
				spawn sensorHandler (userObject.userId);
				route userObject;
			}
			
		}
		
		stream <UserObject> regionStream := all UserObject();
		
		UserObject region;
		RegionCount rcount;
		from region in regionStream within 3600.0
		  group by region.regionLabel
		  select RegionCount(region.regionLabel, count()):rcount {
			emit IWRegion(rcount.regionLabel + "|" + rcount.toString(), 
			              "topic:IWCustomer") to "jms:UniversalMessaging-default-sender"; 
			//print "Count for region " + rcount.regionLabel + " - " + rcount.count.toString(); 
		}
		
//		UserObject user;
//		UserCount ucount;
		
//		from user in regionStream 
//		  partition by user.regionLabel within 3600.0
//		  group by user.userId, user.regionLabel
//		  select UserCount(user.regionLabel, user.userId, count()):ucount {
//			print "Count for user " + ucount.name + " - " + ucount.count.toString(); 
//		}
		
		jms.onApplicationInitialized();

		
		
		
		HelloWorld hello;
		on all HelloWorld ():hello {
	
		log "Received Hello World " + hello.toString();
		
		emit hello to "jms:UniversalMessaging-default-sender";
	
	}
	
	}
	
	action sensorHandler (string id) {
		UserObject sensorObject;
		boolean sendDeal := false;
		string status := "";
		string dealRemark := "Analyzing user data";
		on all UserObject(userId=id) : sensorObject {
			
			//log "Received event " + sensorObject.toString();
			
			if currentRegion = "" then {
				currentRegion := sensorObject.regionLabel;
			}
			
			if currentRegion = sensorObject.regionLabel then {
				if regionEntryTime = 0.0 then {
					regionEntryTime := currentTime;
				}
				
				timeInRegion := currentTime - regionEntryTime;
				
				if timeInRegion >= DEAL_TRIGGER then {
					if dealTime = 0.0 then {
						sendDeal := true;
						dealTime := currentTime;
						
						dealRemark := " Send deal to user " + sensorObject.name; 
					
					}
					else if (currentTime - dealTime) > DEAL_WAIT then {
						sendDeal := true;
						dealTime := currentTime;
						
						dealRemark := "Deal sent to user " + sensorObject.name;
					}
					else {
						sendDeal := false;
						dealRemark := "Deal already sent. Wait for the next deal for user " + sensorObject.name;
					}
				}
				
				
				if (timeInRegion >= IDLE_TRIGGER and timeInRegion <= DEAL_TRIGGER) then {
					status := "Idle";
				}
				else if (timeInRegion <= IDLE_TRIGGER) then {
					status := "Active";
				}
				else if (timeInRegion >= DEAL_TRIGGER) then {
					status := "Inactive";
				}
			} 
			else {
				currentRegion := sensorObject.regionLabel;
				regionEntryTime := currentTime;
				timeInRegion := currentTime - regionEntryTime;
				status := "Active";
			}
			
//			print 	"Region Entry Time " + regionEntryTime.toString() + 
//			" Region Time " + timeInRegion.toString()+
//			" Current Region " + currentRegion + 
//			" Deal time " + dealTime.toString() + 
//			" Status " + status;
//			
			emit IWStatus(sensorObject.userId + "|" 
			                + sensorObject.name + "|"
			                + currentRegion + "|" 
			                + status + "|"
			                + dealRemark + "|"
			                + sendDeal.toString(), "topic:IWStatus") to "jms:UniversalMessaging-default-sender";
	
		}
	}
} 00000057 C:\SoftwareAG\ApamaWork_5.1\studio_workspace\Prosoft_IW2015\monitors\SensorMonitors.mon
RMDT 00000015 &INPUT(1,1,true,true)
EVNT 0000004f 0 com.apama.correlator.jms.JMSConnectionStatus("UniversalMessaging","OK","",{})
EVNT 000000b8 0 com.apama.correlator.jms.JMSReceiverStatus("UniversalMessaging","UniversalMessaging-receiver-InnovationWorld","CONNECTING","",{},"topic:InnovationWorld","BEST_EFFORT","","",false,{})
EVNT 00000080 0 com.apama.correlator.jms.JMSSenderStatus("UniversalMessaging","UniversalMessaging-default-sender","OK","",{},"BEST_EFFORT",{})
RMDT 00000015 &INPUT(1,3,true,true)
EVNT 000000b0 0 com.apama.correlator.jms.JMSReceiverStatus("UniversalMessaging","UniversalMessaging-receiver-InnovationWorld","OK","",{},"topic:InnovationWorld","BEST_EFFORT","","",false,{})
RMDT 00000015 &INPUT(1,1,true,true)
EVNT 00000077 3852671336013955072 com.apama.scenario.RequestScenarios("com.apama.scenario.private_3852679161445351425_1444006033314")
TIME 0000000e 1444006033.3,1
RMDT 00000015 &INPUT(1,1,true,true)
RMDT 0000001f &REPLAY_ID("EmittedSeqNum",1,3)
RMDT 0000001f &REPLAY_ID("EmittedSeqNum",1,4)
EVNT 00000046 0 com.prosoftgroup.klgame.UserObject("1","Alok","1","Hall B","1","In")
TIME 0000000c 1444006050,1
RMDT 00000015 &INPUT(1,1,true,true)
RMDT 0000001f &REPLAY_ID("EmittedSeqNum",1,5)
RMDT 0000001f &REPLAY_ID("EmittedSeqNum",1,6)
RMDT 0000001f &REPLAY_ID("EmittedSeqNum",1,7)
EVNT 00000045 0 com.prosoftgroup.klgame.UserObject("3","Ram","1","Hall D","1","In")
TIME 0000000c 1444006052,1
RMDT 00000015 &INPUT(1,1,true,true)
RMDT 0000001f &REPLAY_ID("EmittedSeqNum",1,8)
RMDT 0000001f &REPLAY_ID("EmittedSeqNum",1,9)
RMDT 00000020 &REPLAY_ID("EmittedSeqNum",1,10)
DISC 0000003c 3852671336013955072/3852671336013955072 from 127.0.0.1:62323
DISC 0000003c 1829400198888423424/1829400198888423424 from 127.0.0.1:62325
DISC 00000027 6201958683091171081/3955614762 from R01
DISC 00000036 6201958683091171081/3482309487 from internal:R:control
DISC 00000027 6201958683091171081/1865318693 from S01
